{"version":3,"sources":["webpack:///./node_modules/ractive/ractive.mjs"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mEAAmE;;AAE5F;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,yEAAyE;;AAElF,kCAAkC,wDAAwD;;AAE1F;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C,oCAAoC,UAAU;AAC9C,kEAAkE,UAAU;AAC5E;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sCAAsC;;AAEtD;AACA,4BAA4B,aAAa;AACzC,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA,KAAK;AACL;;AAEA;AACA,4CAA4C,eAAe;AAC3D;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,MAAM;AACxB,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD,4BAA4B,qBAAqB;AACjD,4BAA4B,qBAAqB;AACjD,8BAA8B,qBAAqB,4BAA4B;AAC/E;AACA,gQAAgQ,uHAAuH,eAAe,EAAE;;AAExY;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAqD;AACxE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,2BAA2B;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA,6CAA6C,qBAAqB,EAAE;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,kJAAkJ;;AAE7L;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,aAAa;;AAEjC;AACA;AACA,mBAAmB,mCAAmC;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mFAAmF,iBAAiB,EAAE;AACtG,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,4BAA4B,OAAO;AACnC;;AAEA,oBAAoB,oBAAoB;AACxC;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAoC,WAAW;;AAE/C;AACA,wBAAwB,wBAAwB;;AAEhD;AACA;;AAEA,oBAAoB;AACpB,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,sDAAsD,2BAA2B,EAAE;AACnF;;AAEA;AACA;;AAEA,eAAe,SAAS;;AAExB;AACA;;AAEA;AACA,+CAA+C,8CAA8C;;AAE7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,+CAA+C,4BAA4B,EAAE;AAC7E,GAAG;AACH;AACA;;AAEA;AACA;AACA,mEAAmE,0BAA0B,EAAE;AAC/F;;AAEA;AACA;;AAEA;AACA;;AAEA,uCAAuC,iBAAiB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D,6BAA6B,+CAA+C;AAC5E,YAAY,yCAAyC;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG,OAAO,cAAc;AACxB;;AAEA;AACA;;AAEA,mBAAmB,4BAA4B;;AAE/C;AACA,eAAe,cAAc;;AAE7B;AACA,+DAA+D,aAAa;;AAE5E;AACA,yCAAyC,aAAa;;AAEtD;AACA;AACA;AACA,iFAAiF,aAAa;AAC9F,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qCAAqC;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,uCAAuC,+BAA+B,EAAE,EAAE;AACpG;AACA,uCAAuC,8CAA8C,EAAE;AACvF,sCAAsC,6BAA6B,EAAE;AACrE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,6CAA6C;AAC7E;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,4BAA4B;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iDAAiD,EAAE;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;;AAEA;AACA;AACA;AACA,gDAAgD,wBAAwB;AACxE;;AAEA;AACA;AACA;AACA,qBAAqB,wCAAwC;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB,YAAY;;AAE7B;AACA;AACA;AACA,iBAAiB,8CAA8C;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA,oCAAoC,8BAA8B,EAAE;AACpE,cAAc,2BAA2B;;AAEzC;AACA;AACA,gCAAgC,mCAAmC;AACnE;;AAEA;AACA,cAAc,0BAA0B;;AAExC,iBAAiB,wBAAwB;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,aAAa;;AAElB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,+BAA+B,eAAe;AAC9C;AACA;;AAEA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,KAAK,iBAAiB;AACtB,QAAQ,aAAa;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,yDAAyD;;AAEzF,iBAAiB,2BAA2B;;AAE5C,iBAAiB,qCAAqC;;AAEtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,wCAAwC;;AAE3F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,aAAa;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,wBAAwB;;AAElD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,mDAAmD,EAAE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,qBAAqB,EAAE;AAC/D;;AAEA;AACA;;AAEA;AACA,OAAO,4DAA4D;AACnE,4CAA4C,QAAQ;;AAEpD;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE;AACT;;AAEA;AACA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;AACA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,6BAA6B,6BAA6B;AAC1D,UAAU,oBAAoB;AAC9B;;AAEA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA,uBAAuB;AACvB,uEAAuE,uBAAuB;AAC9F;;AAEA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA,kBAAkB,QAAQ;;AAE1B;;AAEA,aAAa,QAAQ;;AAErB;AACA,yBAAyB,QAAQ;AACjC;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA,GAAG;;AAEH;AACA,kBAAkB,yBAAyB;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sBAAsB,8BAA8B;;AAEpD;;AAEA;AACA,eAAe,SAAS;AACxB,uBAAuB;;AAEvB;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB,4BAA4B;AAC5B,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE,EAAE,cAAc,EAAE;;AAE1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,aAAa;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,iCAAiC;AACjC,sBAAsB,2CAA2C;AACjE;;AAEA;AACA;;AAEA,sBAAsB,2CAA2C;;AAEjE,sBAAsB,wBAAwB;;AAE9C;AACA,oCAAoC;AACpC,aAAa,kCAAkC,kCAAkC;AACjF,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa,2CAA2C,EAAE;;AAEjF,iCAAiC,sCAAsC;;AAEvE;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,EAAE;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;;AAEA;AACA,eAAe,6CAA6C;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sEAAsE;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA,gDAAgD;AAChD;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,6BAA6B;AAC/C,UAAU,kBAAkB;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,aAAa;;AAE9C;;AAEA;;AAEA,cAAc,kCAAkC;;AAEhD;;AAEA,iCAAiC,6BAA6B;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,kCAAkC;;AAElD;;AAEA,mCAAmC,8BAA8B;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,+BAA+B;AAC1D,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO,4BAA4B;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,uCAAuC,6BAA6B,sBAAsB;AAC1F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,mCAAmC,2BAA2B,KAAK;AACnE,SAAS;AACT,mBAAmB,uCAAuC,yCAAyC,EAAE,sBAAsB;AAC3H;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,OAAO;AACP;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC,oBAAoB,aAAa;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0BAA0B;AACnC,WAAW,0BAA0B;AACrC,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gEAAgE,QAAQ;AACxE;AACA,aAAa,wBAAwB;AACrC;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;;AAEA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,eAAe,EAAE,EAAE;;AAEjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,8CAA8C,eAAe,EAAE,EAAE;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,aAAa;;AAEhC;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD,uBAAuB;AACvB;AACA,oCAAoC,0CAA0C;AAC9E,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,qCAAqC,sCAAsC;AAC3E;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,+BAA+B;AACrD;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,sDAAsD;;AAEvF;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D,YAAY,sCAAsC;AAClD,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sDAAsD;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,8CAA8C,2DAA2D;AACzG;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,wBAAwB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB;AAChB,uCAAuC;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA,cAAc,aAAa;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,aAAa;;AAEnD;AACA,4CAA4C;AAC5C;AACA,yBAAyB,sCAAsC;AAC/D;AACA;;AAEA;;AAEA,qCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA,KAAK;AACL,qDAAqD,UAAU;AAC/D,yBAAyB,aAAa,QAAQ,OAAO;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,6CAA6C;;AAE7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;AACA,GAAG;AACH;AACA,aAAa,YAAY;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,iBAAiB,SAAS,EAAE;AAChD;AACA;AACA;;AAEA;AACA,sBAAsB,qCAAqC;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,cAAc;AACd,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM,kBAAkB,SAAS;AACzD;;AAEA;AACA;AACA,gDAAgD,MAAM;AACtD,SAAS;AACT,kCAAkC,WAAW,SAAS,MAAM;AAC5D;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,sBAAsB,iBAAiB,MAAM,gCAAgC,MAAM,SAAS;AAC5F,uBAAuB,iBAAiB,MAAM,gCAAgC,OAAO,SAAS;AAC9F,sBAAsB,uCAAuC,MAAM,aAAa,QAAQ,GAAG;AAC3F;AACA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,iBAAiB,OAAO,gCAAgC,MAAM,SAAS;AAC7F,uBAAuB,uCAAuC,OAAO,aAAa,QAAQ,GAAG;AAC7F;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,aAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,kBAAkB,EAAE;AACvD;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,GAAG;;AAEvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA,gCAAgC,GAAG;AACnC;AACA;AACA,gBAAgB;AAChB,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,yBAAyB,EAAE;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,0FAA0F;AAC1F;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,yEAAyE;AACzE;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,SAAS,gBAAgB,uDAAuD,EAAE;AAClF,YAAY,kCAAkC;AAC9C,KAAK,mCAAmC,WAAW;;AAEnD;AACA;AACA,SAAS,gBAAgB,sDAAsD,EAAE;AACjF,YAAY,cAAc,sBAAsB;AAChD,KAAK,uCAAuC,aAAa;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,+CAA+C,eAAe,EAAE;AAChE,iEAAiE,sBAAsB,EAAE;;AAEzF;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;AACL,iDAAiD,eAAe,EAAE;AAClE,mEAAmE,sBAAsB,EAAE;;AAE3F;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sCAAsC,2BAA2B;AACjE;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,yBAAyB;;AAE1D;AACA,2BAA2B,8BAA8B;AACzD,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,uCAAuC;AACxD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC;;AAElC,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,oCAAoC;;AAEjE,6BAA6B,mBAAmB;;AAEhD;AACA,uCAAuC;AACvC,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C;;AAE9C,kCAAkC,yBAAyB;AAC3D;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,IAAI;AAC/C,wBAAwB,mBAAmB;AAC3C;AACA,uDAAuD,sBAAsB,EAAE;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,2BAA2B;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,IAAI;AACT,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,gCAAgC;AACjE;AACA,mBAAmB,WAAW,SAAS,oCAAoC;AAC3E;AACA;;AAEA;AACA,gCAAgC,uBAAuB;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,kBAAkB,EAAE;AAC1D,wDAAwD,kBAAkB,EAAE;AAC5E;AACA;;AAEA;AACA,4DAA4D,QAAQ;;AAEpE;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,+BAA+B;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,oCAAoC;;AAEpE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,4CAA4C,4BAA4B,EAAE;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,+BAA+B,iCAAiC;AAChE,UAAU,sCAAsC;;AAEhD;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,iBAAiB,QAAQ;;AAEzB;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,iBAAiB,0BAA0B;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,kBAAkB;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uBAAuB;AAC5B;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,aAAa,oBAAoB;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;;AAEA;AACA,sBAAsB,cAAc;;AAEpC;AACA,oBAAoB,cAAc;AAClC,wBAAwB,kBAAkB;;AAE1C;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;;AAEpC;AACA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,iCAAiC;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oBAAoB,QAAQ;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,+BAA+B;AAC/E;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,oBAAoB;;AAE1C;AACA,iDAAiD,iCAAiC,EAAE;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD,OAAO;AACP;AACA;AACA,+BAA+B,sBAAsB;;AAErD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,0BAA0B,wBAAwB;;AAElD;AACA;AACA;;AAEA;AACA,yBAAyB,mCAAmC;AAC5D;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;;AAExC;AACA,kCAAkC,4BAA4B;AAC9D,YAAY,sCAAsC;AAClD;AACA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,4CAA4C;AACjE,wBAAwB,eAAe;AACvC;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gFAAgF,aAAa;AAC7F;AACA;;AAEA,yCAAyC,aAAa;;AAEtD;AACA,uCAAuC,8BAA8B;AACrE,UAAU,6CAA6C;;AAEvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,oBAAoB;;AAEhF;AACA;;AAEA;AACA,qBAAqB,+BAA+B;;AAEpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,wBAAwB;;AAEpD;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD,wBAAwB,2CAA2C,sCAAsC,EAAE,EAAE;AAC7G;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA,iBAAiB,kBAAkB;AACnC,yCAAyC;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,+BAA+B;;AAEnD;AACA,uBAAuB,uEAAuE;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,MAAM,uBAAuB,OAAO;AAC7D,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;AACA,wBAAwB,QAAQ;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,mBAAmB,0DAA0D;AAC7E,YAAY,QAAQ;AACpB,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,oCAAoC,oBAAoB;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,YAAY;AACZ,OAAO,kCAAkC,2DAA2D;AACpG;;AAEA;AACA;AACA,iFAAiF,iBAAiB;AAClG;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD,aAAa;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,qCAAqC;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,oBAAoB;AACrD,cAAc,8CAA8C;AAC5D,QAAQ,aAAa;AACrB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,qBAAqB;;AAE1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;;AAEnC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,OAAO,kBAAkB;AAC9B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mFAAmF,2BAA2B,EAAE;AAChH;AACA;;AAEA;AACA,GAAG;AACH;AACA,qFAAqF,4BAA4B,EAAE;AACnH;;AAEA;AACA;;AAEA,gBAAgB;AAChB;AACA;;AAEA;AACA,6CAA6C,yBAAyB;AACtE,4BAA4B,yBAAyB;;AAErD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa,EAAE;AACvC,2BAA2B,eAAe;;AAE1C;AACA,2EAA2E,sBAAsB,EAAE;AACnG;;AAEA,sFAAsF;AACtF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+BAA+B;AAChF;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mGAAmG,qCAAqC,6CAA6C,EAAE,sBAAsB,GAAG,IAAI,0CAA0C,kEAAkE,IAAI,EAAE,GAAG,EAAE;AAC3U;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qCAAqC,uCAAuC,EAAE;AAC9E,GAAG;AACH,0CAA0C,uCAAuC,EAAE;AACnF,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;;AAEA;AACA,4BAA4B,oCAAoC;AAChE;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA,MAAM;AACN;AACA,KAAK,2FAA2F;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C,sBAAsB,kBAAkB;;AAExC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,0BAA0B,yCAAyC;AACnE;;AAEA;;AAEA;AACA,mCAAmC,cAAc,EAAE;AACnD;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mCAAmC;AACvD;;AAEA;AACA;AACA;AACA,KAAK,mCAAmC,iBAAiB;;AAEzD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,6BAA6B,yEAAyE,EAAE;AACxG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,6BAA6B,EAAE;AAC5E;AACA;AACA,yBAAyB,2CAA2C;AACpE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,uFAAuF;;AAE5F;;AAEA,oBAAoB,+BAA+B;AACnD,wBAAwB,4BAA4B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,sBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mCAAmC,cAAc,EAAE;AACnD;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,MAAM;;AAEN;AACA,aAAa,aAAa;;AAE1B;AACA,mBAAmB,2BAA2B;AAC9C,4DAA4D,UAAU;AACtE;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA,MAAM;;AAEN,iCAAiC,qBAAqB;;AAEtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC,qBAAqB;;AAEtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,cAAc;;AAE5B;AACA,6CAA6C,mCAAmC;AAChF,mBAAmB,2BAA2B;AAC9C;AACA,uCAAuC,UAAU;AACjD,kDAAkD,qCAAqC;AACvF;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,OAAO,uDAAuD;AAC9D;AACA;AACA,OAAO,sBAAsB;AAC7B;AACA;AACA,OAAO,kBAAkB;AACzB,UAAU,mBAAmB;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;;AAEA,QAAQ,eAAe;AACvB;AACA;;AAEA,QAAQ,YAAY;AACpB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,aAAa;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB,EAAE;AAC7E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,eAAe,EAAE;AACrE;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,eAAe,UAAU;;AAEnD;AACA;AACA,sBAAsB,cAAc;AACpC,gDAAgD,mCAAmC,EAAE;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAiD;AAClG;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;;AAEA;AACA;AACA,6CAA6C,iBAAiB;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,8CAA8C;;AAE/D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,qCAAqC;AAC3E;AACA,2BAA2B,mDAAmD;AAC9E;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF,cAAc,mDAAmD;AACjE;AACA;AACA;;AAEA,gDAAgD,QAAQ;AACxD,QAAQ,8BAA8B;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA,6BAA6B,mBAAmB;AAChD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,qBAAqB;AACrB,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iDAAiD;AAClG;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D;;AAEA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA,UAAU;AACV;;AAEA;AACA,qEAAqE,oCAAoC,EAAE;AAC3G;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,0CAA0C;;AAErE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,wCAAwC;AAC3E,KAAK,OAAO,sCAAsC;AAClD;AACA;;AAEA;AACA,cAAc,gCAAgC;;AAE9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,kBAAkB;;AAE3E;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,sBAAsB;;AAEpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,QAAQ;;AAEnD;;AAEA,iEAAiE,QAAQ;;AAEzE;AACA;;AAEA,4BAA4B,mCAAmC,wBAAwB,EAAE,EAAE;AAC3F,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,cAAc;;AAE1C,mBAAmB,6BAA6B;AAChD,aAAa,kCAAkC,8BAA8B,EAAE,EAAE;AACjF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,QAAQ;AACzD,sCAAsC,QAAQ;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,QAAQ;;AAE/C;;AAEA,iBAAiB,uBAAuB;AACxC,sDAAsD,UAAU;AAChE;AACA;;AAEA,wCAAwC,WAAW;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qBAAqB;;AAE3C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,iDAAiD,yCAAyC,EAAE;AAC5F,iDAAiD,oEAAoE,EAAE;;AAEvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,mBAAmB,QAAQ;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,eAAe;AACnC;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,uCAAuC,4BAA4B,EAAE;AACrE,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,2BAA2B,2BAA2B;;AAEtD;AACA,iBAAiB,SAAS;AAC1B,uBAAuB,4BAA4B;AACnD;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA,8BAA8B,0CAA0C,UAAU,EAAE,EAAE;;AAEtF;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,yBAAyB,wCAAwC,mBAAmB,EAAE,EAAE,EAAE;AAC1F,6BAA6B,eAAe,EAAE;AAC9C,0BAA0B,wBAAwB,EAAE;AACpD,yBAAyB,yBAAyB;AAClD;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,uCAAuC;;AAE/D;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,+CAA+C;;AAE9D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA,2BAA2B,mBAAmB;;AAE9C,qCAAqC,mBAAmB;;AAExD;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,gCAAgC,EAAE;AAC9E;AACA;AACA;;AAEA,mCAAmC,kBAAkB;AACrD;AACA,OAAO;AACP;AACA,iCAAiC,+BAA+B;AAChE;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,2BAA2B;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA,yBAAyB,qCAAqC,wCAAwC,EAAE,EAAE,EAAE;AAC5G,6BAA6B,eAAe,EAAE;AAC9C,0BAA0B,wBAAwB,EAAE;AACpD,yBAAyB,yBAAyB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,QAAQ;;AAEhC;AACA,0BAA0B,OAAO;AACjC;;AAEA,gBAAgB,SAAS,4DAA4D;AACrF;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8CAA8C,QAAQ;;AAEtD;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gDAAgD,kCAAkC,EAAE;AACpF;;AAEA,iDAAiD,2BAA2B,EAAE;;AAE9E;AACA,8BAA8B,2CAA2C,mBAAmB,gCAAgC,EAAE;AAC9H;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,gDAAgD,kBAAkB,EAAE,EAAE;AAC1G,8CAA8C,8CAA8C,EAAE;;AAE9F;AACA,iDAAiD,8CAA8C,EAAE;AACjG,GAAG;;AAEH;AACA;;AAEA,+BAA+B,GAAG,cAAc,EAAE,iBAAiB;AACnE,4CAA4C;AAC5C;AACA,oDAAoD,EAAE,OAAO,OAAO,KAAK,IAAI,GAAG,GAAG;AACnF;AACA;AACA,iDAAiD,YAAY;;AAE7D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,WAAW;;AAEnD;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;;AAExD;AACA;AACA,iDAAiD,8CAA8C,EAAE;;AAEjG;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,mCAAmC,gBAAgB,EAAE;AACrD;;AAEA;AACA;AACA;AACA,uBAAuB,+BAA+B,EAAE;AACxD,6BAA6B,eAAe,EAAE;;AAE9C;AACA;AACA,uCAAuC,gBAAgB;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB,QAAQ;;AAEjC;AACA;AACA;;AAEA,8BAA8B,QAAQ;;AAEtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;;AAE9B;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iEAAiE;AACjE,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL,sBAAsB,gCAAgC;AACtD,GAAG;;AAEH;AACA;AACA,uBAAuB,QAAQ;;AAE/B,oOAAoO,2CAA2C,EAAE,6CAA6C,MAAM;AACpU;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,YAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,iCAAiC;;AAEtE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8OAA8O,cAAc,oBAAoB,QAAQ,KAAK,qCAAqC,kBAAkB,KAAK;AACzV;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA,6BAA6B,+BAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,QAAQ;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,QAAQ;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA,+BAA+B,eAAe;;AAE9C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD,cAAc;AAClE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,2DAA2D,EAAE;AACjH,6CAA6C,oDAAoD,EAAE;AACnG,6BAA6B,mCAAmC,oCAAoC,EAAE,oBAAoB,eAAe,EAAE,EAAE;AAC7I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+DAA+D,qBAAqB,EAAE;;AAEtF;AACA;AACA,kDAAkD,eAAe,EAAE;AACnE;;AAEA;AACA,qCAAqC,yCAAyC,EAAE;AAChF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,wBAAwB,EAAE;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,+BAA+B;AACrD;;AAEA;AACA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA,uBAAuB,WAAW;;AAElC;AACA;AACA,eAAe;AACf,+BAA+B,sBAAsB,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,qCAAqC;;AAEtE;AACA;AACA;AACA;;AAEA,sCAAsC,0BAA0B;;AAEhE;AACA,0DAA0D,mCAAmC;;AAE7F;AACA;AACA;;AAEA,8BAA8B,UAAU;AACxC,4BAA4B,aAAa,EAAE;;AAE3C,8BAA8B,QAAQ;AACtC;AACA,SAAS,yBAAyB;;AAElC,qCAAqC,0BAA0B;AAC/D;;AAEA;AACA;;AAEA;;AAEA,gDAAgD,QAAQ;AACxD;AACA,gCAAgC,wBAAwB;AACxD,mCAAmC,2BAA2B;AAC9D;;AAEA,yBAAyB,6BAA6B;;AAEtD,qCAAqC,0BAA0B;;AAE/D;AACA;AACA,KAAK,wBAAwB;;AAE7B,qCAAqC,0BAA0B;;AAE/D;AACA;AACA;AACA,OAAO,qCAAqC;AAC5C;AACA;;AAEA;AACA,KAAK,kCAAkC;;AAEvC;AACA;;AAEA;AACA;;AAEA,wBAAwB,iBAAiB;;AAEzC;AACA;;AAEA;AACA,iBAAiB,6BAA6B;AAC9C,GAAG;AACH;AACA;AACA,+EAA+E;;AAE/E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;AAChD,KAAK;AACL;AACA;AACA,iFAAiF;AACjF,iDAAiD,oBAAoB;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,8BAA8B;AACrD;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,0BAA0B;AAC1C,UAAU,uDAAuD;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,cAAc,+BAA+B;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,2BAA2B;AACzC,QAAQ,4FAA4F;AACpG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,oCAAoC;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4EAA4E,QAAQ;;AAEpF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yDAAyD,0BAA0B,EAAE;;AAErF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,yBAAyB;;AAEnD,sCAAsC,iBAAiB;AACvD,2CAA2C,oCAAoC;;AAE/E;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAsC;AACnE;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wBAAwB;;AAEjD;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAAgC,wBAAwB,EAAE;AAC1D;AACA;AACA,WAAW;;AAEX;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,qCAAqC;AACjG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,gCAAgC;AAC5D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,WAAW;AACpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gDAAgD;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,aAAa;AACb,wBAAwB,WAAW;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,4BAA4B;AACpD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD,0BAA0B,uBAAuB;AACjD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gCAAgC;AACxD,+BAA+B,mBAAmB;AAClD,oCAAoC,wBAAwB;AAC5D,UAAU,aAAa;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,4BAA4B;;AAEpD;AACA;;AAEA;AACA,gCAAgC,sCAAsC;AACtE;;AAEA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,yCAAyC,eAAe;AACxD;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,2EAA2E,EAAE;AACpH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gEAAgE,6BAA6B;AAC7F,8BAA8B,+BAA+B;AAC7D,iCAAiC,2CAA2C;;AAE5E;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,4BAA4B;AAC9D,yCAAyC,4BAA4B;;AAErE;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,wBAAwB,+EAA+E;AACvG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,sCAAsC;AACzD,cAAc,4BAA4B;AAC1C;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,2CAA2C,oBAAoB;AAC/D,2CAA2C,aAAa;;AAExD;AACA;AACA,KAAK;AACL;;AAEA;AACA,iFAAiF,aAAa;AAC9F;AACA;;AAEA;AACA,2CAA2C,oBAAoB;;AAE/D;AACA;AACA,eAAe,iBAAiB;AAChC,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,sBAAsB,WAAW;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,oBAAoB,EAAE;AACtF;;AAEA;AACA,4BAA4B,wEAAwE;;AAEpG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,0BAA0B,EAAE,oBAAoB,YAAY,EAAE;;AAEzG;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qCAAqC;AACtD,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB,oDAAoD;AACpG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA,mCAAmC,qCAAqC;AACxE,8BAA8B;;AAE9B;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,iHAAiH;AACjH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,qBAAqB;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,kEAAkE,mBAAmB;AACrF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,qDAAqD,oBAAoB;;AAEzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,oCAAoC;AACvF;;AAEA;AACA;AACA,0BAA0B,wCAAwC;AAClE;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,uDAAuD;AAC/E;;AAEA;AACA,wBAAwB,mDAAmD;AAC3E;;AAEA;AACA,sCAAsC,sBAAsB;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,gDAAgD;AACxE;;AAEA;AACA,wBAAwB,qDAAqD;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,6BAA6B,EAAE;AACzE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,+BAA+B;AACvD;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,iCAAiC;AAClD,YAAY,wCAAwC,0BAA0B,EAAE,EAAE;AAClF;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA,kBAAkB,6BAA6B;;AAE/C;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mCAAmC;;AAE3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+DAA+D,cAAc;;AAE7E;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,OAAO;AACP,gCAAgC,oBAAoB;AACpD,OAAO,EAAE;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD,oBAAoB;AAC7E,0CAA0C,iBAAiB;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;;AAEtB;AACA,0BAA0B,QAAQ;;AAElC;AACA;AACA,aAAa,uCAAuC;;AAEpD,cAAc,eAAe;AAC7B;;AAEA;AACA;AACA,6CAA6C,iBAAiB;AAC9D,eAAe,eAAe;AAC9B;;AAEA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,mCAAmC,QAAQ;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,oBAAoB;AACnD,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC,8BAA8B,EAAE;AACxE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD,6BAA6B,EAAE;AAClF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,QAAQ;;AAEzC;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,+BAA+B;AAClE,QAAQ,mCAAmC,0CAA0C,EAAE,EAAE;;AAEzF;AACA;;AAEA;AACA,gBAAgB,wBAAwB;AACxC,QAAQ,uBAAuB;AAC/B;;AAEA;AACA;;AAEA,8CAA8C,wCAAwC;AACtF;AACA;AACA,sCAAsC,2CAA2C,EAAE;AACnF;AACA;;AAEA;AACA,mBAAmB,0CAA0C;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,sCAAsC,EAAE;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,0BAA0B,iCAAiC,EAAE;AAC7D,uBAAuB,wCAAwC,EAAE;AACjE;AACA;AACA,oDAAoD,aAAa;AACjE,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,iCAAiC;AACpD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,sCAAsC,EAAE;;AAE5F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,uBAAuB;;AAEzC;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB,EAAE;AAClF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,wCAAwC,EAAE;AAC3E,8BAA8B,qCAAqC,EAAE;AACrE;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA,mDAAmD,uBAAuB,EAAE;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D,4BAA4B;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B,kBAAkB,8BAA8B;AAChD,UAAU,6BAA6B;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,qBAAqB,mCAAmC,EAAE;AAC9E;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,wCAAwC,0CAA0C,EAAE;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,cAAc;;AAEnB,qCAAqC,GAAG;AACxC,mDAAmD,aAAa;;AAEhE;AACA;;AAEA;AACA;AACA,KAAK,6EAA6E;;AAElF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,QAAQ;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK,+BAA+B;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,6BAA6B,yBAAyB;;AAEtD,gCAAgC,qBAAqB;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;;AAEhF,+BAA+B,4BAA4B;;AAE3D,kCAAkC,wBAAwB;;AAE1D;AACA;AACA;;AAEA,+CAA+C,oBAAoB;;AAEnE,iDAAiD,uBAAuB;;AAExE,gDAAgD,uBAAuB;;AAEvE;AACA,4BAA4B,uBAAuB;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,uBAAuB;;AAExE;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;;AAEA,gCAAgC,YAAY;AAC5C,oCAAoC,aAAa;AACjD,qCAAqC,YAAY;AACjD,kBAAkB,kBAAkB;;AAEpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B,eAAe,kBAAkB;AACjC,cAAc,oBAAoB;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,OAAO,iBAAiB;AACtD;AACA;;AAEA,wBAAwB,sBAAsB;;AAE9C;AACA,wBAAwB,8BAA8B;AACtD,UAAU,qBAAqB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;;AAEA;AACA,0BAA0B,oCAAoC;AAC9D,wBAAwB,2BAA2B;AACnD;;AAEA;AACA;AACA,yBAAyB,kBAAkB;;AAE3C;AACA;;AAEA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,6DAA6D;;AAErF,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,4CAA4C;AAC5F,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;;AAEA;AACA;AACA,0BAA0B,uCAAuC,6BAA6B,EAAE,EAAE;AAClG,uBAAuB,iCAAiC;AACxD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;;AAEA,qCAAqC,sBAAsB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,gCAAgC;AACtF;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;;AAEA;AACA;AACA;AACA,6EAA6E,WAAW,UAAU,GAAG,EAAE;AACvG;;AAEA;AACA;AACA,uBAAuB,WAAW,SAAS,iCAAiC;AAC5E;AACA,uBAAuB,uBAAuB;;AAE9C;AACA;AACA;AACA,oCAAoC,wDAAwD;AAC5F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,OAAO;AACP,sBAAsB;AACtB;AACA,8FAA8F;AAC9F,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mDAAmD,YAAY,EAAE;AACjE,SAAS;AACT;AACA;AACA;AACA,8EAA8E;AAC9E,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,8BAA8B,kEAAkE;AAChG,4BAA4B,8DAA8D;;AAE1F;AACA,0EAA0E,WAAW,UAAU,GAAG,EAAE;AACpG;;AAEA;;AAEA,gDAAgD,YAAY;;AAE5D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,OAAO,uBAAuB;AAC5D;AACA;;AAEA,uBAAuB,2BAA2B;AAClD,wBAAwB,4BAA4B;AACpD;;AAEA;AACA,yBAAyB,QAAQ;AACjC;;AAEA;AACA;AACA;AACA,4CAA4C,uBAAuB;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,0BAA0B;;AAElD,uBAAuB,yBAAyB;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,SAAS,OAAO,mBAAmB;AAC1D;;AAEA,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;;AAElC;AACA,+BAA+B,cAAc;;AAE7C;;AAEA;AACA;AACA,0CAA0C,aAAa;;AAEvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,SAAS,OAAO,0DAA0D;AACjG;AACA;;AAEA,2DAA2D;AAC3D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,SAAS,OAAO,+BAA+B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,yCAAyC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,8BAA8B;AAC7D,gBAAgB,8BAA8B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB;AACvB;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sCAAsC,qBAAqB,EAAE;AAC7D;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB,+BAA+B;;AAEhD,oCAAoC,uBAAuB,EAAE;AAC7D;;AAEA;AACA,oCAAoC,qBAAqB,EAAE;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB,+BAA+B;;AAEpD;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;;AAEA,sCAAsC,yBAAyB;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oCAAoC,yBAAyB,EAAE;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,uBAAuB,EAAE;AAC7D;;AAEA;AACA,oCAAoC,qBAAqB,EAAE;AAC3D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH,qBAAqB,sCAAsC;AAC3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,YAAY;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;;AAEA,0BAA0B,wBAAwB;;AAElD;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,aAAa;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,YAAY;;AAE1C;AACA,gCAAgC,aAAa;AAC7C;;AAEA;AACA,wBAAwB,eAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA,OAAO;AACP,wCAAwC,uBAAuB;AAC/D;AACA,yBAAyB,mCAAmC;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,sCAAsC,qBAAqB,4BAA4B;AACvF,YAAY;AACZ;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,qBAAqB;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,0BAA0B;AACpE;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,2CAA2C;AAC9E;AACA,kDAAkD,uCAAuC;AACzF;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA,0CAA0C,cAAc;;AAExD;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD,sCAAsC,EAAE;AACzF;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,kCAAkC,EAAE;AAChE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,4BAA4B,yCAAyC,EAAE;AACvE;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sDAAsD,+CAA+C,EAAE;AACvG,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,yCAAyC,6BAA6B,EAAE,EAAE;AACtG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,kBAAkB;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,kCAAkC,6BAA6B,EAAE,EAAE;AACxF;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,gBAAgB,mBAAmB,YAAY,EAAE;AACjD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD,kBAAkB,iCAAiC;AACnD;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;;AAEA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;;AAEA;AACA,CAAC;;AAED;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA,yBAAyB,qBAAqB;AAC9C,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA,wBAAwB,iBAAiB;AACzC,6CAA6C,qDAAqD;AAClG;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,6BAA6B;;AAErD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mBAAmB,cAAc,EAAE;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;;AAEhC;AACA,8BAA8B,cAAc;;AAE5C;AACA;AACA;AACA,eAAe,uCAAuC;AACtD;AACA,gBAAgB,qBAAqB;AACrC;AACA;;AAEA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA,wBAAwB,+BAA+B;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA,qCAAqC,iCAAiC;;AAEtE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,KAAK,KAAK;AACxC,sCAAsC,KAAK,KAAK;AAChD;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA,2BAA2B,aAAa;;AAExC;;AAEA;AACA,gBAAgB;AAChB;AACA,KAAK;;AAEL;AACA;AACA,oBAAoB,SAAS,0BAA0B;AACvD,KAAK;;AAEL;AACA;AACA,mBAAmB,SAAS,cAAc;AAC1C,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,+EAA+E,uCAAuC;AACtH;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,gCAAgC,KAAK,aAAa;;AAElD;;AAEA;;AAEA,+BAA+B;AAC/B,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;;AAEA,iCAAiC;AACjC,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,qCAAqC,aAAa;;AAElD;;AAEA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA,aAAa,aAAa;;AAE1B,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;;AAEjC;AACA;AACA;;AAEA;AACA,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,6BAA6B,oCAAoC;AACjE;AACA;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;;AAEA;;AAEA;AACA,qBAAqB,6BAA6B;AAClD,6BAA6B,iCAAiC;;AAE9D;AACA,4CAA4C,0BAA0B;AACtE;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,+BAA+B,oBAAoB;AACnD,GAAG;AACH;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,iBAAiB;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,8DAA8D;AAC9D,gBAAgB,gBAAgB;;AAEhC;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;;AAEA;AACA,mBAAmB,sCAAsC;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,gBAAgB;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,KAAK,iDAAiD,mBAAmB;AACxG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;;AAE7B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO,oBAAoB;AACxC,yDAAyD,0BAA0B;AACnF,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,2BAA2B;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,0CAA0C;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,iBAAiB;;AAEnC;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,8CAA8C,yCAAyC,EAAE;AACzF;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C,mCAAmC,8BAA8B,EAAE,EAAE;AAC/G,KAAK;AACL;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,iEAAiE,YAAY;;AAE7E;;AAEA,sDAAsD,qBAAqB;AAC3E,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,wDAAwD,uBAAuB;;AAE/E;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,8CAA8C,kCAAkC,EAAE;AAClF;AACA,qCAAqC,sCAAsC;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,yCAAyC;;AAE9D,gBAAgB,kCAAkC;;AAElD;AACA;;AAEA;AACA;AACA,qBAAqB,+CAA+C;AACpE;AACA,uBAAuB,0BAA0B;AACjD,UAAU,qCAAqC;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH,yBAAyB,sBAAsB;AAC/C;AACA,OAAO,yEAAyE;AAChF,GAAG;AACH;AACA,wBAAwB,oCAAoC;AAC5D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE,OAAO,OAAO,oBAAoB;AAClC,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE;AACpE;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,GAAG;;AAEH,oBAAoB,iBAAiB;AACrC,0CAA0C;AAC1C,uCAAuC,uCAAuC;;AAE9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,qCAAqC,EAAE;AAC1G;AACA,8BAA8B,oCAAoC,EAAE;AACpE;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,sBAAsB,qCAAqC;AAC3D;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,8CAA8C;;AAE7D;AACA,eAAe,wCAAwC;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA,sBAAsB,wCAAwC;;AAE9D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uDAAuD,0BAA0B,EAAE;AACnF;AACA,oCAAoC,sBAAsB;AAC1D;AACA,OAAO,2DAA2D;AAClE;;AAEA,sBAAsB,kDAAkD;;AAExE,oBAAoB,uCAAuC;AAC3D,2EAA2E,yBAAyB,EAAE;AACtG;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH,SAAS,cAAc;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;;AAEA,yBAAyB,qBAAqB;AAC9C;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,kCAAkC;AACnE,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA,+CAA+C,+CAA+C,EAAE;AAChG;AACA;;AAEA;AACA,gDAAgD,kCAAkC,EAAE;AACpF;;AAEA;AACA,+CAA+C,qCAAqC,EAAE;AACtF;;AAEA;AACA,+CAA+C,2CAA2C,EAAE;AAC5F;;AAEA;AACA,gDAAgD,uCAAuC,EAAE;AACzF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC,4BAA4B;AACjE;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gCAAgC,mDAAmD;;AAEnF,gCAAgC,6BAA6B;;AAE7D;;AAEA;;AAEA;AACA,0BAA0B,QAAQ;;AAElC;AACA;;AAEA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA,GAAG;;AAEH;;AAEA;AACA,eAAe,eAAe;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA,iBAAiB,SAAS,OAAO,4BAA4B;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,8CAA8C;AAC/E;AACA;AACA,qBAAqB,WAAW,SAAS,wDAAwD;AACjG;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,WAAW,SAAS,uCAAuC;AAClF;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,SAAS,6EAA6E;AACtF,KAAK;AACL;AACA,uBAAuB,WAAW,SAAS,iCAAiC;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,4BAA4B;;AAE5D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,4BAA4B;;AAE9D;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,4CAA4C;AACnE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,qBAAqB,EAAE;;AAE7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,UAAU,OAAO,4CAA4C;;AAE9E,sBAAsB,kDAAkD;;AAExE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD,wEAAwE,WAAW;AACnF;AACA;;AAEA,gCAAgC,WAAW;AAC3C;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC,wEAAwE,WAAW;AACnF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,2CAA2C;;AAElE,0BAA0B,mCAAmC;AAC7D,0BAA0B,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD,oCAAoC,oCAAoC;AACxE,kCAAkC,kCAAkC;AACpE,sCAAsC,sCAAsC;AAC5E,uCAAuC,0CAA0C;AACjF,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,mCAAmC,yCAAyC,kBAAkB,EAAE,KAAK,EAAE;AACvG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,0CAA0C;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,qBAAqB;AAC3D,4BAA4B,wBAAwB;AACpD,2BAA2B,aAAa;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,OAAO,+CAA+C;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,aAAa;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA,wBAAwB,+BAA+B;AACvD;;AAEA;AACA;AACA,wBAAwB,yCAAyC;AACjE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,4BAA4B;AACpD;;AAEA;AACA,yCAAyC,uCAAuC;AAChF;AACA;;AAEA;AACA;;AAEA,sBAAsB,QAAQ;;AAE9B;AACA;AACA;;AAEA,8EAA8E,QAAQ;;AAEtF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA,KAAK;AACL,2CAA2C,uCAAuC;AAClF;AACA;;AAEA;AACA;AACA,OAAO,oDAAoD;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,+BAA+B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,gCAAgC;AACnE;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,QAAQ;;AAE9B;;AAEA;AACA;AACA,qDAAqD,mBAAmB;AACxE,cAAc,oBAAoB;AAClC,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA,uBAAuB,0CAA0C;AACjE;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,uBAAuB;AACvB;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,eAAe;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa,WAAW,EAAE;;AAE1B;AACA,gCAAgC,iBAAiB;;AAEjD,iDAAiD,kCAAkC,EAAE;AACrF;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,+BAA+B,UAAU;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,kCAAkC;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wCAAwC,kDAAkD;AAC1F;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE,yCAAyC,2BAA2B;AACpE;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,6DAA6D,mBAAmB;AAChF;;AAEA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;;AAExC;AACA;AACA;AACA,mBAAmB,kBAAkB;;AAErC;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,WAAW;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB,KAAK;AACL,gBAAgB;AAChB;AACA,GAAG;AACH;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC,8CAA8C;AACtF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,cAAc;;AAEvD;AACA;AACA,KAAK,cAAc;AACnB;AACA,KAAK,cAAc;;AAEnB,gCAAgC;AAChC;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA,qCAAqC,aAAa;AAClD,GAAG;AACH;AACA;AACA,mEAAmE,aAAa;AAChF;;AAEA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,EAAE;AACxC,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,aAAa,EAAE;AAC5D;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,6BAA6B;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE,yCAAyC,2BAA2B;AACpE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,uBAAuB;AAC9B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,cAAc;;AAExD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,qCAAqC,kCAAkC,EAAE,EAAE;AAChG;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAe,SAAS;AACxB;;AAEA,gCAAgC,UAAU;;AAE1C,oCAAoC,aAAa;;AAEjD;AACA,wBAAwB,oBAAoB;AAC5C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,SAAS;AACxB;;AAEA,gCAAgC,UAAU;;AAE1C,oCAAoC,mBAAmB;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,WAAW;AACX,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,uBAAuB;AACpD;;AAEA;AACA;AACA;AACA,kCAAkC,4BAA4B,EAAE;;AAEhE;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO,EAAE;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8DAA8D,+BAA+B;AAC7F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,mCAAmC,qBAAqB,EAAE;AAC1D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,aAAa,yBAAyB,EAAE;AACvD;AACA,QAAQ;AACR,UAAU,kBAAkB;AAC5B,GAAG,OAAO,WAAW;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD;AACjE;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,cAAc,qDAAqD;;AAEnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,wBAAwB;AACzD;;AAEA;AACA;AACA;AACA,mBAAmB,eAAe;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,6BAA6B;AAC9D,uBAAuB,4BAA4B;AACnD,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,kCAAkC,EAAE;AAC/E;;AAEA;AACA;AACA,qCAAqC,kDAAkD,EAAE;AACzF;AACA;;AAEA;AACA,2CAA2C,uCAAuC,EAAE;AACpF;;AAEA;AACA;AACA,qCAAqC,kEAAkE,EAAE;AACzG;AACA;;AAEA;AACA;AACA,+BAA+B,+BAA+B;AAC9D,QAAQ,qBAAqB;AAC7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,iCAAiC,UAAU;;AAE3C;AACA,iBAAiB,aAAa;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sCAAsC,EAAE;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,6DAA6D;AAC7D;AACA,GAAG;;AAEH,gDAAgD;AAChD;;AAEA;AACA,+CAA+C,0BAA0B,EAAE;AAC3E,aAAa,aAAa;AAC1B,mBAAmB,aAAa;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uCAAuC;AAC9D,uBAAuB,uCAAuC;AAC9D;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,6BAA6B,EAAE;AAClE;AACA,yBAAyB,uEAAuE;AAChG,yBAAyB,sDAAsD;AAC/E;AACA;;AAEA;AACA,sBAAsB,kDAAkD;AACxE;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uEAAuE;AAC9F,uBAAuB,sDAAsD;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS,OAAO,8BAA8B;AAC/D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,SAAS,OAAO,yCAAyC;AAC1E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS,OAAO,0BAA0B;AAC/D;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uBAAuB;AACnC,GAAG;AACH;AACA;AACA;AACA,KAAK,OAAO,uBAAuB;AACnC;;AAEA,6BAA6B,4CAA4C;;AAEzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,iEAAiE,qBAAqB,EAAE,GAAG;;AAEhG;;AAEA;;AAEA;AACA,iBAAiB,kCAAkC;;AAEnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2OAA2O;AAC3O;AACA,6DAA6D,mBAAmB;AAChF;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,mCAAmC,EAAE;;AAEzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sBAAsB,YAAY;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,QAAQ;;AAEnC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;;AAE3C;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,qCAAqC;AACnE;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,aAAa;;AAErE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,qBAAqB;;AAE9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA,kBAAkB,iCAAiC;;AAEnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E,sBAAsB,EAAE;AACvG;AACA;AACA;;AAEA;AACA,gFAAgF,gBAAgB,EAAE;AAClG,4DAA4D,8BAA8B,EAAE,IAAI;AAChG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,yDAAyD;AAC5F;;AAEA;AACA;AACA;;AAEA,4BAA4B,4BAA4B,EAAE;AAC1D;AACA;;AAEA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,sBAAsB,uBAAuB;;AAE7C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,oBAAoB,EAAE;AACtD,KAAK,qFAAqF;AAC1F,eAAe,mBAAmB;;AAElC;AACA,wCAAwC,wDAAwD;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,gGAAgG,EAAE;AACzH;AACA;;AAEA;AACA,qCAAqC,oBAAoB,EAAE;AAC3D;;AAEA;AACA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,qCAAqC,2BAA2B;;AAEhE,mCAAmC;AACnC,oCAAoC,IAAI;AACxC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;;AAE9B,aAAa,oDAAoD;AACjE,iBAAiB,wDAAwD;AACzE,iBAAiB,YAAY;AAC7B,UAAU,eAAe;;AAEzB,iBAAiB,oBAAoB;;AAErC,aAAa,gBAAgB;AAC7B,cAAc,iBAAiB;;AAE/B,eAAe,kDAAkD;AACjE,eAAe;AACf,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;;AAEA;AACA,mCAAmC,qBAAqB;AACxD,mCAAmC,qBAAqB;;AAExD;AACA;;AAEA;;AAEA,oCAAoC,uCAAuC;;AAE3E,6BAA6B,qCAAqC;;AAElE;AACA;;AAEA;AACA,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,aAAa,oDAAoD;AACjE,aAAa,sDAAsD;AACnE,WAAW,qDAAqD;AAChE,WAAW;AACX,CAAC;;AAED;AACA,wBAAwB,iDAAiD;;AAEzE;;AAEA;AACA,iBAAiB,YAAY;AAC7B,cAAc,YAAY;AAC1B,cAAc,qDAAqD,GAAG;;AAEtE,eAAe,2BAA2B;AAC1C,eAAe;AACf,GAAG;;AAEH,mCAAmC,0BAA0B;;AAE7D,eAAe,qBAAqB;;AAEpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,6BAA6B;;AAEhE,+BAA+B;AAC/B,gCAAgC,IAAI;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,4DAA4D;;AAE3E;AACA,uCAAuC,uBAAuB;AAC9D,CAAC;AACD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,8BAA8B;AACxC,mBAAmB,8BAA8B;;AAEjD;AACA,WAAW,gBAAgB;AAC3B,eAAe,oBAAoB;AACnC,cAAc,mBAAmB;AACjC,qBAAqB,mBAAmB;AACxC,eAAe,oBAAoB;AACnC,eAAe,sBAAsB;AACrC,WAAW,gBAAgB;AAC3B,eAAe,oBAAoB;AACnC,aAAa,kBAAkB;AAC/B,UAAU,eAAe;AACzB,qBAAqB,mBAAmB;AACxC,UAAU,eAAe;AACzB,iBAAiB,wBAAwB;AACzC;AACA,gBAAgB,qBAAqB;AACrC,QAAQ,eAAe;;AAEvB;AACA,YAAY,+BAA+B;AAC3C,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,YAAY,iBAAiB;;AAE7B;AACA,aAAa,0BAA0B,EAAE;AACzC,eAAe,0BAA0B,EAAE;AAC3C,eAAe,0BAA0B,EAAE;AAC3C,WAAW,gCAAgC;AAC3C,WAAW,0BAA0B,EAAE;AACvC,eAAe,YAAY;AAC3B,YAAY,0CAA0C;AACtD,kBAAkB,uCAAuC;AACzD,aAAa,0BAA0B,EAAE;AACzC,gBAAgB,0BAA0B,EAAE;;AAE5C;AACA,YAAY,8BAA8B,EAAE;;AAE5C;AACA,eAAe,cAAc;;AAE7B;AACA,YAAY,iBAAiB;;AAE7B;AACA,YAAY;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAEc,sEAAO,EAAC;AACvB","file":"./public/js/vendor.js","sourcesContent":["/*\n\tRactive.js v1.3.8\n\tBuild: 2584a0f8b90e1ff96a15df9d956d71e500f8eaa0\n\tDate: Mon Sep 16 2019 20:54:41 GMT+0000 (UTC)\n\tWebsite: https://ractive.js.org\n\tLicense: MIT\n*/\n/* istanbul ignore if */\nif (!Object.assign) {\n  Object.assign = function(target) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    if (target == null) { throw new TypeError('Cannot convert undefined or null to object'); }\n\n    var to = Object(target);\n    var sourcesLength = sources.length;\n\n    for (var index = 0; index < sourcesLength; index++) {\n      var nextSource = sources[index];\n      for (var nextKey in nextSource) {\n        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey)) { continue; }\n        to[nextKey] = nextSource[nextKey];\n      }\n    }\n\n    return to;\n  };\n}\n\nfunction hasOwn(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction fillGaps(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0; i < sources.length; i++) {\n    var source = sources[i];\n    for (var key in source) {\n      // Source can be a prototype-less object.\n      if (key in target || !hasOwn(source, key)) { continue; }\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction toPairs(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  var pairs = [];\n  for (var key in obj) {\n    // Source can be a prototype-less object.\n    if (!hasOwn(obj, key)) { continue; }\n    pairs.push([key, obj[key]]);\n  }\n  return pairs;\n}\n\nvar obj = Object;\n\nvar assign = obj.assign;\n\nvar create = obj.create;\n\nvar defineProperty = obj.defineProperty;\n\nvar defineProperties = obj.defineProperties;\n\nvar keys = obj.keys;\n\nvar toString = Object.prototype.toString;\n\n\nvar isArray = Array.isArray;\n\nfunction isEqual(a, b) {\n  if (a === null && b === null) {\n    return true;\n  }\n\n  if (isObjectType(a) || isObjectType(b)) {\n    return false;\n  }\n\n  return a === b;\n}\n\n// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\nfunction isNumeric(thing) {\n  return !isNaN(parseFloat(thing)) && isFinite(thing);\n}\n\nfunction isObject(thing) {\n  return thing && toString.call(thing) === '[object Object]';\n}\n\nfunction isObjectLike(thing) {\n  return !!(thing && (isObjectType(thing) || isFunction(thing)));\n}\n\nfunction isObjectType(thing) {\n  return typeof thing === 'object';\n}\n\nfunction isFunction(thing) {\n  return typeof thing === 'function';\n}\n\nfunction isString(thing) {\n  return typeof thing === 'string';\n}\n\nfunction isNumber(thing) {\n  return typeof thing === 'number';\n}\n\nfunction isUndefined(thing) {\n  return thing === undefined;\n}\n\n/* istanbul ignore if */\nif (!Array.prototype.find) {\n  defineProperty(Array.prototype, 'find', {\n    value: function value(callback, thisArg) {\n      if (this === null || isUndefined(this))\n        { throw new TypeError('Array.prototype.find called on null or undefined'); }\n\n      if (!isFunction(callback)) { throw new TypeError((callback + \" is not a function\")); }\n\n      var array = Object(this);\n      var arrayLength = array.length >>> 0;\n\n      for (var index = 0; index < arrayLength; index++) {\n        if (!hasOwn(array, index)) { continue; }\n        if (!callback.call(thisArg, array[index], index, array)) { continue; }\n        return array[index];\n      }\n\n      return undefined;\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\n// NOTE: Node doesn't exist in IE8. Nothing can be done.\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  window.Node &&\n  window.Node.prototype &&\n  !window.Node.prototype.contains\n) {\n  Node.prototype.contains = function(node) {\n    var this$1 = this;\n\n    if (!node) { throw new TypeError('node required'); }\n\n    do {\n      if (this$1 === node) { return true; }\n    } while ((node = node && node.parentNode));\n\n    return false;\n  };\n}\n\n/* istanbul ignore if */\nif (typeof window !== 'undefined' && window.performance && !window.performance.now) {\n  window.performance = window.performance || {};\n\n  var nowOffset = Date.now();\n\n  window.performance.now = function() {\n    return Date.now() - nowOffset;\n  };\n}\n\n/* eslint no-console:\"off\" */\nvar win = typeof window !== 'undefined' ? window : null;\nvar doc = win ? document : null;\nvar isClient = !!doc;\nvar base = typeof global !== 'undefined' ? global : win;\nvar hasConsole =\n  typeof console !== 'undefined' && isFunction(console.warn) && isFunction(console.warn.apply);\n\nvar svg = doc\n  ? doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')\n  : false;\n\nvar vendors = ['o', 'ms', 'moz', 'webkit'];\n\n/* istanbul ignore if */\nif (!base.Promise) {\n  var PENDING = {};\n  var FULFILLED = {};\n  var REJECTED = {};\n\n  var Promise$1 = (base.Promise = function(callback) {\n    var fulfilledHandlers = [];\n    var rejectedHandlers = [];\n    var state = PENDING;\n    var result;\n    var dispatchHandlers;\n\n    var makeResolver = function (newState) {\n      return function(value) {\n        if (state !== PENDING) { return; }\n        result = value;\n        state = newState;\n        dispatchHandlers = makeDispatcher(\n          state === FULFILLED ? fulfilledHandlers : rejectedHandlers,\n          result\n        );\n        wait(dispatchHandlers);\n      };\n    };\n\n    var fulfill = makeResolver(FULFILLED);\n    var reject = makeResolver(REJECTED);\n\n    try {\n      callback(fulfill, reject);\n    } catch (err) {\n      reject(err);\n    }\n\n    return {\n      // `then()` returns a Promise - 2.2.7\n      then: function then(onFulfilled, onRejected) {\n        var promise2 = new Promise$1(function (fulfill, reject) {\n          var processResolutionHandler = function (handler, handlers, forward) {\n            if (isFunction(handler)) {\n              handlers.push(function (p1result) {\n                try {\n                  resolve$1(promise2, handler(p1result), fulfill, reject);\n                } catch (err) {\n                  reject(err);\n                }\n              });\n            } else {\n              handlers.push(forward);\n            }\n          };\n\n          processResolutionHandler(onFulfilled, fulfilledHandlers, fulfill);\n          processResolutionHandler(onRejected, rejectedHandlers, reject);\n\n          if (state !== PENDING) {\n            wait(dispatchHandlers);\n          }\n        });\n        return promise2;\n      },\n      catch: function catch$1(onRejected) {\n        return this.then(null, onRejected);\n      },\n      finally: function finally$1(callback) {\n        return this.then(\n          function (v) {\n            callback();\n            return v;\n          },\n          function (e) {\n            callback();\n            throw e;\n          }\n        );\n      }\n    };\n  });\n\n  Promise$1.all = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var result = [];\n      var pending;\n      var i;\n\n      if (!promises.length) {\n        fulfill(result);\n        return;\n      }\n\n      var processPromise = function (promise, i) {\n        if (promise && isFunction(promise.then)) {\n          promise.then(function (value) {\n            result[i] = value;\n            --pending || fulfill(result);\n          }, reject);\n        } else {\n          result[i] = promise;\n          --pending || fulfill(result);\n        }\n      };\n\n      pending = i = promises.length;\n\n      while (i--) {\n        processPromise(promises[i], i);\n      }\n    });\n  };\n\n  Promise$1.race = function(promises) {\n    return new Promise$1(function (fulfill, reject) {\n      var pending = true;\n      function ok(v) {\n        if (!pending) { return; }\n        pending = false;\n        fulfill(v);\n      }\n      function fail(e) {\n        if (!pending) { return; }\n        pending = false;\n        reject(e);\n      }\n      for (var i = 0; i < promises.length; i++) {\n        if (promises[i] && isFunction(promises[i].then)) {\n          promises[i].then(ok, fail);\n        }\n      }\n    });\n  };\n\n  Promise$1.resolve = function(value) {\n    if (value && isFunction(value.then)) { return value; }\n    return new Promise$1(function (fulfill) {\n      fulfill(value);\n    });\n  };\n\n  Promise$1.reject = function(reason) {\n    if (reason && isFunction(reason.then)) { return reason; }\n    return new Promise$1(function (fulfill, reject) {\n      reject(reason);\n    });\n  };\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  var wait = function(callback) {\n    setTimeout(callback, 0);\n  };\n\n  var makeDispatcher = function(handlers, result) {\n    return function() {\n      for (var handler = (void 0); (handler = handlers.shift()); ) {\n        handler(result);\n      }\n    };\n  };\n\n  var resolve$1 = function(promise, x, fulfil, reject) {\n    var then;\n    if (x === promise) {\n      throw new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n    }\n    if (x instanceof Promise$1) {\n      x.then(fulfil, reject);\n    } else if (x && (isObjectType(x) || isFunction(x))) {\n      try {\n        then = x.then;\n      } catch (e) {\n        reject(e);\n        return;\n      }\n      if (isFunction(then)) {\n        var called;\n\n        var resolvePromise = function(y) {\n          if (called) { return; }\n          called = true;\n          resolve$1(promise, y, fulfil, reject);\n        };\n        var rejectPromise = function(r) {\n          if (called) { return; }\n          called = true;\n          reject(r);\n        };\n\n        try {\n          then.call(x, resolvePromise, rejectPromise);\n        } catch (e) {\n          if (!called) {\n            reject(e);\n            called = true;\n            return;\n          }\n        }\n      } else {\n        fulfil(x);\n      }\n    } else {\n      fulfil(x);\n    }\n  };\n}\n\n/* istanbul ignore if */\nif (\n  typeof window !== 'undefined' &&\n  !(window.requestAnimationFrame && window.cancelAnimationFrame)\n) {\n  var lastTime = 0;\n  window.requestAnimationFrame = function(callback) {\n    var currentTime = Date.now();\n    var timeToNextCall = Math.max(0, 16 - (currentTime - lastTime));\n    var id = window.setTimeout(function () {\n      callback(currentTime + timeToNextCall);\n    }, timeToNextCall);\n    lastTime = currentTime + timeToNextCall;\n    return id;\n  };\n  window.cancelAnimationFrame = function(id) {\n    clearTimeout(id);\n  };\n}\n\nvar defaults = {\n  // render placement:\n  el: void 0,\n  append: false,\n  delegate: true,\n  enhance: false,\n\n  // template:\n  template: null,\n\n  // parse:\n  allowExpressions: true,\n  delimiters: ['{{', '}}'],\n  tripleDelimiters: ['{{{', '}}}'],\n  staticDelimiters: ['[[', ']]'],\n  staticTripleDelimiters: ['[[[', ']]]'],\n  csp: true,\n  interpolate: false,\n  preserveWhitespace: false,\n  sanitize: false,\n  stripComments: true,\n  contextLines: 0,\n\n  // data & binding:\n  data: create(null),\n  helpers: create(null),\n  computed: create(null),\n  syncComputedChildren: false,\n  resolveInstanceMembers: false,\n  warnAboutAmbiguity: false,\n  adapt: [],\n  isolated: true,\n  twoway: true,\n  lazy: false,\n\n  // transitions:\n  noIntro: false,\n  noOutro: false,\n  transitionsEnabled: true,\n  complete: void 0,\n  nestedTransitions: true,\n\n  // css:\n  css: null,\n  noCSSTransform: false\n};\n\n// These are a subset of the easing equations found at\n// https://raw.github.com/danro/easing-js - license info\n// follows:\n\n// --------------------------------------------------\n// easing.js v0.5.4\n// Generic set of easing functions with AMD support\n// https://github.com/danro/easing-js\n// This code may be freely distributed under the MIT license\n// http://danro.mit-license.org/\n// --------------------------------------------------\n// All functions adapted from Thomas Fuchs & Jeremy Kahn\n// Easing Equations (c) 2003 Robert Penner, BSD license\n// https://raw.github.com/danro/easing-js/master/LICENSE\n// --------------------------------------------------\n\n// In that library, the functions named easeIn, easeOut, and\n// easeInOut below are named easeInCubic, easeOutCubic, and\n// (you guessed it) easeInOutCubic.\n//\n// You can add additional easing functions to this list, and they\n// will be globally available.\n\nvar easing = {\n  linear: function linear(pos) {\n    return pos;\n  },\n  easeIn: function easeIn(pos) {\n    /* istanbul ignore next */\n    return Math.pow(pos, 3);\n  },\n  easeOut: function easeOut(pos) {\n    return Math.pow(pos - 1, 3) + 1;\n  },\n  easeInOut: function easeInOut(pos) {\n    /* istanbul ignore next */\n    if ((pos /= 0.5) < 1) {\n      return 0.5 * Math.pow(pos, 3);\n    }\n    /* istanbul ignore next */\n    return 0.5 * (Math.pow(pos - 2, 3) + 2);\n  }\n};\n\nfunction noop() {}\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar alreadyWarned = {};\nvar log;\nvar printWarning;\nvar welcome;\n\nif (hasConsole) {\n  var welcomeIntro = [\n    \"%cRactive.js %c1.3.8 %cin debug mode, %cmore...\",\n    'color: rgb(114, 157, 52); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(85, 85, 85); font-weight: normal;',\n    'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n  ];\n  var welcomeMessage = \"You're running Ractive 1.3.8 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://ractive.js.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  welcome = function () {\n    if (Ractive.WELCOME_MESSAGE === false) {\n      welcome = noop;\n      return;\n    }\n    var message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n    var hasGroup = !!console.groupCollapsed;\n    if (hasGroup) { console.groupCollapsed.apply(console, welcomeIntro); }\n    console.log(message);\n    if (hasGroup) {\n      console.groupEnd(welcomeIntro);\n    }\n\n    welcome = noop;\n  };\n\n  printWarning = function (message, args) {\n    welcome();\n\n    // extract information about the instance this message pertains to, if applicable\n    if (isObjectType(args[args.length - 1])) {\n      var options = args.pop();\n      var ractive = options ? options.ractive : null;\n\n      if (ractive) {\n        // if this is an instance of a component that we know the name of, add\n        // it to the message\n        var name;\n        if (ractive.component && (name = ractive.component.name)) {\n          message = \"<\" + name + \"> \" + message;\n        }\n\n        var node;\n        if (\n          (node =\n            options.node || (ractive.fragment && ractive.fragment.rendered && ractive.find('*')))\n        ) {\n          args.push(node);\n        }\n      }\n    }\n\n    console.warn.apply(\n      console,\n      ['%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);'].concat(\n        args\n      )\n    );\n  };\n\n  log = function() {\n    console.log.apply(console, arguments);\n  };\n} else {\n  printWarning = log = welcome = noop;\n}\n\nfunction format(message, args) {\n  return message.replace(/%s/g, function () { return args.shift(); });\n}\n\nfunction fatal(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  throw new Error(message);\n}\n\nfunction logIfDebug() {\n  if (Ractive.DEBUG) {\n    log.apply(null, arguments);\n  }\n}\n\nfunction warn(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n  printWarning(message, args);\n}\n\nfunction warnOnce(message) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  message = format(message, args);\n\n  if (alreadyWarned[message]) {\n    return;\n  }\n\n  alreadyWarned[message] = true;\n  printWarning(message, args);\n}\n\nfunction warnIfDebug() {\n  if (Ractive.DEBUG) {\n    warn.apply(null, arguments);\n  }\n}\n\nfunction warnOnceIfDebug() {\n  if (Ractive.DEBUG) {\n    warnOnce.apply(null, arguments);\n  }\n}\n\n// Error messages that are used (or could be) in multiple places\nvar badArguments = 'Bad arguments';\nvar noRegistryFunctionReturn =\n  'A function was specified for \"%s\" %s, but no %s was returned';\nvar missingPlugin = function (name, type) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://ractive.js.org/integrations/#\" + type + \"s\"); };\n\nfunction findInViewHierarchy(registryName, ractive, name) {\n  var instance = findInstance(registryName, ractive, name);\n  return instance ? instance[registryName][name] : null;\n}\n\nfunction findInstance(registryName, ractive, name) {\n  while (ractive) {\n    if (name in ractive[registryName]) {\n      return ractive;\n    }\n\n    if (ractive.isolated) {\n      return null;\n    }\n\n    ractive = ractive.parent;\n  }\n}\n\nfunction interpolate(from, to, ractive, type) {\n  if (from === to) { return null; }\n\n  if (type) {\n    var interpol = findInViewHierarchy('interpolators', ractive, type);\n    if (interpol) { return interpol(from, to) || null; }\n\n    fatal(missingPlugin(type, 'interpolator'));\n  }\n\n  return (\n    interpolators.number(from, to) ||\n    interpolators.array(from, to) ||\n    interpolators.object(from, to) ||\n    null\n  );\n}\n\nvar interpolators = {\n  number: function number(from, to) {\n    if (!isNumeric(from) || !isNumeric(to)) {\n      return null;\n    }\n\n    from = +from;\n    to = +to;\n\n    var delta = to - from;\n\n    if (!delta) {\n      return function() {\n        return from;\n      };\n    }\n\n    return function(t) {\n      return from + t * delta;\n    };\n  },\n\n  array: function array(from, to) {\n    var len, i;\n\n    if (!isArray(from) || !isArray(to)) {\n      return null;\n    }\n\n    var intermediate = [];\n    var interpolators = [];\n\n    i = len = Math.min(from.length, to.length);\n    while (i--) {\n      interpolators[i] = interpolate(from[i], to[i]);\n    }\n\n    // surplus values - don't interpolate, but don't exclude them either\n    for (i = len; i < from.length; i += 1) {\n      intermediate[i] = from[i];\n    }\n\n    for (i = len; i < to.length; i += 1) {\n      intermediate[i] = to[i];\n    }\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        intermediate[i] = interpolators[i](t);\n      }\n\n      return intermediate;\n    };\n  },\n\n  object: function object(from, to) {\n    if (!isObject(from) || !isObject(to)) {\n      return null;\n    }\n\n    var properties = [];\n    var intermediate = {};\n    var interpolators = {};\n\n    var loop = function ( prop ) {\n      if (hasOwn(from, prop)) {\n        if (hasOwn(to, prop)) {\n          properties.push(prop);\n          interpolators[prop] = interpolate(from[prop], to[prop]) || (function () { return to[prop]; });\n        } else {\n          intermediate[prop] = from[prop];\n        }\n      }\n    };\n\n    for (var prop in from) loop( prop );\n\n    for (var prop$1 in to) {\n      if (hasOwn(to, prop$1) && !hasOwn(from, prop$1)) {\n        intermediate[prop$1] = to[prop$1];\n      }\n    }\n\n    var len = properties.length;\n\n    return function(t) {\n      var i = len;\n\n      while (i--) {\n        var prop = properties[i];\n\n        intermediate[prop] = interpolators[prop](t);\n      }\n\n      return intermediate;\n    };\n  }\n};\n\nvar refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\nvar splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\nvar escapeKeyPattern = /\\\\|\\./g;\nvar unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\nfunction escapeKey(key) {\n  if (isString(key)) {\n    return key.replace(escapeKeyPattern, '\\\\$&');\n  }\n\n  return key;\n}\n\nfunction normalise(ref) {\n  return ref ? ref.replace(refPattern, '.$1') : '';\n}\n\nfunction splitKeypath(keypath) {\n  var result = [];\n  var match;\n\n  keypath = normalise(keypath);\n\n  while ((match = splitPattern.exec(keypath))) {\n    var index = match.index + match[1].length;\n    result.push(keypath.substr(0, index));\n    keypath = keypath.substr(index + 1);\n  }\n\n  result.push(keypath);\n\n  return result;\n}\n\nfunction unescapeKey(key) {\n  if (isString(key)) {\n    return key.replace(unescapeKeyPattern, '$1$2');\n  }\n\n  return key;\n}\n\nfunction addToArray(array, value) {\n  var index = array.indexOf(value);\n\n  if (index === -1) {\n    array.push(value);\n  }\n}\n\nfunction arrayContains(array, value) {\n  for (var i = 0, c = array.length; i < c; i++) {\n    if (array[i] == value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arrayContentsMatch(a, b) {\n  var i;\n\n  if (!isArray(a) || !isArray(b)) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  i = a.length;\n  while (i--) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureArray(x) {\n  if (isString(x)) {\n    return [x];\n  }\n\n  if (isUndefined(x)) {\n    return [];\n  }\n\n  return x;\n}\n\nfunction lastItem(array) {\n  return array[array.length - 1];\n}\n\nfunction removeFromArray(array, member) {\n  if (!array) {\n    return;\n  }\n\n  var index = array.indexOf(member);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n\nfunction combine() {\n  var arrays = [], len = arguments.length;\n  while ( len-- ) arrays[ len ] = arguments[ len ];\n\n  var res = arrays.concat.apply([], arrays);\n  var i = res.length;\n  while (i--) {\n    var idx = res.indexOf(res[i]);\n    if (~idx && idx < i) { res.splice(i, 1); }\n  }\n\n  return res;\n}\n\nfunction toArray(arrayLike) {\n  var array = [];\n  var i = arrayLike.length;\n  while (i--) {\n    array[i] = arrayLike[i];\n  }\n\n  return array;\n}\n\nfunction findMap(array, fn) {\n  var len = array.length;\n  for (var i = 0; i < len; i++) {\n    var result = fn(array[i]);\n    if (result) { return result; }\n  }\n}\n\nfunction buildNewIndices(one, two, comparator) {\n  var oldArray = one;\n  var newArray = two;\n  if (comparator) {\n    oldArray = oldArray.map(comparator);\n    newArray = newArray.map(comparator);\n  }\n\n  var oldLength = oldArray.length;\n\n  var usedIndices = {};\n  var firstUnusedIndex = 0;\n\n  var result = oldArray.map(function (item) {\n    var index;\n    var start = firstUnusedIndex;\n\n    do {\n      index = newArray.indexOf(item, start);\n\n      if (index === -1) {\n        return -1;\n      }\n\n      start = index + 1;\n    } while (usedIndices[index] === true && start < oldLength);\n\n    // keep track of the first unused index, so we don't search\n    // the whole of newArray for each item in oldArray unnecessarily\n    if (index === firstUnusedIndex) {\n      firstUnusedIndex += 1;\n    }\n    // allow next instance of next \"equal\" to be found item\n    usedIndices[index] = true;\n    return index;\n  });\n\n  var len = (result.oldLen = oldArray.length);\n  result.newLen = newArray.length;\n\n  if (len === result.newLen) {\n    var i = 0;\n    for (i; i < len; i++) {\n      if (result[i] !== i) { break; }\n    }\n\n    if (i === len) { result.same = true; }\n  }\n\n  return result;\n}\n\nvar fnBind = Function.prototype.bind;\n\nfunction bind(fn, context) {\n  if (!/this/.test(fn.toString())) { return fn; }\n\n  var bound = fnBind.call(fn, context);\n  for (var prop in fn) { bound[prop] = fn[prop]; }\n\n  return bound;\n}\n\nvar shuffleTasks = { early: [], mark: [] };\nvar registerQueue = { early: [], mark: [] };\nvar noVirtual = { virtual: false };\n\nvar ModelBase = function ModelBase(parent) {\n  this.deps = [];\n\n  this.children = [];\n  this.childByKey = {};\n  this.links = [];\n\n  this.bindings = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.root = parent.root;\n  }\n};\nvar ModelBase__proto__ = ModelBase.prototype;\n\nModelBase__proto__.addShuffleTask = function addShuffleTask (task, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  shuffleTasks[stage].push(task);\n};\nModelBase__proto__.addShuffleRegister = function addShuffleRegister (item, stage) {\n    if ( stage === void 0 ) stage = 'early';\n\n  registerQueue[stage].push({ model: this, item: item });\n};\n\nModelBase__proto__.downstreamChanged = function downstreamChanged () {};\n\nModelBase__proto__.findMatches = function findMatches (keys$$1) {\n  var len = keys$$1.length;\n\n  var existingMatches = [this];\n  var matches;\n  var i;\n\n  var loop = function (  ) {\n    var key = keys$$1[i];\n\n    if (key === '*') {\n      matches = [];\n      existingMatches.forEach(function (model) {\n        matches.push.apply(matches, model.getValueChildren(model.get()));\n      });\n    } else {\n      matches = existingMatches.map(function (model) { return model.joinKey(key); });\n    }\n\n    existingMatches = matches;\n  };\n\n    for (i = 0; i < len; i += 1) loop(  );\n\n  return matches;\n};\n\nModelBase__proto__.getKeypath = function getKeypath (ractive) {\n  if (ractive !== this.ractive && this._link) { return this._link.target.getKeypath(ractive); }\n\n  if (!this.keypath) {\n    var parent = this.parent && this.parent.getKeypath(ractive);\n    this.keypath = parent\n      ? ((this.parent.getKeypath(ractive)) + \".\" + (escapeKey(this.key)))\n      : escapeKey(this.key);\n  }\n\n  return this.keypath;\n};\n\nModelBase__proto__.getValueChildren = function getValueChildren (value) {\n    var this$1 = this;\n\n  var children;\n  if (isArray(value)) {\n    children = [];\n    if ('length' in this && this.length !== value.length) {\n      children.push(this.joinKey('length'));\n    }\n    value.forEach(function (m, i) {\n      children.push(this$1.joinKey(i));\n    });\n  } else if (isObject(value) || isFunction(value)) {\n    children = keys(value).map(function (key) { return this$1.joinKey(key); });\n  } else if (value != null) {\n    children = [];\n  }\n\n  var computed = this.computed;\n  if (computed) {\n    children.push.apply(children, keys(computed).map(function (k) { return this$1.joinKey(k); }));\n  }\n\n  return children;\n};\n\nModelBase__proto__.getVirtual = function getVirtual (shouldCapture) {\n    var this$1 = this;\n\n  var value = this.get(shouldCapture, { virtual: false });\n  if (isObject(value)) {\n    var result = isArray(value) ? [] : create(null);\n\n    var keys$$1 = keys(value);\n    var i = keys$$1.length;\n    while (i--) {\n      var child = this$1.childByKey[keys$$1[i]];\n      if (!child) { result[keys$$1[i]] = value[keys$$1[i]]; }\n      else if (child._link) { result[keys$$1[i]] = child._link.getVirtual(); }\n      else { result[keys$$1[i]] = child.getVirtual(); }\n    }\n\n    i = this.children.length;\n    while (i--) {\n      var child$1 = this$1.children[i];\n      if (!(child$1.key in result) && child$1._link) {\n        result[child$1.key] = child$1._link.getVirtual();\n      }\n    }\n\n    if (this.computed) {\n      keys$$1 = keys(this.computed);\n      i = keys$$1.length;\n      while (i--) {\n        result[keys$$1[i]] = this$1.computed[keys$$1[i]].get();\n      }\n    }\n\n    return result;\n  } else { return value; }\n};\n\nModelBase__proto__.has = function has (key) {\n    var this$1 = this;\n\n  if (this._link) { return this._link.has(key); }\n\n  var value = this.get(false, noVirtual);\n  if (!value) { return false; }\n\n  key = unescapeKey(key);\n  if ((isFunction(value) || isObject(value)) && key in value) { return true; }\n\n  var computed = this.computed;\n  if (computed && key in this.computed) { return true; }\n\n  computed = this.root.ractive && this.root.ractive.computed;\n  if (computed) {\n    keys(computed).forEach(function (k) {\n      if (computed[k].pattern && computed[k].pattern.test(this$1.getKeypath())) { return true; }\n    });\n  }\n\n  return false;\n};\n\nModelBase__proto__.joinAll = function joinAll (keys$$1, opts) {\n  var model = this;\n  for (var i = 0; i < keys$$1.length; i += 1) {\n    if (\n      opts &&\n      opts.lastLink === false &&\n      i + 1 === keys$$1.length &&\n      model.childByKey[keys$$1[i]] &&\n      model.childByKey[keys$$1[i]]._link\n    )\n      { return model.childByKey[keys$$1[i]]; }\n    model = model.joinKey(keys$$1[i], opts);\n  }\n\n  return model;\n};\n\nModelBase__proto__.notifyUpstream = function notifyUpstream (startPath) {\n    var this$1 = this;\n\n  var parent = this.parent;\n  var path = startPath || [this.key];\n  while (parent) {\n    if (parent.patterns) { parent.patterns.forEach(function (o) { return o.notify(path.slice()); }); }\n    path.unshift(parent.key);\n    parent.links.forEach(function (l) { return l.notifiedUpstream(path, this$1.root); });\n    parent.deps.forEach(function (d) { return d.handleChange(path); });\n    parent.downstreamChanged(startPath);\n    parent = parent.parent;\n  }\n};\n\nModelBase__proto__.rebind = function rebind (next, previous, safe) {\n    var this$1 = this;\n\n  if (this._link) {\n    this._link.rebind(next, previous, false);\n  }\n\n  // tell the deps to move to the new target\n  var i = this.deps.length;\n  while (i--) {\n    if (this$1.deps[i].rebind) { this$1.deps[i].rebind(next, previous, safe); }\n  }\n\n  i = this.links.length;\n  while (i--) {\n    var link = this$1.links[i];\n    // only relink the root of the link tree\n    if (link.owner && link.owner._link) { link.relinking(next, safe); }\n  }\n\n  i = this.children.length;\n  while (i--) {\n    var child = this$1.children[i];\n    child.rebind(next ? next.joinKey(child.key) : undefined, child._link || child, safe);\n    if (this$1.dataModel) {\n      this$1.addShuffleTask(function () { return checkDataLink(this$1, this$1.retrieve()); }, 'early');\n    }\n  }\n\n  i = this.bindings.length;\n  while (i--) {\n    this$1.bindings[i].rebind(next, previous, safe);\n  }\n};\n\nModelBase__proto__.reference = function reference () {\n  'refs' in this ? this.refs++ : (this.refs = 1);\n};\n\nModelBase__proto__.register = function register (dep) {\n  this.deps.push(dep);\n};\n\nModelBase__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nModelBase__proto__.registerPatternObserver = function registerPatternObserver (observer) {\n  (this.patterns || (this.patterns = [])).push(observer);\n  this.register(observer);\n};\n\nModelBase__proto__.registerTwowayBinding = function registerTwowayBinding (binding) {\n  this.bindings.push(binding);\n};\n\nModelBase__proto__.unreference = function unreference () {\n  if ('refs' in this) { this.refs--; }\n};\n\nModelBase__proto__.unregister = function unregister (dep) {\n  removeFromArray(this.deps, dep);\n};\n\nModelBase__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nModelBase__proto__.unregisterPatternObserver = function unregisterPatternObserver (observer) {\n  removeFromArray(this.patterns, observer);\n  this.unregister(observer);\n};\n\nModelBase__proto__.unregisterTwowayBinding = function unregisterTwowayBinding (binding) {\n  removeFromArray(this.bindings, binding);\n};\n\nModelBase__proto__.updateFromBindings = function updateFromBindings$1 (cascade) {\n    var this$1 = this;\n\n  var i = this.bindings.length;\n  while (i--) {\n    var value = this$1.bindings[i].getValue();\n    if (value !== this$1.value) { this$1.set(value); }\n  }\n\n  // check for one-way bindings if there are no two-ways\n  if (!this.bindings.length) {\n    var oneway = findBoundValue(this.deps);\n    if (oneway && oneway.value !== this.value) { this.set(oneway.value); }\n  }\n\n  if (cascade) {\n    this.children.forEach(updateFromBindings);\n    this.links.forEach(updateFromBindings);\n    if (this._link) { this._link.updateFromBindings(cascade); }\n  }\n};\n\n// TODO: this may be better handled by overriding `get` on models with a parent that isRoot\nfunction maybeBind(model, value, shouldBind) {\n  if (shouldBind && isFunction(value) && model.parent && model.parent.isRoot) {\n    if (!model.boundValue) {\n      model.boundValue = bind(value._r_unbound || value, model.parent.ractive);\n    }\n\n    return model.boundValue;\n  }\n\n  return value;\n}\n\nfunction updateFromBindings(model) {\n  model.updateFromBindings(true);\n}\n\nfunction findBoundValue(list) {\n  var i = list.length;\n  while (i--) {\n    if (list[i].bound) {\n      var owner = list[i].owner;\n      if (owner) {\n        var value = owner.name === 'checked' ? owner.node.checked : owner.node.value;\n        return { value: value };\n      }\n    }\n  }\n}\n\nfunction fireShuffleTasks(stage) {\n  if (!stage) {\n    fireShuffleTasks('early');\n    fireShuffleTasks('mark');\n  } else {\n    var tasks = shuffleTasks[stage];\n    shuffleTasks[stage] = [];\n    var i = tasks.length;\n    while (i--) { tasks[i](); }\n\n    var register = registerQueue[stage];\n    registerQueue[stage] = [];\n    i = register.length;\n    while (i--) { register[i].model.register(register[i].item); }\n  }\n}\n\nfunction shuffle(model, newIndices, link, unsafe) {\n  model.shuffling = true;\n\n  var i = newIndices.length;\n  while (i--) {\n    var idx = newIndices[i];\n    // nothing is actually changing, so move in the index and roll on\n    if (i === idx) {\n      continue;\n    }\n\n    // rebind the children on i to idx\n    if (i in model.childByKey)\n      { model.childByKey[i].rebind(\n        !~idx ? undefined : model.joinKey(idx),\n        model.childByKey[i],\n        !unsafe\n      ); }\n  }\n\n  var upstream = model.source().length !== model.source().value.length;\n\n  model.links.forEach(function (l) { return l.shuffle(newIndices); });\n  if (!link) { fireShuffleTasks('early'); }\n\n  i = model.deps.length;\n  while (i--) {\n    if (model.deps[i].shuffle) { model.deps[i].shuffle(newIndices); }\n  }\n\n  model[link ? 'marked' : 'mark']();\n  if (!link) { fireShuffleTasks('mark'); }\n\n  if (upstream) { model.notifyUpstream(); }\n\n  model.shuffling = false;\n}\n\nfunction checkDataLink(model, value) {\n  if (value !== model.dataModel) {\n    if (value && value.viewmodel && value.viewmodel.isRoot && model.childByKey.data) {\n      model.childByKey.data.link(value.viewmodel, 'data');\n      model.dataModel = value;\n    } else if (model.dataModel) {\n      model.childByKey.data.unlink();\n      model.dataModel = true;\n    }\n  }\n}\n\nvar stack = [];\nvar captureGroup;\n\nfunction startCapturing() {\n  stack.push((captureGroup = []));\n}\n\nfunction stopCapturing() {\n  var dependencies = stack.pop();\n  captureGroup = stack[stack.length - 1];\n  return dependencies;\n}\n\nfunction capture(model) {\n  if (captureGroup) {\n    captureGroup.push(model);\n  }\n}\n\nfunction bind$1(x) {\n  x.bind();\n}\nfunction cancel(x) {\n  x.cancel();\n}\nfunction destroyed(x) {\n  x.destroyed();\n}\nfunction handleChange(x) {\n  x.handleChange();\n}\nfunction mark(x) {\n  x.mark();\n}\nfunction markForce(x) {\n  x.mark(true);\n}\nfunction marked(x) {\n  x.marked();\n}\nfunction markedAll(x) {\n  x.markedAll();\n}\nfunction render(x) {\n  x.render();\n}\nfunction shuffled(x) {\n  x.shuffled();\n}\nfunction teardown(x) {\n  x.teardown();\n}\nfunction unbind(x) {\n  x.unbind();\n}\nfunction unrender(x) {\n  x.unrender();\n}\n\nfunction update(x) {\n  x.update();\n}\nfunction toString$1(x) {\n  return x.toString();\n}\nfunction toEscapedString(x) {\n  return x.toString(true);\n}\n\n// this is the dry method of checking to see if a rebind applies to\n// a particular keypath because in some cases, a dep may be bound\n// directly to a particular keypath e.g. foo.bars.0.baz and need\n// to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\nfunction rebindMatch(template, next, previous, fragment) {\n  var keypath = template.r || template;\n\n  // no valid keypath, go with next\n  if (!keypath || !isString(keypath)) { return next; }\n\n  // completely contextual ref, go with next\n  if (\n    keypath === '.' ||\n    keypath[0] === '@' ||\n    (next || previous).isKey ||\n    (next || previous).isKeypath\n  )\n    { return next; }\n\n  var parts = keypath.split('/');\n  var keys = splitKeypath(parts[parts.length - 1]);\n  var last = keys[keys.length - 1];\n\n  // check the keypath against the model keypath to see if it matches\n  var model = next || previous;\n\n  // check to see if this was an alias\n  if (model && keys.length === 1 && last !== model.key && fragment) {\n    keys = findAlias(last, fragment) || keys;\n  }\n\n  var i = keys.length;\n  var match = true;\n  var shuffling = false;\n\n  while (model && i--) {\n    if (model.shuffling) { shuffling = true; }\n    // non-strict comparison to account for indices in keypaths\n    if (keys[i] != model.key) { match = false; }\n    model = model.parent;\n  }\n\n  // next is undefined, but keypath is shuffling and previous matches\n  if (!next && match && shuffling) { return previous; }\n  else if (next && !match && shuffling)\n    // next is defined, but doesn't match the keypath\n    { return previous; }\n  else { return next; }\n}\n\nfunction findAlias(name, fragment) {\n  while (fragment) {\n    var z = fragment.aliases;\n    if (z && z[name]) {\n      var aliases = (fragment.owner.iterations ? fragment.owner : fragment).owner.template.z;\n      for (var i = 0; i < aliases.length; i++) {\n        if (aliases[i].n === name) {\n          var alias = aliases[i].x;\n          if (!alias.r) { return false; }\n          var parts = alias.r.split('/');\n          return splitKeypath(parts[parts.length - 1]);\n        }\n      }\n      return;\n    }\n\n    fragment = fragment.componentParent || fragment.parent;\n  }\n}\n\n// temporary placeholder target for detached implicit links\nvar Missing = {\n  key: '@missing',\n  animate: noop,\n  applyValue: noop,\n  get: noop,\n  getKeypath: function getKeypath() {\n    return this.key;\n  },\n  joinAll: function joinAll() {\n    return this;\n  },\n  joinKey: function joinKey() {\n    return this;\n  },\n  mark: noop,\n  registerLink: noop,\n  shufle: noop,\n  set: noop,\n  unregisterLink: noop\n};\nMissing.parent = Missing;\n\nvar LinkModel = (function (ModelBase) {\n  function LinkModel(parent, owner, target, key) {\n    ModelBase.call(this, parent);\n\n    this.owner = owner;\n    this.target = target;\n    this.key = isUndefined(key) ? owner.key : key;\n    if (owner && owner.isLink) { this.sourcePath = (owner.sourcePath) + \".\" + (this.key); }\n\n    if (target) { target.registerLink(this); }\n\n    if (parent) { this.isReadonly = parent.isReadonly; }\n\n    this.isLink = true;\n  }\n\n  if ( ModelBase ) LinkModel.__proto__ = ModelBase;\n  var LinkModel__proto__ = LinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n  LinkModel__proto__.constructor = LinkModel;\n\n  LinkModel__proto__.animate = function animate (from, to, options, interpolator) {\n    return this.target.animate(from, to, options, interpolator);\n  };\n\n  LinkModel__proto__.applyValue = function applyValue (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.applyValue(value);\n  };\n\n  LinkModel__proto__.attach = function attach (fragment) {\n    var model = resolveReference(fragment, this.key);\n    if (model) {\n      this.relinking(model, false);\n    } else {\n      // if there is no link available, move everything here to real models\n      this.owner.unlink();\n    }\n  };\n\n  LinkModel__proto__.detach = function detach () {\n    this.relinking(Missing, false);\n  };\n\n  LinkModel__proto__.get = function get (shouldCapture, opts) {\n    if ( opts === void 0 ) opts = {};\n\n    if (shouldCapture) {\n      capture(this);\n\n      // may need to tell the target to unwrap\n      opts.unwrap = 'unwrap' in opts ? opts.unwrap : true;\n    }\n\n    var bind = 'shouldBind' in opts ? opts.shouldBind : true;\n    opts.shouldBind = this.mapping && this.target.parent && this.target.parent.isRoot;\n\n    return maybeBind(this, this.target.get(false, opts), bind);\n  };\n\n  LinkModel__proto__.getKeypath = function getKeypath (ractive) {\n    if (ractive && ractive !== this.root.ractive) { return this.target.getKeypath(ractive); }\n\n    return ModelBase.prototype.getKeypath.call(this, ractive);\n  };\n\n  LinkModel__proto__.handleChange = function handleChange$1 () {\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.notifyUpstream();\n  };\n\n  LinkModel__proto__.isDetached = function isDetached () {\n    return this.virtual && this.target === Missing;\n  };\n\n  LinkModel__proto__.joinKey = function joinKey (key) {\n    // TODO: handle nested links\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new LinkModel(this, this, this.target.joinKey(key), key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  LinkModel__proto__.mark = function mark (force) {\n    this.target.mark(force);\n  };\n\n  LinkModel__proto__.marked = function marked$1 () {\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n\n    this.deps.forEach(handleChange);\n  };\n\n  LinkModel__proto__.markedAll = function markedAll$1 () {\n    this.children.forEach(markedAll);\n    this.marked();\n  };\n\n  LinkModel__proto__.notifiedUpstream = function notifiedUpstream (startPath, root) {\n    var this$1 = this;\n\n    this.links.forEach(function (l) { return l.notifiedUpstream(startPath, this$1.root); });\n    this.deps.forEach(handleChange);\n    if (startPath && this.rootLink && this.root !== root) {\n      var path = startPath.slice(1);\n      path.unshift(this.key);\n      this.notifyUpstream(path);\n    }\n  };\n\n  LinkModel__proto__.relinked = function relinked () {\n    this.target.registerLink(this);\n    this.children.forEach(function (c) { return c.relinked(); });\n  };\n\n  LinkModel__proto__.relinking = function relinking (target, safe) {\n    var this$1 = this;\n\n    if (this.rootLink && this.sourcePath)\n      { target = rebindMatch(this.sourcePath, target, this.target); }\n    if (!target || this.target === target) { return; }\n\n    this.target && this.target.unregisterLink(this);\n\n    this.target = target;\n    this.children.forEach(function (c) {\n      c.relinking(target.joinKey(c.key), safe);\n    });\n\n    if (this.rootLink)\n      { this.addShuffleTask(function () {\n        this$1.relinked();\n        if (!safe) {\n          this$1.markedAll();\n          this$1.notifyUpstream();\n        }\n      }); }\n  };\n\n  LinkModel__proto__.set = function set (value) {\n    if (this.boundValue) { this.boundValue = null; }\n    this.target.set(value);\n  };\n\n  LinkModel__proto__.shuffle = function shuffle$1 (newIndices) {\n    // watch for extra shuffles caused by a shuffle in a downstream link\n    if (this.shuffling) { return; }\n\n    // let the real model handle firing off shuffles\n    if (!this.target.shuffling) {\n      if (this.target.shuffle) {\n        this.target.shuffle(newIndices);\n      } else {\n        // the target is a computation, which can't shuffle\n        this.target.mark();\n      }\n    } else {\n      shuffle(this, newIndices, true);\n    }\n  };\n\n  LinkModel__proto__.source = function source () {\n    if (this.target.source) { return this.target.source(); }\n    else { return this.target; }\n  };\n\n  LinkModel__proto__.teardown = function teardown$3 () {\n    if (this._link) { this._link.teardown(); }\n    this.target.unregisterLink(this);\n    this.children.forEach(teardown);\n  };\n\n  return LinkModel;\n}(ModelBase));\n\nModelBase.prototype.link = function link(model, keypath, options) {\n  var lnk = this._link || new LinkModel(this.parent, this, model, this.key);\n  lnk.implicit = options && options.implicit;\n  lnk.mapping = options && options.mapping;\n  lnk.sourcePath = keypath;\n  lnk.rootLink = true;\n  if (this._link) { this._link.relinking(model, false); }\n  this.rebind(lnk, this, false);\n  fireShuffleTasks();\n\n  this._link = lnk;\n  lnk.markedAll();\n\n  this.notifyUpstream();\n  return lnk;\n};\n\nModelBase.prototype.unlink = function unlink() {\n  if (this._link) {\n    var ln = this._link;\n    this._link = undefined;\n    ln.rebind(this, ln, false);\n    fireShuffleTasks();\n    ln.teardown();\n    this.notifyUpstream();\n  }\n};\n\nfunction fromExpression(body, length) {\n  if ( length === void 0 ) length = 0;\n\n  var args = new Array(length);\n\n  while (length--) {\n    args[length] = \"_\" + length;\n  }\n\n  // Functions created directly with new Function() look like this:\n  //     function anonymous (_0 /**/) { return _0*2 }\n  //\n  // With this workaround, we get a little more compact:\n  //     function (_0){return _0*2}\n  return new Function([], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\"))();\n}\n\nvar functions = create(null);\n\nfunction getFunction(str, i) {\n  if (functions[str]) { return functions[str]; }\n  return (functions[str] = createFunction(str, i));\n}\n\nfunction addFunctions(template) {\n  if (!template) { return; }\n\n  var exp = template.e;\n\n  if (!exp) { return; }\n\n  keys(exp).forEach(function (str) {\n    if (functions[str]) { return; }\n    functions[str] = exp[str];\n  });\n}\n\nvar TEMPLATE_VERSION = 4;\n\nvar leadingWhitespace = /^\\s+/;\n\nvar ParseError = function(message) {\n  this.name = 'ParseError';\n  this.message = message;\n  try {\n    throw new Error(message);\n  } catch (e) {\n    this.stack = e.stack;\n  }\n};\n\nParseError.prototype = Error.prototype;\n\nvar Parser = function(str, options) {\n  var item;\n  var lineStart = 0;\n\n  this.str = str;\n  this.options = options || {};\n  this.pos = 0;\n\n  this.lines = this.str.split('\\n');\n  this.lineEnds = this.lines.map(function (line) {\n    var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n    lineStart = lineEnd;\n    return lineEnd;\n  }, 0);\n\n  // Custom init logic\n  if (this.init) { this.init(str, options); }\n\n  var items = [];\n\n  while (this.pos < this.str.length && (item = this.read())) {\n    items.push(item);\n  }\n\n  this.leftover = this.remaining();\n  this.result = this.postProcess ? this.postProcess(items, options) : items;\n};\n\nParser.prototype = {\n  read: function read(converters) {\n    var this$1 = this;\n\n    var i, item;\n\n    if (!converters) { converters = this.converters; }\n\n    var pos = this.pos;\n\n    var len = converters.length;\n    for (i = 0; i < len; i += 1) {\n      this$1.pos = pos; // reset for each attempt\n\n      if ((item = converters[i](this$1))) {\n        return item;\n      }\n    }\n\n    return null;\n  },\n\n  getContextMessage: function getContextMessage(pos, message) {\n    var ref = this.getLinePos(pos);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    if (this.options.contextLines === -1) {\n      return [lineNum, columnNum, (message + \" at line \" + lineNum + \" character \" + columnNum)];\n    }\n\n    var line = this.lines[lineNum - 1];\n\n    var contextUp = '';\n    var contextDown = '';\n    if (this.options.contextLines) {\n      var start =\n        lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n      contextUp = this.lines\n        .slice(start, lineNum - 1 - start)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      contextDown = this.lines\n        .slice(lineNum, lineNum + this.options.contextLines)\n        .join('\\n')\n        .replace(/\\t/g, '  ');\n      if (contextUp) {\n        contextUp += '\\n';\n      }\n      if (contextDown) {\n        contextDown = '\\n' + contextDown;\n      }\n    }\n\n    var numTabs = 0;\n    var annotation =\n      contextUp +\n      line.replace(/\\t/g, function (match, char) {\n        if (char < columnNum) {\n          numTabs += 1;\n        }\n\n        return '  ';\n      }) +\n      '\\n' +\n      new Array(columnNum + numTabs).join(' ') +\n      '^----' +\n      contextDown;\n\n    return [\n      lineNum,\n      columnNum,\n      (message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation)\n    ];\n  },\n\n  getLinePos: function getLinePos(char) {\n    var this$1 = this;\n\n    var lineNum = 0;\n    var lineStart = 0;\n\n    while (char >= this.lineEnds[lineNum]) {\n      lineStart = this$1.lineEnds[lineNum];\n      lineNum += 1;\n    }\n\n    var columnNum = char - lineStart;\n    return [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  },\n\n  error: function error(message) {\n    var ref = this.getContextMessage(this.pos, message);\n    var lineNum = ref[0];\n    var columnNum = ref[1];\n    var msg = ref[2];\n\n    var error = new ParseError(msg);\n\n    error.line = lineNum;\n    error.character = columnNum;\n    error.shortMessage = message;\n\n    throw error;\n  },\n\n  matchString: function matchString(string) {\n    if (this.str.substr(this.pos, string.length) === string) {\n      this.pos += string.length;\n      return string;\n    }\n  },\n\n  matchPattern: function matchPattern(pattern) {\n    var match;\n\n    if ((match = pattern.exec(this.remaining()))) {\n      this.pos += match[0].length;\n      return match[1] || match[0];\n    }\n  },\n\n  sp: function sp() {\n    this.matchPattern(leadingWhitespace);\n  },\n\n  remaining: function remaining() {\n    return this.str.substring(this.pos);\n  },\n\n  nextChar: function nextChar() {\n    return this.str.charAt(this.pos);\n  },\n\n  warn: function warn(message) {\n    var msg = this.getContextMessage(this.pos, message)[2];\n\n    warnIfDebug(msg);\n  }\n};\n\nParser.extend = function(proto) {\n  var Parent = this;\n  var Child = function(str, options) {\n    Parser.call(this, str, options);\n  };\n\n  Child.prototype = create(Parent.prototype);\n\n  for (var key in proto) {\n    if (hasOwn(proto, key)) {\n      Child.prototype[key] = proto[key];\n    }\n  }\n\n  Child.extend = Parser.extend;\n  return Child;\n};\n\nvar TEXT = 1;\nvar INTERPOLATOR = 2;\nvar TRIPLE = 3;\nvar SECTION = 4;\nvar INVERTED = 5;\nvar CLOSING = 6;\nvar ELEMENT = 7;\nvar PARTIAL = 8;\nvar COMMENT = 9;\nvar DELIMCHANGE = 10;\nvar ANCHOR = 11;\nvar ATTRIBUTE = 13;\nvar CLOSING_TAG = 14;\nvar COMPONENT = 15;\nvar YIELDER = 16;\nvar INLINE_PARTIAL = 17;\nvar DOCTYPE = 18;\nvar ALIAS = 19;\n\nvar AWAIT = 55;\n\nvar NUMBER_LITERAL = 20;\nvar STRING_LITERAL = 21;\nvar ARRAY_LITERAL = 22;\nvar OBJECT_LITERAL = 23;\nvar BOOLEAN_LITERAL = 24;\nvar REGEXP_LITERAL = 25;\n\nvar GLOBAL = 26;\nvar KEY_VALUE_PAIR = 27;\n\nvar REFERENCE = 30;\nvar REFINEMENT = 31;\nvar MEMBER = 32;\nvar PREFIX_OPERATOR = 33;\nvar BRACKETED = 34;\nvar CONDITIONAL = 35;\nvar INFIX_OPERATOR = 36;\n\nvar INVOCATION = 40;\n\nvar SECTION_IF = 50;\nvar SECTION_UNLESS = 51;\nvar SECTION_EACH = 52;\nvar SECTION_WITH = 53;\nvar SECTION_IF_WITH = 54;\n\nvar ELSE = 60;\nvar ELSEIF = 61;\nvar THEN = 62;\nvar CATCH = 63;\n\nvar EVENT = 70;\nvar DECORATOR = 71;\nvar TRANSITION = 72;\nvar BINDING_FLAG = 73;\nvar DELEGATE_FLAG = 74;\n\nvar delimiterChangePattern = /^[^\\s=]+/;\nvar whitespacePattern = /^\\s+/;\n\nfunction readDelimiterChange(parser) {\n  if (!parser.matchString('=')) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  // allow whitespace before new opening delimiter\n  parser.sp();\n\n  var opening = parser.matchPattern(delimiterChangePattern);\n  if (!opening) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace (in fact, it's necessary...)\n  if (!parser.matchPattern(whitespacePattern)) {\n    return null;\n  }\n\n  var closing = parser.matchPattern(delimiterChangePattern);\n  if (!closing) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace before closing '='\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return [opening, closing];\n}\n\nvar regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\nfunction readNumberLiteral(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(regexpPattern))) {\n    return {\n      t: REGEXP_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nvar pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\nfunction escapeRegExp(str) {\n  return str.replace(pattern, '\\\\$&');\n}\n\nvar regExpCache = {};\n\nfunction getLowestIndex(haystack, needles) {\n  return haystack.search(\n    regExpCache[needles.join()] ||\n      (regExpCache[needles.join()] = new RegExp(needles.map(escapeRegExp).join('|')))\n  );\n}\n\n// https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n//export const booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\nvar booleanAttributes = {\n  allowfullscreen: 1,\n  async: 1,\n  autofocus: 1,\n  autoplay: 1,\n  checked: 1,\n  compact: 1,\n  controls: 1,\n  declare: 1,\n  default: 1,\n  defaultchecked: 1,\n  defaultmuted: 1,\n  defaultselected: 1,\n  defer: 1,\n  disabled: 1,\n  enabled: 1,\n  formnovalidate: 1,\n  hidden: 1,\n  indeterminate: 1,\n  inert: 1,\n  ismap: 1,\n  itemscope: 1,\n  loop: 1,\n  multiple: 1,\n  muted: 1,\n  nohref: 1,\n  noresize: 1,\n  noshade: 1,\n  novalidate: 1,\n  nowrap: 1,\n  open: 1,\n  pauseonexit: 1,\n  readonly: 1,\n  required: 1,\n  reversed: 1,\n  scoped: 1,\n  seamless: 1,\n  selected: 1,\n  sortable: 1,\n  translate: 1,\n  truespeed: 1,\n  typemustmatch: 1,\n  visible: 1\n};\nvar voidElements = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  command: 1,\n  doctype: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  keygen: 1,\n  link: 1,\n  meta: 1,\n  param: 1,\n  source: 1,\n  track: 1,\n  wbr: 1\n};\n\nvar htmlEntities = {\n  quot: 34,\n  amp: 38,\n  apos: 39,\n  lt: 60,\n  gt: 62,\n  nbsp: 160,\n  iexcl: 161,\n  cent: 162,\n  pound: 163,\n  curren: 164,\n  yen: 165,\n  brvbar: 166,\n  sect: 167,\n  uml: 168,\n  copy: 169,\n  ordf: 170,\n  laquo: 171,\n  not: 172,\n  shy: 173,\n  reg: 174,\n  macr: 175,\n  deg: 176,\n  plusmn: 177,\n  sup2: 178,\n  sup3: 179,\n  acute: 180,\n  micro: 181,\n  para: 182,\n  middot: 183,\n  cedil: 184,\n  sup1: 185,\n  ordm: 186,\n  raquo: 187,\n  frac14: 188,\n  frac12: 189,\n  frac34: 190,\n  iquest: 191,\n  Agrave: 192,\n  Aacute: 193,\n  Acirc: 194,\n  Atilde: 195,\n  Auml: 196,\n  Aring: 197,\n  AElig: 198,\n  Ccedil: 199,\n  Egrave: 200,\n  Eacute: 201,\n  Ecirc: 202,\n  Euml: 203,\n  Igrave: 204,\n  Iacute: 205,\n  Icirc: 206,\n  Iuml: 207,\n  ETH: 208,\n  Ntilde: 209,\n  Ograve: 210,\n  Oacute: 211,\n  Ocirc: 212,\n  Otilde: 213,\n  Ouml: 214,\n  times: 215,\n  Oslash: 216,\n  Ugrave: 217,\n  Uacute: 218,\n  Ucirc: 219,\n  Uuml: 220,\n  Yacute: 221,\n  THORN: 222,\n  szlig: 223,\n  agrave: 224,\n  aacute: 225,\n  acirc: 226,\n  atilde: 227,\n  auml: 228,\n  aring: 229,\n  aelig: 230,\n  ccedil: 231,\n  egrave: 232,\n  eacute: 233,\n  ecirc: 234,\n  euml: 235,\n  igrave: 236,\n  iacute: 237,\n  icirc: 238,\n  iuml: 239,\n  eth: 240,\n  ntilde: 241,\n  ograve: 242,\n  oacute: 243,\n  ocirc: 244,\n  otilde: 245,\n  ouml: 246,\n  divide: 247,\n  oslash: 248,\n  ugrave: 249,\n  uacute: 250,\n  ucirc: 251,\n  uuml: 252,\n  yacute: 253,\n  thorn: 254,\n  yuml: 255,\n  OElig: 338,\n  oelig: 339,\n  Scaron: 352,\n  scaron: 353,\n  Yuml: 376,\n  fnof: 402,\n  circ: 710,\n  tilde: 732,\n  Alpha: 913,\n  Beta: 914,\n  Gamma: 915,\n  Delta: 916,\n  Epsilon: 917,\n  Zeta: 918,\n  Eta: 919,\n  Theta: 920,\n  Iota: 921,\n  Kappa: 922,\n  Lambda: 923,\n  Mu: 924,\n  Nu: 925,\n  Xi: 926,\n  Omicron: 927,\n  Pi: 928,\n  Rho: 929,\n  Sigma: 931,\n  Tau: 932,\n  Upsilon: 933,\n  Phi: 934,\n  Chi: 935,\n  Psi: 936,\n  Omega: 937,\n  alpha: 945,\n  beta: 946,\n  gamma: 947,\n  delta: 948,\n  epsilon: 949,\n  zeta: 950,\n  eta: 951,\n  theta: 952,\n  iota: 953,\n  kappa: 954,\n  lambda: 955,\n  mu: 956,\n  nu: 957,\n  xi: 958,\n  omicron: 959,\n  pi: 960,\n  rho: 961,\n  sigmaf: 962,\n  sigma: 963,\n  tau: 964,\n  upsilon: 965,\n  phi: 966,\n  chi: 967,\n  psi: 968,\n  omega: 969,\n  thetasym: 977,\n  upsih: 978,\n  piv: 982,\n  ensp: 8194,\n  emsp: 8195,\n  thinsp: 8201,\n  zwnj: 8204,\n  zwj: 8205,\n  lrm: 8206,\n  rlm: 8207,\n  ndash: 8211,\n  mdash: 8212,\n  lsquo: 8216,\n  rsquo: 8217,\n  sbquo: 8218,\n  ldquo: 8220,\n  rdquo: 8221,\n  bdquo: 8222,\n  dagger: 8224,\n  Dagger: 8225,\n  bull: 8226,\n  hellip: 8230,\n  permil: 8240,\n  prime: 8242,\n  Prime: 8243,\n  lsaquo: 8249,\n  rsaquo: 8250,\n  oline: 8254,\n  frasl: 8260,\n  euro: 8364,\n  image: 8465,\n  weierp: 8472,\n  real: 8476,\n  trade: 8482,\n  alefsym: 8501,\n  larr: 8592,\n  uarr: 8593,\n  rarr: 8594,\n  darr: 8595,\n  harr: 8596,\n  crarr: 8629,\n  lArr: 8656,\n  uArr: 8657,\n  rArr: 8658,\n  dArr: 8659,\n  hArr: 8660,\n  forall: 8704,\n  part: 8706,\n  exist: 8707,\n  empty: 8709,\n  nabla: 8711,\n  isin: 8712,\n  notin: 8713,\n  ni: 8715,\n  prod: 8719,\n  sum: 8721,\n  minus: 8722,\n  lowast: 8727,\n  radic: 8730,\n  prop: 8733,\n  infin: 8734,\n  ang: 8736,\n  and: 8743,\n  or: 8744,\n  cap: 8745,\n  cup: 8746,\n  int: 8747,\n  there4: 8756,\n  sim: 8764,\n  cong: 8773,\n  asymp: 8776,\n  ne: 8800,\n  equiv: 8801,\n  le: 8804,\n  ge: 8805,\n  sub: 8834,\n  sup: 8835,\n  nsub: 8836,\n  sube: 8838,\n  supe: 8839,\n  oplus: 8853,\n  otimes: 8855,\n  perp: 8869,\n  sdot: 8901,\n  lceil: 8968,\n  rceil: 8969,\n  lfloor: 8970,\n  rfloor: 8971,\n  lang: 9001,\n  rang: 9002,\n  loz: 9674,\n  spades: 9824,\n  clubs: 9827,\n  hearts: 9829,\n  diams: 9830\n};\nvar controlCharacters = [\n  8364,\n  129,\n  8218,\n  402,\n  8222,\n  8230,\n  8224,\n  8225,\n  710,\n  8240,\n  352,\n  8249,\n  338,\n  141,\n  381,\n  143,\n  144,\n  8216,\n  8217,\n  8220,\n  8221,\n  8226,\n  8211,\n  8212,\n  732,\n  8482,\n  353,\n  8250,\n  339,\n  157,\n  382,\n  376\n];\nvar entityPattern = new RegExp(\n  '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + keys(htmlEntities).join('|') + '));?',\n  'g'\n);\nvar codePointSupport = isFunction(String.fromCodePoint);\nvar codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\nfunction decodeCharacterReferences(html) {\n  return html.replace(entityPattern, function (match, entity) {\n    var code;\n\n    // Handle named entities\n    if (entity[0] !== '#') {\n      code = htmlEntities[entity];\n    } else if (entity[1] === 'x') {\n      code = parseInt(entity.substring(2), 16);\n    } else {\n      code = parseInt(entity.substring(1), 10);\n    }\n\n    if (!code) {\n      return match;\n    }\n\n    return codeToChar(validateCode(code));\n  });\n}\n\nvar lessThan = /</g;\nvar greaterThan = />/g;\nvar amp = /&/g;\nvar invalid = 65533;\n\nfunction escapeHtml(str) {\n  return str\n    .replace(amp, '&amp;')\n    .replace(lessThan, '&lt;')\n    .replace(greaterThan, '&gt;');\n}\n\n// some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n// code points with alternatives in some cases - since we're bypassing that mechanism, we need\n// to replace them ourselves\n//\n// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n/* istanbul ignore next */\nfunction validateCode(code) {\n  if (!code) {\n    return invalid;\n  }\n\n  // line feed becomes generic whitespace\n  if (code === 10) {\n    return 32;\n  }\n\n  // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  if (code < 128) {\n    return code;\n  }\n\n  // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  // to correct the mistake or we'll end up with missing  signs and so on\n  if (code <= 159) {\n    return controlCharacters[code - 128];\n  }\n\n  // basic multilingual plane\n  if (code < 55296) {\n    return code;\n  }\n\n  // UTF-16 surrogate halves\n  if (code <= 57343) {\n    return invalid;\n  }\n\n  // rest of the basic multilingual plane\n  if (code <= 65535) {\n    return code;\n  } else if (!codePointSupport) {\n    return invalid;\n  }\n\n  // supplementary multilingual plane 0x10000 - 0x1ffff\n  if (code >= 65536 && code <= 131071) {\n    return code;\n  }\n\n  // supplementary ideographic plane 0x20000 - 0x2ffff\n  if (code >= 131072 && code <= 196607) {\n    return code;\n  }\n\n  return invalid;\n}\n\nvar expectedExpression = 'Expected a JavaScript expression';\nvar expectedParen = 'Expected closing paren';\n\n// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\nvar numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\nfunction readNumberLiteral$1(parser) {\n  var result;\n\n  if ((result = parser.matchPattern(numberPattern))) {\n    return {\n      t: NUMBER_LITERAL,\n      v: result\n    };\n  }\n\n  return null;\n}\n\nfunction readBooleanLiteral(parser) {\n  var remaining = parser.remaining();\n\n  if (remaining.substr(0, 4) === 'true') {\n    parser.pos += 4;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'true'\n    };\n  }\n\n  if (remaining.substr(0, 5) === 'false') {\n    parser.pos += 5;\n    return {\n      t: BOOLEAN_LITERAL,\n      v: 'false'\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', \\, or EOL/EOF.\n// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\nvar stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n// Match one escape sequence, including the backslash.\nvar escapeSequencePattern = /^\\\\(?:[`'\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n// Match one ES5 line continuation (backslash + line terminator).\nvar lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n// Helper for defining getDoubleQuotedString and getSingleQuotedString.\nfunction makeQuotedStringMatcher(okQuote) {\n  return function(parser) {\n    var literal = '\"';\n    var done = false;\n    var next;\n\n    while (!done) {\n      next =\n        parser.matchPattern(stringMiddlePattern) ||\n        parser.matchPattern(escapeSequencePattern) ||\n        parser.matchString(okQuote);\n      if (next) {\n        if (next === \"\\\"\") {\n          literal += \"\\\\\\\"\";\n        } else if (next === \"\\\\'\") {\n          literal += \"'\";\n        } else {\n          literal += next;\n        }\n      } else {\n        next = parser.matchPattern(lineContinuationPattern);\n        if (next) {\n          // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n          literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n        } else {\n          done = true;\n        }\n      }\n    }\n\n    literal += '\"';\n\n    // use JSON.parse to interpret escapes\n    return JSON.parse(literal);\n  };\n}\n\nvar singleMatcher = makeQuotedStringMatcher(\"\\\"\");\nvar doubleMatcher = makeQuotedStringMatcher(\"'\");\n\nfunction readStringLiteral(parser) {\n  var start = parser.pos;\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n\n  if (quote) {\n    var string = (quote === \"'\" ? singleMatcher : doubleMatcher)(parser);\n\n    if (!parser.matchString(quote)) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: STRING_LITERAL,\n      v: string\n    };\n  }\n\n  return null;\n}\n\n// Match one or more characters until: \", ', or \\\nvar stringMiddlePattern$1 = /^[^`\"\\\\\\$]+?(?:(?=[`\"\\\\\\$]))/;\n\nvar escapes = /[\\r\\n\\t\\b\\f]/g;\nfunction getString(literal) {\n  return JSON.parse((\"\\\"\" + (literal.replace(escapes, escapeChar)) + \"\\\"\"));\n}\n\nfunction escapeChar(c) {\n  switch (c) {\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\t':\n      return '\\\\t';\n    case '\\b':\n      return '\\\\b';\n    case '\\f':\n      return '\\\\f';\n  }\n}\n\nfunction readTemplateStringLiteral(parser) {\n  if (!parser.matchString('`')) { return null; }\n\n  var literal = '';\n  var done = false;\n  var next;\n  var parts = [];\n\n  while (!done) {\n    next =\n      parser.matchPattern(stringMiddlePattern$1) ||\n      parser.matchPattern(escapeSequencePattern) ||\n      parser.matchString('$') ||\n      parser.matchString('\"');\n    if (next) {\n      if (next === \"\\\"\") {\n        literal += \"\\\\\\\"\";\n      } else if (next === '\\\\`') {\n        literal += '`';\n      } else if (next === '$') {\n        if (parser.matchString('{')) {\n          parts.push({ t: STRING_LITERAL, v: getString(literal) });\n          literal = '';\n\n          parser.sp();\n          var expr = readExpression(parser);\n\n          if (!expr) { parser.error('Expected valid expression'); }\n\n          parts.push({ t: BRACKETED, x: expr });\n\n          parser.sp();\n          if (!parser.matchString('}'))\n            { parser.error(\"Expected closing '}' after interpolated expression\"); }\n        } else {\n          literal += '$';\n        }\n      } else {\n        literal += next;\n      }\n    } else {\n      next = parser.matchPattern(lineContinuationPattern);\n      if (next) {\n        // convert \\(newline-like) into a \\u escape, which is allowed in JSON\n        literal += '\\\\u' + ('000' + next.charCodeAt(1).toString(16)).slice(-4);\n      } else {\n        done = true;\n      }\n    }\n  }\n\n  if (literal.length) { parts.push({ t: STRING_LITERAL, v: getString(literal) }); }\n\n  if (!parser.matchString('`')) { parser.error(\"Expected closing '`'\"); }\n\n  if (parts.length === 1) {\n    return parts[0];\n  } else {\n    var result = parts.pop();\n    var part;\n\n    while ((part = parts.pop())) {\n      result = {\n        t: INFIX_OPERATOR,\n        s: '+',\n        o: [part, result]\n      };\n    }\n\n    return {\n      t: BRACKETED,\n      x: result\n    };\n  }\n}\n\nvar name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\nvar spreadPattern = /^\\s*\\.{3}/;\nvar legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*(?:\\.(?:[a-zA-Z_$][-\\/a-zA-Z_$0-9]*))*/;\n\nvar identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n// http://mathiasbynens.be/notes/javascript-properties\n// can be any name, string literal, or number literal\nfunction readKey(parser) {\n  var token;\n\n  if ((token = readStringLiteral(parser))) {\n    return identifier.test(token.v) ? token.v : '\"' + token.v.replace(/\"/g, '\\\\\"') + '\"';\n  }\n\n  if ((token = readNumberLiteral$1(parser))) {\n    return token.v;\n  }\n\n  if ((token = parser.matchPattern(name))) {\n    return token;\n  }\n\n  return null;\n}\n\nfunction readKeyValuePair(parser) {\n  var spread;\n  var start = parser.pos;\n\n  // allow whitespace between '{' and key\n  parser.sp();\n\n  var refKey = parser.nextChar() !== \"'\" && parser.nextChar() !== '\"';\n  if (refKey) { spread = parser.matchPattern(spreadPattern); }\n\n  var key = spread ? readExpression(parser) : readKey(parser);\n  if (key === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between key and ':'\n  parser.sp();\n\n  // es2015 shorthand property\n  if (refKey && (parser.nextChar() === ',' || parser.nextChar() === '}')) {\n    if (!spread && !name.test(key)) {\n      parser.error((\"Expected a valid reference, but found '\" + key + \"' instead.\"));\n    }\n\n    var pair = {\n      t: KEY_VALUE_PAIR,\n      k: key,\n      v: {\n        t: REFERENCE,\n        n: key\n      }\n    };\n\n    if (spread) {\n      pair.p = true;\n    }\n\n    return pair;\n  }\n\n  // next character must be ':'\n  if (!parser.matchString(':')) {\n    parser.pos = start;\n    return null;\n  }\n\n  // allow whitespace between ':' and value\n  parser.sp();\n\n  // next expression must be a, well... expression\n  var value = readExpression(parser);\n  if (value === null) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: KEY_VALUE_PAIR,\n    k: key,\n    v: value\n  };\n}\n\nfunction readKeyValuePairs(parser) {\n  var start = parser.pos;\n\n  var pair = readKeyValuePair(parser);\n  if (pair === null) {\n    return null;\n  }\n\n  var pairs = [pair];\n\n  if (parser.matchString(',')) {\n    var keyValuePairs = readKeyValuePairs(parser);\n\n    if (!keyValuePairs) {\n      parser.pos = start;\n      return null;\n    }\n\n    return pairs.concat(keyValuePairs);\n  }\n\n  return pairs;\n}\n\nfunction readObjectLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace\n  parser.sp();\n\n  if (!parser.matchString('{')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var keyValuePairs = readKeyValuePairs(parser);\n\n  // allow whitespace between final value and '}'\n  parser.sp();\n\n  if (!parser.matchString('}')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: OBJECT_LITERAL,\n    m: keyValuePairs\n  };\n}\n\nfunction readArrayLiteral(parser) {\n  var start = parser.pos;\n\n  // allow whitespace before '['\n  parser.sp();\n\n  if (!parser.matchString('[')) {\n    parser.pos = start;\n    return null;\n  }\n\n  var expressionList = readExpressionList(parser, true);\n\n  if (!parser.matchString(']')) {\n    parser.pos = start;\n    return null;\n  }\n\n  return {\n    t: ARRAY_LITERAL,\n    m: expressionList\n  };\n}\n\nfunction readLiteral(parser) {\n  return (\n    readNumberLiteral$1(parser) ||\n    readBooleanLiteral(parser) ||\n    readStringLiteral(parser) ||\n    readTemplateStringLiteral(parser) ||\n    readObjectLiteral(parser) ||\n    readArrayLiteral(parser) ||\n    readNumberLiteral(parser)\n  );\n}\n\n// if a reference is a browser global, we don't deference it later, so it needs special treatment\nvar globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\n// keywords are not valid references, with the exception of `this`\nvar keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\nvar prefixPattern = /^(?:\\@\\.|\\@|~\\/|(?:\\^\\^\\/(?:\\^\\^\\/)*(?:\\.\\.\\/)*)|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\nvar specials = /^(key|index|keypath|rootpath|this|global|shared|context|event|node|local|style|helpers|last|macro)/;\n\nfunction readReference(parser) {\n  var prefix, name$$1, global, reference, lastDotIndex;\n\n  var startPos = parser.pos;\n\n  prefix = parser.matchPattern(prefixPattern) || '';\n  name$$1 =\n    (!prefix && parser.relaxedNames && parser.matchPattern(relaxedName)) ||\n    parser.matchPattern(legalReference);\n  var actual = prefix.length + ((name$$1 && name$$1.length) || 0);\n\n  if (prefix === '@.') {\n    prefix = '@';\n    if (name$$1) { name$$1 = 'this.' + name$$1; }\n    else { name$$1 = 'this'; }\n  }\n\n  if (!name$$1 && prefix) {\n    name$$1 = prefix;\n    prefix = '';\n  }\n\n  if (!name$$1) {\n    return null;\n  }\n\n  if (prefix === '@') {\n    if (!specials.test(name$$1)) {\n      parser.error((\"Unrecognized special reference @\" + name$$1));\n    } else if ((!name$$1.indexOf('event') || !name$$1.indexOf('node')) && !parser.inEvent) {\n      parser.error(\"@event and @node are only valid references within an event directive\");\n    } else if (~name$$1.indexOf('context')) {\n      parser.pos = parser.pos - (name$$1.length - 7);\n      return {\n        t: BRACKETED,\n        x: {\n          t: REFERENCE,\n          n: '@context'\n        }\n      };\n    }\n  }\n\n  // bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  if (!prefix && !parser.relaxedNames && keywords.test(name$$1)) {\n    parser.pos = startPos;\n    return null;\n  }\n\n  // if this is a browser global, stop here\n  if (!prefix && globals.test(name$$1)) {\n    global = globals.exec(name$$1)[0];\n    parser.pos = startPos + global.length;\n\n    return {\n      t: GLOBAL,\n      v: global\n    };\n  }\n\n  reference = (prefix || '') + normalise(name$$1);\n\n  if (parser.matchString('(')) {\n    // if this is a method invocation (as opposed to a function) we need\n    // to strip the method name from the reference combo, else the context\n    // will be wrong\n    // but only if the reference was actually a member and not a refinement\n    lastDotIndex = reference.lastIndexOf('.');\n    if (lastDotIndex !== -1 && name$$1[name$$1.length - 1] !== ']') {\n      if (lastDotIndex === 0) {\n        reference = '.';\n        parser.pos = startPos;\n      } else {\n        var refLength = reference.length;\n        reference = reference.substr(0, lastDotIndex);\n        parser.pos = startPos + (actual - (refLength - lastDotIndex));\n      }\n    } else {\n      parser.pos -= 1;\n    }\n  }\n\n  return {\n    t: REFERENCE,\n    n: reference.replace(/^this\\./, './').replace(/^this$/, '.')\n  };\n}\n\nfunction readBracketedExpression(parser) {\n  if (!parser.matchString('(')) { return null; }\n\n  parser.sp();\n\n  var expr = readExpression(parser);\n\n  if (!expr) { parser.error(expectedExpression); }\n\n  parser.sp();\n\n  if (!parser.matchString(')')) { parser.error(expectedParen); }\n\n  return {\n    t: BRACKETED,\n    x: expr\n  };\n}\n\nfunction readPrimary(parser) {\n  return readLiteral(parser) || readReference(parser) || readBracketedExpression(parser);\n}\n\nfunction readRefinement(parser) {\n  // some things call for strict refinement (partial names), meaning no space between reference and refinement\n  if (!parser.strictRefinement) {\n    parser.sp();\n  }\n\n  // \".\" name\n  if (parser.matchString('.')) {\n    parser.sp();\n\n    var name$$1 = parser.matchPattern(name);\n    if (name$$1) {\n      return {\n        t: REFINEMENT,\n        n: name$$1\n      };\n    }\n\n    parser.error('Expected a property name');\n  }\n\n  // \"[\" expression \"]\"\n  if (parser.matchString('[')) {\n    parser.sp();\n\n    var expr = readExpression(parser);\n    if (!expr) { parser.error(expectedExpression); }\n\n    parser.sp();\n\n    if (!parser.matchString(']')) { parser.error(\"Expected ']'\"); }\n\n    return {\n      t: REFINEMENT,\n      x: expr\n    };\n  }\n\n  return null;\n}\n\nfunction readMemberOrInvocation(parser) {\n  var expression = readPrimary(parser);\n\n  if (!expression) { return null; }\n\n  while (expression) {\n    var refinement = readRefinement(parser);\n    if (refinement) {\n      expression = {\n        t: MEMBER,\n        x: expression,\n        r: refinement\n      };\n    } else if (parser.matchString('(')) {\n      parser.sp();\n      var expressionList = readExpressionList(parser, true);\n\n      parser.sp();\n\n      if (!parser.matchString(')')) {\n        parser.error(expectedParen);\n      }\n\n      expression = {\n        t: INVOCATION,\n        x: expression\n      };\n\n      if (expressionList) { expression.o = expressionList; }\n    } else {\n      break;\n    }\n  }\n\n  return expression;\n}\n\nvar readTypeOf;\n\nvar makePrefixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    var expression;\n\n    if ((expression = fallthrough(parser))) {\n      return expression;\n    }\n\n    if (!parser.matchString(symbol)) {\n      return null;\n    }\n\n    parser.sp();\n\n    expression = readExpression(parser);\n    if (!expression) {\n      parser.error(expectedExpression);\n    }\n\n    return {\n      s: symbol,\n      o: expression,\n      t: PREFIX_OPERATOR\n    };\n  };\n};\n\n// create all prefix sequence matchers, return readTypeOf\n(function() {\n  var i, len, matcher, fallthrough;\n\n  var prefixOperators = '! ~ + - typeof'.split(' ');\n\n  fallthrough = readMemberOrInvocation;\n  for (i = 0, len = prefixOperators.length; i < len; i += 1) {\n    matcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // typeof operator is higher precedence than multiplication, so provides the\n  // fallthrough for the multiplication sequence matcher we're about to create\n  // (we're skipping void and delete)\n  readTypeOf = fallthrough;\n})();\n\nvar readTypeof = readTypeOf;\n\nvar readLogicalOr;\n\nvar makeInfixSequenceMatcher = function(symbol, fallthrough) {\n  return function(parser) {\n    // > and / have to be quoted\n    if (parser.inUnquotedAttribute && (symbol === '>' || symbol === '/'))\n      { return fallthrough(parser); }\n\n    var start, left, right;\n\n    left = fallthrough(parser);\n    if (!left) {\n      return null;\n    }\n\n    // Loop to handle left-recursion in a case like `a * b * c` and produce\n    // left association, i.e. `(a * b) * c`.  The matcher can't call itself\n    // to parse `left` because that would be infinite regress.\n    while (true) {\n      start = parser.pos;\n\n      parser.sp();\n\n      if (!parser.matchString(symbol)) {\n        parser.pos = start;\n        return left;\n      }\n\n      // special case - in operator must not be followed by [a-zA-Z_$0-9]\n      if (symbol === 'in' && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n        parser.pos = start;\n        return left;\n      }\n\n      parser.sp();\n\n      // right operand must also consist of only higher-precedence operators\n      right = fallthrough(parser);\n      if (!right) {\n        parser.pos = start;\n        return left;\n      }\n\n      left = {\n        t: INFIX_OPERATOR,\n        s: symbol,\n        o: [left, right]\n      };\n\n      // Loop back around.  If we don't see another occurrence of the symbol,\n      // we'll return left.\n    }\n  };\n};\n\n// create all infix sequence matchers, and return readLogicalOr\n(function() {\n  var i, len, matcher, fallthrough;\n\n  // All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  // Each sequence matcher will initially fall through to its higher precedence\n  // neighbour, and only attempt to match if one of the higher precedence operators\n  // (or, ultimately, a literal, reference, or bracketed expression) already matched\n  var infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split(\n    ' '\n  );\n\n  // A typeof operator is higher precedence than multiplication\n  fallthrough = readTypeof;\n  for (i = 0, len = infixOperators.length; i < len; i += 1) {\n    matcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n    fallthrough = matcher;\n  }\n\n  // Logical OR is the fallthrough for the conditional matcher\n  readLogicalOr = fallthrough;\n})();\n\nvar readLogicalOr$1 = readLogicalOr;\n\n// The conditional operator is the lowest precedence operator, so we start here\nfunction getConditional(parser) {\n  var expression = readLogicalOr$1(parser);\n  if (!expression) {\n    return null;\n  }\n\n  var start = parser.pos;\n\n  parser.sp();\n\n  if (!parser.matchString('?')) {\n    parser.pos = start;\n    return expression;\n  }\n\n  parser.sp();\n\n  var ifTrue = readExpression(parser);\n  if (!ifTrue) {\n    parser.error(expectedExpression);\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(':')) {\n    parser.error('Expected \":\"');\n  }\n\n  parser.sp();\n\n  var ifFalse = readExpression(parser);\n  if (!ifFalse) {\n    parser.error(expectedExpression);\n  }\n\n  return {\n    t: CONDITIONAL,\n    o: [expression, ifTrue, ifFalse]\n  };\n}\n\nfunction readExpression(parser) {\n  // if eval is false, no expressions\n  if (parser.allowExpressions === false) {\n    var ref = readReference(parser);\n    parser.sp();\n    return ref;\n  }\n\n  // The conditional operator is the lowest precedence operator (except yield,\n  // assignment operators, and commas, none of which are supported), so we\n  // start there. If it doesn't match, it 'falls through' to progressively\n  // higher precedence operators, until it eventually matches (or fails to\n  // match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  // tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  return getConditional(parser);\n}\n\nfunction readExpressionList(parser, spread) {\n  var isSpread;\n  var expressions = [];\n\n  var pos = parser.pos;\n\n  do {\n    parser.sp();\n\n    if (spread) {\n      isSpread = parser.matchPattern(spreadPattern);\n    }\n\n    var expr = readExpression(parser);\n\n    if (expr === null && expressions.length) {\n      parser.error(expectedExpression);\n    } else if (expr === null) {\n      parser.pos = pos;\n      return null;\n    }\n\n    if (isSpread) {\n      expr.p = true;\n    }\n\n    expressions.push(expr);\n\n    parser.sp();\n  } while (parser.matchString(','));\n\n  return expressions;\n}\n\nfunction readExpressionOrReference(parser, expectedFollowers) {\n  var start = parser.pos;\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    // valid reference but invalid expression e.g. `{{new}}`?\n    var ref = parser.matchPattern(/^(\\w+)/);\n    if (ref) {\n      return {\n        t: REFERENCE,\n        n: ref\n      };\n    }\n\n    return null;\n  }\n\n  for (var i = 0; i < expectedFollowers.length; i += 1) {\n    if (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n      return expression;\n    }\n  }\n\n  parser.pos = start;\n  return readReference(parser);\n}\n\nfunction flattenExpression(expression) {\n  var refs;\n  var count = 0;\n\n  extractRefs(expression, (refs = []));\n  var stringified = stringify(expression);\n\n  return {\n    r: refs,\n    s: getVars(stringified)\n  };\n\n  function getVars(expr) {\n    var vars = [];\n    for (var i = count - 1; i >= 0; i--) {\n      vars.push((\"x$\" + i));\n    }\n    return vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n  }\n\n  function stringify(node) {\n    if (isString(node)) {\n      return node;\n    }\n\n    switch (node.t) {\n      case BOOLEAN_LITERAL:\n      case GLOBAL:\n      case NUMBER_LITERAL:\n      case REGEXP_LITERAL:\n        return node.v;\n\n      case STRING_LITERAL:\n        return JSON.stringify(String(node.v));\n\n      case ARRAY_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"[].concat(\" + (makeSpread(node.m, '[', ']', stringify)) + \")\");\n        } else {\n          return '[' + (node.m ? node.m.map(stringify).join(',') : '') + ']';\n        }\n\n      case OBJECT_LITERAL:\n        if (node.m && hasSpread(node.m)) {\n          return (\"Object.assign({},\" + (makeSpread(node.m, '{', '}', stringifyPair)) + \")\");\n        } else {\n          return '{' + (node.m ? node.m.map(function (n) { return ((n.k) + \":\" + (stringify(n.v))); }).join(',') : '') + '}';\n        }\n\n      case PREFIX_OPERATOR:\n        return (node.s === 'typeof' ? 'typeof ' : node.s) + stringify(node.o);\n\n      case INFIX_OPERATOR:\n        return (\n          stringify(node.o[0]) +\n          (node.s.substr(0, 2) === 'in' ? ' ' + node.s + ' ' : node.s) +\n          stringify(node.o[1])\n        );\n\n      case INVOCATION:\n        if (node.o && hasSpread(node.o)) {\n          var id = count++;\n          return (\"(x$\" + id + \"=\" + (stringify(node.x)) + \").apply(x$\" + id + \",\" + (stringify({\n            t: ARRAY_LITERAL,\n            m: node.o\n          })) + \")\");\n        } else {\n          return stringify(node.x) + '(' + (node.o ? node.o.map(stringify).join(',') : '') + ')';\n        }\n\n      case BRACKETED:\n        return '(' + stringify(node.x) + ')';\n\n      case MEMBER:\n        return stringify(node.x) + stringify(node.r);\n\n      case REFINEMENT:\n        return node.n ? '.' + node.n : '[' + stringify(node.x) + ']';\n\n      case CONDITIONAL:\n        return stringify(node.o[0]) + '?' + stringify(node.o[1]) + ':' + stringify(node.o[2]);\n\n      case REFERENCE:\n        return '_' + refs.indexOf(node.n);\n\n      default:\n        throw new Error('Expected legal JavaScript');\n    }\n  }\n\n  function stringifyPair(node) {\n    return node.p ? stringify(node.k) : ((node.k) + \":\" + (stringify(node.v)));\n  }\n\n  function makeSpread(list, open, close, fn) {\n    var out = list.reduce(\n      function (a, c) {\n        if (c.p) {\n          a.str += \"\" + (a.open ? close + ',' : a.str.length ? ',' : '') + (fn(c));\n        } else {\n          a.str += \"\" + (!a.str.length ? open : !a.open ? ',' + open : ',') + (fn(c));\n        }\n        a.open = !c.p;\n        return a;\n      },\n      { open: false, str: '' }\n    );\n    if (out.open) { out.str += close; }\n    return out.str;\n  }\n}\n\nfunction hasSpread(list) {\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].p) { return true; }\n  }\n\n  return false;\n}\n\n// TODO maybe refactor this?\nfunction extractRefs(node, refs) {\n  if (node.t === REFERENCE && isString(node.n)) {\n    if (!~refs.indexOf(node.n)) {\n      refs.unshift(node.n);\n    }\n  }\n\n  var list = node.o || node.m;\n  if (list) {\n    if (isObject(list)) {\n      extractRefs(list, refs);\n    } else {\n      var i = list.length;\n      while (i--) {\n        extractRefs(list[i], refs);\n      }\n    }\n  }\n\n  if (node.k && node.t === KEY_VALUE_PAIR && !isString(node.k)) {\n    extractRefs(node.k, refs);\n  }\n\n  if (node.x) {\n    extractRefs(node.x, refs);\n  }\n\n  if (node.r) {\n    extractRefs(node.r, refs);\n  }\n\n  if (node.v) {\n    extractRefs(node.v, refs);\n  }\n}\n\nfunction refineExpression(expression, mustache) {\n  var referenceExpression;\n\n  if (expression) {\n    while (expression.t === BRACKETED && expression.x) {\n      expression = expression.x;\n    }\n\n    if (expression.t === REFERENCE) {\n      var n = expression.n;\n      if (!~n.indexOf('@context')) {\n        mustache.r = expression.n;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    } else {\n      if ((referenceExpression = getReferenceExpression(expression))) {\n        mustache.rx = referenceExpression;\n      } else {\n        mustache.x = flattenExpression(expression);\n      }\n    }\n\n    return mustache;\n  }\n}\n\n// TODO refactor this! it's bewildering\nfunction getReferenceExpression(expression) {\n  var members = [];\n  var refinement;\n\n  while (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n    refinement = expression.r;\n\n    if (refinement.x) {\n      if (refinement.x.t === REFERENCE) {\n        members.unshift(refinement.x);\n      } else {\n        members.unshift(flattenExpression(refinement.x));\n      }\n    } else {\n      members.unshift(refinement.n);\n    }\n\n    expression = expression.x;\n  }\n\n  if (expression.t !== REFERENCE) {\n    return null;\n  }\n\n  return {\n    r: expression.n,\n    m: members\n  };\n}\n\nvar attributeNamePattern = /^[^\\s\"'>\\/=(]+/;\nvar onPattern = /^on/;\nvar eventPattern = /^on-([a-zA-Z\\*\\.$_]((?:[a-zA-Z\\*\\.$_0-9\\-]|\\\\-)+))$/;\nvar reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|complete|unrender|detach|insert|destruct|attachchild|detachchild)$/;\nvar decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\nvar transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\nvar boundPattern = /^((bind|class)-(([-a-zA-Z0-9_])+))$/;\nvar directives = {\n  lazy: { t: BINDING_FLAG, v: 'l' },\n  twoway: { t: BINDING_FLAG, v: 't' },\n  'no-delegation': { t: DELEGATE_FLAG }\n};\nvar unquotedAttributeValueTextPattern = /^[^\\s\"'=<>\\/`]+/;\nvar proxyEvent = /^[^\\s\"'=<>@\\[\\]()]*/;\nvar whitespace = /^\\s+/;\n\nvar slashes = /\\\\/g;\nfunction splitEvent(str) {\n  var result = [];\n  var s = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] === '-' && str[i - 1] !== '\\\\') {\n      result.push(str.substring(s, i).replace(slashes, ''));\n      s = i + 1;\n    }\n  }\n\n  result.push(str.substring(s).replace(slashes, ''));\n\n  return result;\n}\n\nfunction readAttribute(parser) {\n  var name, i, nearest, idx;\n\n  parser.sp();\n\n  name = parser.matchPattern(attributeNamePattern);\n  if (!name) {\n    return null;\n  }\n\n  // check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n  nearest = name.length;\n  for (i = 0; i < parser.tags.length; i++) {\n    if (~(idx = name.indexOf(parser.tags[i].open))) {\n      if (idx < nearest) { nearest = idx; }\n    }\n  }\n  if (nearest < name.length) {\n    parser.pos -= name.length - nearest;\n    name = name.substr(0, nearest);\n    if (!name) { return null; }\n  }\n\n  return { n: name };\n}\n\nfunction readAttributeValue(parser) {\n  var start = parser.pos;\n\n  // next character must be `=`, `/`, `>` or whitespace\n  if (!/[=\\/>\\s]/.test(parser.nextChar())) {\n    parser.error('Expected `=`, `/`, `>` or whitespace');\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('=')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var valueStart = parser.pos;\n  var startDepth = parser.sectionDepth;\n\n  var value =\n    readQuotedAttributeValue(parser, \"'\") ||\n    readQuotedAttributeValue(parser, \"\\\"\") ||\n    readUnquotedAttributeValue(parser);\n\n  if (value === null) {\n    parser.error('Expected valid attribute value');\n  }\n\n  if (parser.sectionDepth !== startDepth) {\n    parser.pos = valueStart;\n    parser.error(\n      'An attribute value must contain as many opening section tags as closing section tags'\n    );\n  }\n\n  if (!value.length) {\n    return '';\n  }\n\n  if (value.length === 1 && isString(value[0])) {\n    return decodeCharacterReferences(value[0]);\n  }\n\n  return value;\n}\n\nfunction readUnquotedAttributeValueToken(parser) {\n  var text, index;\n\n  var start = parser.pos;\n\n  text = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  if (!text) {\n    return null;\n  }\n\n  var haystack = text;\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n\n  if ((index = getLowestIndex(haystack, needles)) !== -1) {\n    text = text.substr(0, index);\n    parser.pos = start + text.length;\n  }\n\n  return text;\n}\n\nfunction readUnquotedAttributeValue(parser) {\n  parser.inAttribute = true;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  while (token) {\n    tokens.push(token);\n    token = readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  }\n\n  if (!tokens.length) {\n    return null;\n  }\n\n  parser.inAttribute = false;\n  return tokens;\n}\n\nfunction readQuotedAttributeValue(parser, quoteMark) {\n  var start = parser.pos;\n\n  if (!parser.matchString(quoteMark)) {\n    return null;\n  }\n\n  parser.inAttribute = quoteMark;\n\n  var tokens = [];\n\n  var token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  while (token !== null) {\n    tokens.push(token);\n    token = readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  }\n\n  if (!parser.matchString(quoteMark)) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.inAttribute = false;\n\n  return tokens;\n}\n\nfunction readQuotedStringToken(parser, quoteMark) {\n  var haystack = parser.remaining();\n\n  var needles = parser.tags.map(function (t) { return t.open; }); // TODO refactor... we do this in readText.js as well\n  needles.push(quoteMark);\n\n  var index = getLowestIndex(haystack, needles);\n\n  if (index === -1) {\n    parser.error('Quoted attribute value must have a closing quote');\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  parser.pos += index;\n  return haystack.substr(0, index);\n}\n\nfunction readAttributeOrDirective(parser) {\n  var match, directive;\n\n  var attribute = readAttribute(parser, false);\n\n  if (!attribute) { return null; }\n\n  // lazy, twoway\n  if ((directive = directives[attribute.n])) {\n    attribute.t = directive.t;\n    if (directive.v) { attribute.v = directive.v; }\n    delete attribute.n; // no name necessary\n    parser.sp();\n    if (parser.nextChar() === '=') { attribute.f = readAttributeValue(parser); }\n  } else if ((match = decoratorPattern.exec(attribute.n))) {\n    // decorators\n    attribute.n = match[1];\n    attribute.t = DECORATOR;\n    readArguments(parser, attribute);\n  } else if ((match = transitionPattern.exec(attribute.n))) {\n    // transitions\n    attribute.n = match[1];\n    attribute.t = TRANSITION;\n    readArguments(parser, attribute);\n    attribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n  } else if ((match = eventPattern.exec(attribute.n))) {\n    // on-click etc\n    attribute.n = splitEvent(match[1]);\n    attribute.t = EVENT;\n\n    if (parser.matchString('(')) {\n      attribute.a = flattenExpression({\n        t: ARRAY_LITERAL,\n        m: readExpressionList(parser)\n      });\n      if (!parser.matchString(')')) { parser.error(\"Expected closing ')'\"); }\n    }\n\n    parser.inEvent = true;\n\n    // check for a proxy event\n    if (!readProxyEvent(parser, attribute)) {\n      // otherwise, it's an expression\n      readArguments(parser, attribute, true);\n    } else if (reservedEventNames.test(attribute.f)) {\n      parser.pos -= attribute.f.length;\n      parser.error(\n        'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, complete, detach, insert, destruct, attachchild, detachchild)'\n      );\n    }\n\n    parser.inEvent = false;\n  } else if ((match = boundPattern.exec(attribute.n))) {\n    // bound directives\n    var bind = match[2] === 'bind';\n    attribute.n = bind ? match[3] : match[1];\n    attribute.t = ATTRIBUTE;\n    readArguments(parser, attribute, false, true);\n\n    if (!attribute.f && bind) {\n      attribute.f = [{ t: INTERPOLATOR, r: match[3] }];\n    }\n  } else {\n    parser.sp();\n    var value = parser.nextChar() === '=' ? readAttributeValue(parser) : null;\n    attribute.f = value != null ? value : attribute.f;\n\n    if (parser.sanitizeEventAttributes && onPattern.test(attribute.n)) {\n      return { exclude: true };\n    } else {\n      attribute.f = attribute.f || (attribute.f === '' ? '' : 0);\n      attribute.t = ATTRIBUTE;\n    }\n  }\n\n  return attribute;\n}\n\nfunction readProxyEvent(parser, attribute) {\n  var start = parser.pos;\n  if (!parser.matchString('=')) { parser.error(\"Missing required directive arguments\"); }\n\n  var quote = parser.matchString(\"'\") || parser.matchString(\"\\\"\");\n  parser.sp();\n  var proxy = parser.matchPattern(proxyEvent);\n\n  if (proxy !== undefined) {\n    if (quote) {\n      parser.sp();\n      if (!parser.matchString(quote)) { parser.pos = start; }\n      else { return (attribute.f = proxy) || true; }\n    } else if (!parser.matchPattern(whitespace)) {\n      parser.pos = start;\n    } else {\n      return (attribute.f = proxy) || true;\n    }\n  } else {\n    parser.pos = start;\n  }\n}\n\nfunction readArguments(parser, attribute, required, single) {\n  if ( required === void 0 ) required = false;\n  if ( single === void 0 ) single = false;\n\n  parser.sp();\n  if (!parser.matchString('=')) {\n    if (required) { parser.error(\"Missing required directive arguments\"); }\n    return;\n  }\n  parser.sp();\n\n  var quote = parser.matchString('\"') || parser.matchString(\"'\");\n  var spread = parser.spreadArgs;\n  parser.spreadArgs = true;\n  parser.inUnquotedAttribute = !quote;\n  var expr = single\n    ? readExpressionOrReference(parser, [quote || ' ', '/', '>'])\n    : { m: readExpressionList(parser), t: ARRAY_LITERAL };\n  parser.inUnquotedAttribute = false;\n  parser.spreadArgs = spread;\n\n  if (quote) {\n    parser.sp();\n    if (parser.matchString(quote) !== quote) { parser.error((\"Expected matching quote '\" + quote + \"'\")); }\n  }\n\n  if (single) {\n    var interpolator = { t: INTERPOLATOR };\n    refineExpression(expr, interpolator);\n    attribute.f = [interpolator];\n  } else {\n    attribute.f = flattenExpression(expr);\n  }\n}\n\nvar delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\nfunction readMustache(parser) {\n  var mustache, i;\n\n  // If we're inside a <script> or <style> tag, and we're not\n  // interpolating, bug out\n  if (parser.interpolate[parser.inside] === false) {\n    return null;\n  }\n\n  for (i = 0; i < parser.tags.length; i += 1) {\n    if ((mustache = readMustacheOfType(parser, parser.tags[i]))) {\n      return mustache;\n    }\n  }\n\n  if (parser.inTag && !parser.inAttribute) {\n    mustache = readAttributeOrDirective(parser);\n    if (mustache) {\n      parser.sp();\n      return mustache;\n    }\n  }\n}\n\nfunction readMustacheOfType(parser, tag) {\n  var mustache, reader, i;\n\n  var start = parser.pos;\n\n  if (parser.matchString('\\\\' + tag.open)) {\n    if (start === 0 || parser.str[start - 1] !== '\\\\') {\n      return tag.open;\n    }\n  } else if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  // delimiter change?\n  if ((mustache = readDelimiterChange(parser))) {\n    // find closing delimiter or abort...\n    if (!parser.matchString(tag.close)) {\n      return null;\n    }\n\n    // ...then make the switch\n    tag.open = mustache[0];\n    tag.close = mustache[1];\n    parser.sortMustacheTags();\n\n    return delimiterChangeToken;\n  }\n\n  parser.sp();\n\n  // illegal section closer\n  if (parser.matchString('/')) {\n    parser.pos -= 1;\n    var rewind = parser.pos;\n    if (!readNumberLiteral(parser)) {\n      parser.pos = rewind - tag.close.length;\n      if (parser.inAttribute) {\n        parser.pos = start;\n        return null;\n      } else {\n        parser.error(\"Attempted to close a section that wasn't open\");\n      }\n    } else {\n      parser.pos = rewind;\n    }\n  }\n\n  for (i = 0; i < tag.readers.length; i += 1) {\n    reader = tag.readers[i];\n\n    if ((mustache = reader(parser, tag))) {\n      if (tag.isStatic) {\n        mustache.s = 1;\n      }\n\n      if (parser.includeLinePositions) {\n        mustache.q = parser.getLinePos(start);\n      }\n\n      return mustache;\n    }\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readTriple(parser, tag) {\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nfunction readUnescaped(parser, tag) {\n  if (!parser.matchString('&')) {\n    return null;\n  }\n\n  parser.sp();\n\n  var expression = readExpression(parser);\n\n  if (!expression) {\n    return null;\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  var triple = { t: TRIPLE };\n  refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  return triple;\n}\n\nvar legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\nvar asRE = /^as/i;\n\nfunction readAliases(parser) {\n  var aliases = [];\n  var alias;\n  var start = parser.pos;\n\n  parser.sp();\n\n  alias = readAlias(parser);\n\n  if (alias) {\n    alias.x = refineExpression(alias.x, {});\n    aliases.push(alias);\n\n    parser.sp();\n\n    while (parser.matchString(',')) {\n      alias = readAlias(parser);\n\n      if (!alias) {\n        parser.error('Expected another alias.');\n      }\n\n      alias.x = refineExpression(alias.x, {});\n      aliases.push(alias);\n\n      parser.sp();\n    }\n\n    return aliases;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nfunction readAlias(parser) {\n  var start = parser.pos;\n\n  parser.sp();\n\n  var expr = readExpression(parser, []);\n\n  if (!expr) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n  parser.matchPattern(asRE);\n  parser.sp();\n\n  var alias = parser.matchPattern(legalAlias);\n\n  if (!alias) {\n    parser.pos = start;\n    return null;\n  }\n\n  return { n: alias, x: expr };\n}\n\nfunction readPartial(parser, tag) {\n  var type = parser.matchString('>') || parser.matchString('yield');\n  var partial = { t: type === '>' ? PARTIAL : YIELDER };\n  var aliases;\n\n  if (!type) { return null; }\n\n  parser.sp();\n\n  if (type === '>' || !(aliases = parser.matchString('with'))) {\n    // Partial names can include hyphens, so we can't use readExpression\n    // blindly. Instead, we use the `relaxedNames` flag to indicate that\n    // `foo-bar` should be read as a single name, rather than 'subtract\n    // bar from foo'\n    parser.relaxedNames = parser.strictRefinement = true;\n    var expression = readExpression(parser);\n    parser.relaxedNames = parser.strictRefinement = false;\n\n    if (!expression && type === '>') { return null; }\n\n    if (expression) {\n      refineExpression(expression, partial); // TODO...\n      parser.sp();\n      if (type !== '>') { aliases = parser.matchString('with'); }\n    }\n  }\n\n  parser.sp();\n\n  // check for alias context e.g. `{{>foo bar as bat, bip as bop}}`\n  if (aliases || type === '>') {\n    aliases = readAliases(parser);\n    if (aliases && aliases.length) {\n      partial.z = aliases;\n    } else {\n      // otherwise check for literal context e.g. `{{>foo bar}}` then\n      // turn it into `{{#with bar}}{{>foo}}{{/with}}`\n      var context = readExpression(parser);\n      if (context) {\n        partial.c = {};\n        refineExpression(context, partial.c);\n      }\n\n      // allow aliases after context\n      if (parser.matchString(',')) {\n        aliases = readAliases(parser);\n        if (aliases && aliases.length) {\n          partial.z = aliases;\n        }\n      }\n    }\n\n    if (type !== '>' && (!partial.c && !partial.z)) {\n      // {{yield with}} requires some aliases\n      parser.error(\"Expected a context or one or more aliases\");\n    }\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return partial;\n}\n\nfunction readComment(parser, tag) {\n  if (!parser.matchString('!')) {\n    return null;\n  }\n\n  var index = parser.remaining().indexOf(tag.close);\n\n  if (index !== -1) {\n    parser.pos += index + tag.close.length;\n    return { t: COMMENT };\n  }\n}\n\nfunction readInterpolator(parser, tag) {\n  var expression, err;\n\n  var start = parser.pos;\n\n  // TODO would be good for perf if we could do away with the try-catch\n  try {\n    expression = readExpressionOrReference(parser, [tag.close]);\n  } catch (e) {\n    err = e;\n  }\n\n  if (!expression) {\n    if (parser.str.charAt(start) === '!') {\n      // special case - comment\n      parser.pos = start;\n      return null;\n    }\n\n    if (err) {\n      throw err;\n    }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"' after reference\"));\n\n    if (!expression) {\n      // special case - comment\n      if (parser.nextChar() === '!') {\n        return null;\n      }\n\n      parser.error(\"Expected expression or legal reference\");\n    }\n  }\n\n  var interpolator = { t: INTERPOLATOR };\n  refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  return interpolator;\n}\n\nfunction readClosing(parser, tag) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('/')) {\n    parser.pos = start;\n    return null;\n  }\n\n  parser.sp();\n\n  var remaining = parser.remaining();\n  var index = remaining.indexOf(tag.close);\n\n  if (index !== -1) {\n    var closing = {\n      t: CLOSING,\n      r: remaining.substr(0, index).split(' ')[0]\n    };\n\n    parser.pos += index;\n\n    if (!parser.matchString(tag.close)) {\n      parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n    }\n\n    return closing;\n  }\n\n  parser.pos = start;\n  return null;\n}\n\nvar patterns = {\n  else: /^\\s*else\\s*/,\n  elseif: /^\\s*elseif\\s+/,\n  then: /^\\s*then\\s*/,\n  catch: /^\\s*catch\\s*/\n};\n\nvar types = {\n  else: ELSE,\n  elseif: ELSEIF,\n  then: THEN,\n  catch: CATCH\n};\n\nfunction readInlineBlock(parser, tag, type) {\n  var start = parser.pos;\n\n  if (!parser.matchString(tag.open)) {\n    return null;\n  }\n\n  if (!parser.matchPattern(patterns[type])) {\n    parser.pos = start;\n    return null;\n  }\n\n  var res = { t: types[type] };\n\n  if (type === 'elseif') {\n    res.x = readExpression(parser);\n  } else if (type === 'catch' || type === 'then') {\n    var nm = parser.matchPattern(name);\n    if (nm) { res.n = nm; }\n  }\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  return res;\n}\n\nvar handlebarsBlockCodes = {\n  each: SECTION_EACH,\n  if: SECTION_IF,\n  with: SECTION_IF_WITH,\n  unless: SECTION_UNLESS\n};\n\nvar indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\nvar handlebarsBlockPattern = new RegExp('^(' + keys(handlebarsBlockCodes).join('|') + ')\\\\b');\n\nfunction readSection(parser, tag) {\n  var expression,\n    section,\n    child,\n    children,\n    hasElse,\n    block,\n    unlessBlock,\n    closed,\n    i,\n    expectedClose,\n    hasThen,\n    hasCatch,\n    inlineThen;\n  var aliasOnly = false;\n\n  var start = parser.pos;\n\n  if (parser.matchString('^')) {\n    // watch out for parent context refs - {{^^/^^/foo}}\n    if (parser.matchString('^/')) {\n      parser.pos = start;\n      return null;\n    }\n    section = { t: SECTION, f: [], n: SECTION_UNLESS };\n  } else if (parser.matchString('#')) {\n    section = { t: SECTION, f: [] };\n\n    if (parser.matchString('partial')) {\n      parser.pos = start - parser.standardDelimiters[0].length;\n      parser.error(\n        'Partial definitions can only be at the top level of the template, or immediately inside components'\n      );\n    }\n\n    if ((block = parser.matchString('await'))) {\n      expectedClose = block;\n      section.t = AWAIT;\n    } else if ((block = parser.matchPattern(handlebarsBlockPattern))) {\n      expectedClose = block;\n      section.n = handlebarsBlockCodes[block];\n    }\n  } else {\n    return null;\n  }\n\n  parser.sp();\n\n  if (block === 'with') {\n    var aliases = readAliases(parser);\n    if (aliases) {\n      aliasOnly = true;\n      section.z = aliases;\n      section.t = ALIAS;\n    }\n  } else if (block === 'each') {\n    var alias = readAlias(parser);\n    if (alias) {\n      section.z = [{ n: alias.n, x: { r: '.' } }];\n      expression = alias.x;\n    }\n  }\n\n  if (!aliasOnly) {\n    if (!expression) { expression = readExpression(parser); }\n\n    if (!expression) {\n      parser.error('Expected expression');\n    }\n\n    // extra each aliases\n    if (block === 'each' && parser.matchString(',')) {\n      var aliases$1 = readAliases(parser);\n      if (aliases$1) {\n        if (section.z) { aliases$1.unshift(section.z[0]); }\n        section.z = aliases$1;\n      }\n    }\n\n    // optional index and key references\n    if ((block === 'each' || !block) && (i = parser.matchPattern(indexRefPattern))) {\n      var extra;\n\n      if ((extra = parser.matchPattern(keyIndexRefPattern))) {\n        section.i = i + ',' + extra;\n      } else {\n        section.i = i;\n      }\n    } else if (block === 'await' && parser.matchString('then')) {\n      parser.sp();\n      hasThen = true;\n      inlineThen = parser.matchPattern(name);\n      if (!inlineThen) { inlineThen = true; }\n    }\n\n    if (!block && expression.n) {\n      expectedClose = expression.n;\n    }\n  }\n\n  parser.sp();\n\n  if (!parser.matchString(tag.close)) {\n    parser.error((\"Expected closing delimiter '\" + (tag.close) + \"'\"));\n  }\n\n  parser.sectionDepth += 1;\n  children = section.f;\n\n  var pos;\n  do {\n    pos = parser.pos;\n    if ((child = readClosing(parser, tag))) {\n      if (expectedClose && child.r !== expectedClose) {\n        if (!block) {\n          if (child.r)\n            { parser.warn(\n              (\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close) + \" but found \" + (tag.open) + \"/\" + (child.r) + (tag.close))\n            ); }\n        } else {\n          parser.pos = pos;\n          parser.error((\"Expected \" + (tag.open) + \"/\" + expectedClose + (tag.close)));\n        }\n      }\n\n      parser.sectionDepth -= 1;\n      closed = true;\n    } else if (\n      !aliasOnly &&\n      ((child = readInlineBlock(parser, tag, 'elseif')) ||\n        (child = readInlineBlock(parser, tag, 'else')) ||\n        (block === 'await' &&\n          ((child = readInlineBlock(parser, tag, 'then')) ||\n            (child = readInlineBlock(parser, tag, 'catch')))))\n    ) {\n      if (section.n === SECTION_UNLESS) {\n        parser.error('{{else}} not allowed in {{#unless}}');\n      }\n\n      if (hasElse) {\n        if (child.t === ELSE) {\n          parser.error('there can only be one {{else}} block, at the end of a section');\n        } else if (child.t === ELSEIF) {\n          parser.error('illegal {{elseif...}} after {{else}}');\n        }\n      }\n\n      if (!unlessBlock && (inlineThen || !hasThen) && !hasCatch) {\n        if (block === 'await') {\n          var s = { f: children };\n          section.f = [s];\n          if (inlineThen) {\n            s.t = THEN;\n            inlineThen !== true && (s.n = inlineThen);\n          } else {\n            s.t = SECTION;\n          }\n        } else {\n          unlessBlock = [];\n        }\n      }\n\n      var mustache = {\n        t: SECTION,\n        f: (children = [])\n      };\n\n      if (child.t === ELSE) {\n        if (block === 'await') {\n          section.f.push(mustache);\n          mustache.t = ELSE;\n        } else {\n          mustache.n = SECTION_UNLESS;\n          unlessBlock.push(mustache);\n        }\n        hasElse = true;\n      } else if (child.t === ELSEIF) {\n        mustache.n = SECTION_IF;\n        refineExpression(child.x, mustache);\n        unlessBlock.push(mustache);\n      } else if (child.t === THEN) {\n        if (hasElse) { parser.error('{{then}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('{{then}} block must appear before any {{catch}} block'); }\n        if (hasThen) { parser.error('there can only be one {{then}} block per {{#await}}'); }\n        mustache.t = THEN;\n        hasThen = true;\n        child.n && (mustache.n = child.n);\n        section.f.push(mustache);\n      } else if (child.t === CATCH) {\n        if (hasElse) { parser.error('{{catch}} block must appear before any {{else}} block'); }\n        if (hasCatch) { parser.error('there can only be one {{catch}} block per {{#await}}'); }\n        mustache.t = CATCH;\n        hasCatch = true;\n        mustache.n = child.n;\n        section.f.push(mustache);\n      }\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        break;\n      }\n\n      children.push(child);\n    }\n  } while (!closed);\n\n  if (unlessBlock) {\n    section.l = unlessBlock;\n  }\n\n  if (!aliasOnly) {\n    refineExpression(expression, section);\n  }\n\n  if (block === 'await' && (inlineThen || !hasThen) && !hasCatch && !hasElse) {\n    var s$1 = { f: section.f };\n    section.f = [s$1];\n    if (inlineThen) {\n      s$1.t = THEN;\n      inlineThen !== true && (s$1.n = inlineThen);\n    } else {\n      s$1.t = SECTION;\n    }\n  }\n\n  // TODO if a section is empty it should be discarded. Don't do\n  // that here though - we need to clean everything up first, as\n  // it may contain removeable whitespace. As a temporary measure,\n  // to pass the existing tests, remove empty `f` arrays\n  if (!section.f.length) {\n    delete section.f;\n  }\n\n  return section;\n}\n\nvar OPEN_COMMENT = '<!--';\nvar CLOSE_COMMENT = '-->';\n\nfunction readHtmlComment(parser) {\n  var start = parser.pos;\n\n  if (parser.textOnlyMode || !parser.matchString(OPEN_COMMENT)) {\n    return null;\n  }\n\n  var remaining = parser.remaining();\n  var endIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  if (endIndex === -1) {\n    parser.error(\"Illegal HTML - expected closing comment sequence ('-->')\");\n  }\n\n  var content = remaining.substr(0, endIndex);\n  parser.pos += endIndex + 3;\n\n  var comment = {\n    t: COMMENT,\n    c: content\n  };\n\n  if (parser.includeLinePositions) {\n    comment.q = parser.getLinePos(start);\n  }\n\n  return comment;\n}\n\nvar leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\nvar trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\nfunction stripStandalones(items) {\n  var i, current, backOne, backTwo, lastSectionItem;\n\n  for (i = 1; i < items.length; i += 1) {\n    current = items[i];\n    backOne = items[i - 1];\n    backTwo = items[i - 2];\n\n    // if we're at the end of a [text][comment][text] sequence...\n    if (isString(current) && isComment(backOne) && isString(backTwo)) {\n      // ... and the comment is a standalone (i.e. line breaks either side)...\n      if (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n        // ... then we want to remove the whitespace after the first line break\n        items[i - 2] = backTwo.replace(trailingLinebreak, '\\n');\n\n        // and the leading line break of the second text token\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    }\n\n    // if the current item is a section, and it is preceded by a linebreak, and\n    // its first item is a linebreak...\n    if (isSection(current) && isString(backOne)) {\n      if (\n        trailingLinebreak.test(backOne) &&\n        isString(current.f[0]) &&\n        leadingLinebreak.test(current.f[0])\n      ) {\n        items[i - 1] = backOne.replace(trailingLinebreak, '\\n');\n        current.f[0] = current.f[0].replace(leadingLinebreak, '');\n      }\n    }\n\n    // if the last item was a section, and it is followed by a linebreak, and\n    // its last item is a linebreak...\n    if (isString(current) && isSection(backOne)) {\n      lastSectionItem = lastItem(backOne.f);\n\n      if (\n        isString(lastSectionItem) &&\n        trailingLinebreak.test(lastSectionItem) &&\n        leadingLinebreak.test(current)\n      ) {\n        backOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, '\\n');\n        items[i] = current.replace(leadingLinebreak, '');\n      }\n    }\n  }\n\n  return items;\n}\n\nfunction isComment(item) {\n  return item.t === COMMENT || item.t === DELIMCHANGE;\n}\n\nfunction isSection(item) {\n  return (item.t === SECTION || item.t === INVERTED) && item.f;\n}\n\nfunction trimWhitespace(items, leadingPattern, trailingPattern) {\n  var item;\n\n  if (leadingPattern) {\n    item = items[0];\n    if (isString(item)) {\n      item = item.replace(leadingPattern, '');\n\n      if (!item) {\n        items.shift();\n      } else {\n        items[0] = item;\n      }\n    }\n  }\n\n  if (trailingPattern) {\n    item = lastItem(items);\n    if (isString(item)) {\n      item = item.replace(trailingPattern, '');\n\n      if (!item) {\n        items.pop();\n      } else {\n        items[items.length - 1] = item;\n      }\n    }\n  }\n}\n\nvar contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\nvar leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\nvar trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\nvar leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\nvar trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\nfunction cleanup(\n  items,\n  stripComments,\n  preserveWhitespace,\n  removeLeadingWhitespace,\n  removeTrailingWhitespace,\n  whiteSpaceElements\n) {\n  if (isString(items)) { return; }\n\n  var i,\n    item,\n    previousItem,\n    nextItem,\n    preserveWhitespaceInsideFragment,\n    removeLeadingWhitespaceInsideFragment,\n    removeTrailingWhitespaceInsideFragment;\n\n  // First pass - remove standalones and comments etc\n  stripStandalones(items);\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n\n    // Remove delimiter changes, unsafe elements etc\n    if (item.exclude) {\n      items.splice(i, 1);\n    } else if (stripComments && item.t === COMMENT) {\n      // Remove comments, unless we want to keep them\n      items.splice(i, 1);\n    }\n  }\n\n  // If necessary, remove leading and trailing whitespace\n  trimWhitespace(\n    items,\n    removeLeadingWhitespace ? leadingWhitespace$1 : null,\n    removeTrailingWhitespace ? trailingWhitespace : null\n  );\n\n  i = items.length;\n  while (i--) {\n    item = items[i];\n    removeLeadingWhitespaceInsideFragment = removeTrailingWhitespaceInsideFragment = false;\n\n    // Recurse\n    if (item.f) {\n      var isPreserveWhitespaceElement =\n        item.t === ELEMENT &&\n        (whiteSpaceElements[item.e.toLowerCase()] || whiteSpaceElements[item.e]);\n      preserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n      if (!preserveWhitespace && isPreserveWhitespaceElement) {\n        trimWhitespace(item.f, leadingNewLine, trailingNewLine);\n      }\n\n      if (!preserveWhitespaceInsideFragment) {\n        previousItem = items[i - 1];\n        nextItem = items[i + 1];\n\n        // if the previous item was a text item with trailing whitespace,\n        // remove leading whitespace inside the fragment\n        if (!previousItem || (isString(previousItem) && trailingWhitespace.test(previousItem))) {\n          removeLeadingWhitespaceInsideFragment = true;\n        }\n\n        // and vice versa\n        if (!nextItem || (isString(nextItem) && leadingWhitespace$1.test(nextItem))) {\n          removeTrailingWhitespaceInsideFragment = true;\n        }\n      }\n\n      cleanup(\n        item.f,\n        stripComments,\n        preserveWhitespaceInsideFragment,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n    }\n\n    // Split if-else blocks into two (an if, and an unless)\n    if (item.l) {\n      cleanup(\n        item.l,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n\n      item.l.forEach(function (s) { return (s.l = 1); });\n      item.l.unshift(i + 1, 0);\n      items.splice.apply(items, item.l);\n      delete item.l; // TODO would be nice if there was a way around this\n    }\n\n    // Clean up conditional attributes\n    if (item.m) {\n      cleanup(\n        item.m,\n        stripComments,\n        preserveWhitespace,\n        removeLeadingWhitespaceInsideFragment,\n        removeTrailingWhitespaceInsideFragment,\n        whiteSpaceElements\n      );\n      if (item.m.length < 1) { delete item.m; }\n    }\n  }\n\n  // final pass - fuse text nodes together\n  i = items.length;\n  while (i--) {\n    if (isString(items[i])) {\n      if (isString(items[i + 1])) {\n        items[i] = items[i] + items[i + 1];\n        items.splice(i + 1, 1);\n      }\n\n      if (!preserveWhitespace) {\n        items[i] = items[i].replace(contiguousWhitespace, ' ');\n      }\n\n      if (items[i] === '') {\n        items.splice(i, 1);\n      }\n    }\n  }\n}\n\nvar closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\nfunction readClosingTag(parser) {\n  var tag;\n\n  var start = parser.pos;\n\n  // are we looking at a closing tag?\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  if ((tag = parser.matchPattern(closingTagPattern))) {\n    if (parser.inside && tag !== parser.inside) {\n      parser.pos = start;\n      return null;\n    }\n\n    return {\n      t: CLOSING_TAG,\n      e: tag\n    };\n  }\n\n  // We have an illegal closing tag, report it\n  parser.pos -= 2;\n  parser.error('Illegal closing tag');\n}\n\nfunction hyphenateCamel(camelCaseStr) {\n  return camelCaseStr.replace(/([A-Z])/g, function (match, $1) {\n    return '-' + $1.toLowerCase();\n  });\n}\n\nvar tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\nvar anchorPattern = /^[a-zA-Z_$][-a-zA-Z0-9_$]*/;\nvar validTagNameFollower = /^[\\s\\n\\/>]/;\nvar semiEnd = /;\\s*$/;\nvar exclude = { exclude: true };\n\n// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\nvar disallowedContents = {\n  li: ['li'],\n  dt: ['dt', 'dd'],\n  dd: ['dt', 'dd'],\n  p: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(\n    ' '\n  ),\n  rt: ['rt', 'rp'],\n  rp: ['rt', 'rp'],\n  optgroup: ['optgroup'],\n  option: ['option', 'optgroup'],\n  thead: ['tbody', 'tfoot'],\n  tbody: ['tbody', 'tfoot'],\n  tfoot: ['tbody'],\n  tr: ['tr', 'tbody'],\n  td: ['td', 'th', 'tr'],\n  th: ['td', 'th', 'tr']\n};\n\nfunction readElement$1(parser) {\n  var attribute,\n    selfClosing,\n    children,\n    partials,\n    hasPartials,\n    child,\n    closed,\n    pos,\n    remaining,\n    closingTag,\n    anchor;\n\n  var start = parser.pos;\n\n  if (parser.inside || parser.inAttribute || parser.textOnlyMode) {\n    return null;\n  }\n\n  if (!parser.matchString('<')) {\n    return null;\n  }\n\n  // if this is a closing tag, abort straight away\n  if (parser.nextChar() === '/') {\n    return null;\n  }\n\n  var element = {};\n  if (parser.includeLinePositions) {\n    element.q = parser.getLinePos(start);\n  }\n\n  // check for doctype decl\n  if (parser.matchString('!')) {\n    element.t = DOCTYPE;\n    if (!parser.matchPattern(/^doctype/i)) {\n      parser.error('Expected DOCTYPE declaration');\n    }\n\n    element.a = parser.matchPattern(/^(.+?)>/);\n    return element;\n  } else if ((anchor = parser.matchString('#'))) {\n    // check for anchor\n    parser.sp();\n    element.t = ANCHOR;\n    element.n = parser.matchPattern(anchorPattern);\n  } else {\n    // otherwise, it's an element/component\n    element.t = ELEMENT;\n\n    // element name\n    element.e = parser.matchPattern(tagNamePattern);\n    if (!element.e) {\n      return null;\n    }\n  }\n\n  // next character must be whitespace, closing solidus or '>'\n  if (!validTagNameFollower.test(parser.nextChar())) {\n    parser.error('Illegal tag name');\n  }\n\n  parser.sp();\n\n  parser.inTag = true;\n\n  // directives and attributes\n  while ((attribute = readMustache(parser))) {\n    if (attribute !== false) {\n      if (!element.m) { element.m = []; }\n      element.m.push(attribute);\n    }\n\n    parser.sp();\n  }\n\n  parser.inTag = false;\n\n  // allow whitespace before closing solidus\n  parser.sp();\n\n  // self-closing solidus?\n  if (parser.matchString('/')) {\n    selfClosing = true;\n  }\n\n  // closing angle bracket\n  if (!parser.matchString('>')) {\n    return null;\n  }\n\n  var lowerCaseName = (element.e || element.n).toLowerCase();\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  if (!selfClosing && (anchor || !voidElements[element.e.toLowerCase()])) {\n    if (!anchor) {\n      parser.elementStack.push(lowerCaseName);\n\n      // Special case - if we open a script element, further tags should\n      // be ignored unless they're a closing script element\n      if (lowerCaseName in parser.interpolate) {\n        parser.inside = lowerCaseName;\n      }\n    }\n\n    children = [];\n    partials = create(null);\n\n    do {\n      pos = parser.pos;\n      remaining = parser.remaining();\n\n      if (!remaining) {\n        // if this happens to be a script tag and there's no content left, it's because\n        // a closing script tag can't appear in a script\n        if (parser.inside === 'script') {\n          closed = true;\n          break;\n        }\n\n        parser.error(\n          (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack\n            .reverse()\n            .map(function (x) { return (\"</\" + x + \">\"); })\n            .join('')) + \")\")\n        );\n      }\n\n      // if for example we're in an <li> element, and we see another\n      // <li> tag, close the first so they become siblings\n      if (!anchor && !canContain(lowerCaseName, remaining)) {\n        closed = true;\n      } else if (!anchor && (closingTag = readClosingTag(parser))) {\n        // closing tag\n        closed = true;\n\n        var closingTagName = closingTag.e.toLowerCase();\n\n        // if this *isn't* the closing tag for the current element...\n        if (closingTagName !== lowerCaseName) {\n          // rewind parser\n          parser.pos = pos;\n\n          // if it doesn't close a parent tag, error\n          if (!~parser.elementStack.indexOf(closingTagName)) {\n            var errorMessage = 'Unexpected closing tag';\n\n            // add additional help for void elements, since component names\n            // might clash with them\n            if (voidElements[closingTagName.toLowerCase()]) {\n              errorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n            }\n\n            parser.error(errorMessage);\n          }\n        }\n      } else if (anchor && readAnchorClose(parser, element.n)) {\n        closed = true;\n      } else {\n        // implicit close by closing section tag. TODO clean this up\n        var tag = {\n          open: parser.standardDelimiters[0],\n          close: parser.standardDelimiters[1]\n        };\n        if (readClosing(parser, tag) || readInline(parser, tag)) {\n          closed = true;\n          parser.pos = pos;\n        } else if ((child = parser.read(PARTIAL_READERS))) {\n          if (partials[child.n]) {\n            parser.pos = pos;\n            parser.error('Duplicate partial definition');\n          }\n\n          cleanup(\n            child.f,\n            parser.stripComments,\n            preserveWhitespace,\n            !preserveWhitespace,\n            !preserveWhitespace,\n            parser.whiteSpaceElements\n          );\n\n          partials[child.n] = child.f;\n          hasPartials = true;\n        } else {\n          if ((child = parser.read(READERS))) {\n            children.push(child);\n          } else {\n            closed = true;\n          }\n        }\n      }\n    } while (!closed);\n\n    if (children.length) {\n      element.f = children;\n    }\n\n    if (hasPartials) {\n      element.p = partials;\n    }\n\n    parser.elementStack.pop();\n  }\n\n  parser.inside = null;\n\n  if (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n    return exclude;\n  }\n\n  if (\n    element.m &&\n    lowerCaseName !== 'input' &&\n    lowerCaseName !== 'select' &&\n    lowerCaseName !== 'textarea' &&\n    lowerCaseName !== 'option'\n  ) {\n    var attrs = element.m;\n    var classes, styles, cls, style;\n    var i = 0;\n    var a;\n    while (i < attrs.length) {\n      a = attrs[i];\n\n      if (a.t !== ATTRIBUTE) {\n        i++;\n        continue;\n      }\n\n      if (a.n.indexOf('class-') === 0 && !a.f) {\n        // static class directives\n        (classes || (classes = [])).push(a.n.slice(6));\n        attrs.splice(i, 1);\n      } else if (a.n.indexOf('style-') === 0 && isString(a.f)) {\n        // static style directives\n        (styles || (styles = [])).push(((hyphenateCamel(a.n.slice(6))) + \": \" + (a.f) + \";\"));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class' && isString(a.f)) {\n        // static class attrs\n        (classes || (classes = [])).push(a.f);\n        attrs.splice(i, 1);\n      } else if (a.n === 'style' && isString(a.f)) {\n        // static style attrs\n        (styles || (styles = [])).push(a.f + (semiEnd.test(a.f) ? '' : ';'));\n        attrs.splice(i, 1);\n      } else if (a.n === 'class') {\n        cls = a;\n        i++;\n      } else if (a.n === 'style') {\n        style = a;\n        i++;\n      } else if (\n        !~a.n.indexOf(':') &&\n        a.n !== 'value' &&\n        a.n !== 'contenteditable' &&\n        isString(a.f)\n      ) {\n        a.g = 1;\n        i++;\n      } else {\n        i++;\n      }\n    }\n\n    if (classes) {\n      if (!cls || !isString(cls.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'class', f: classes.join(' '), g: 1 }); }\n      else { cls.f += ' ' + classes.join(' '); }\n    } else if (cls && isString(cls.f)) { cls.g = 1; }\n\n    if (styles) {\n      if (!style || !isString(style.f))\n        { attrs.unshift({ t: ATTRIBUTE, n: 'style', f: styles.join(' '), g: 1 }); }\n      else { style.f += '; ' + styles.join(' '); }\n    } else if (style && isString(style.f)) { style.g = 1; }\n  }\n\n  return element;\n}\n\nfunction canContain(name, remaining) {\n  var match = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  var disallowed = disallowedContents[name];\n\n  if (!match || !disallowed) {\n    return true;\n  }\n\n  return !~disallowed.indexOf(match[1].toLowerCase());\n}\n\nfunction readAnchorClose(parser, name) {\n  var pos = parser.pos;\n  if (!parser.matchString('</')) {\n    return null;\n  }\n\n  parser.matchString('#');\n  parser.sp();\n\n  if (!parser.matchString(name)) {\n    parser.pos = pos;\n    return null;\n  }\n\n  parser.sp();\n\n  if (!parser.matchString('>')) {\n    parser.pos = pos;\n    return null;\n  }\n\n  return true;\n}\n\nvar inlines = /^\\s*(elseif|else|then|catch)\\s*/;\nfunction readInline(parser, tag) {\n  var pos = parser.pos;\n  if (!parser.matchString(tag.open)) { return; }\n  if (parser.matchPattern(inlines)) {\n    return true;\n  } else {\n    parser.pos = pos;\n  }\n}\n\nfunction readText(parser) {\n  var index, disallowed, barrier;\n\n  var remaining = parser.remaining();\n\n  if (parser.textOnlyMode) {\n    disallowed = parser.tags.map(function (t) { return t.open; });\n    disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n    index = getLowestIndex(remaining, disallowed);\n  } else {\n    barrier = parser.inside ? '</' + parser.inside : '<';\n\n    if (parser.inside && !parser.interpolate[parser.inside]) {\n      index = remaining.indexOf(barrier);\n    } else {\n      disallowed = parser.tags.map(function (t) { return t.open; });\n      disallowed = disallowed.concat(parser.tags.map(function (t) { return '\\\\' + t.open; }));\n\n      // http://developers.whatwg.org/syntax.html#syntax-attributes\n      if (parser.inAttribute === true) {\n        // we're inside an unquoted attribute value\n        disallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", '`');\n      } else if (parser.inAttribute) {\n        // quoted attribute value\n        disallowed.push(parser.inAttribute);\n      } else {\n        disallowed.push(barrier);\n      }\n\n      index = getLowestIndex(remaining, disallowed);\n    }\n  }\n\n  if (!index) {\n    return null;\n  }\n\n  if (index === -1) {\n    index = remaining.length;\n  }\n\n  parser.pos += index;\n\n  if ((parser.inside && parser.inside !== 'textarea') || parser.textOnlyMode) {\n    return remaining.substr(0, index);\n  } else {\n    return decodeCharacterReferences(remaining.substr(0, index));\n  }\n}\n\nvar partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\nfunction readPartialDefinitionSection(parser) {\n  var child, closed;\n\n  var start = parser.pos;\n\n  var delimiters = parser.standardDelimiters;\n\n  if (!parser.matchString(delimiters[0])) {\n    return null;\n  }\n\n  if (!parser.matchPattern(partialDefinitionSectionPattern)) {\n    parser.pos = start;\n    return null;\n  }\n\n  var name = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/);\n\n  if (!name) {\n    parser.error('expected legal partial name');\n  }\n\n  parser.sp();\n  if (!parser.matchString(delimiters[1])) {\n    parser.error((\"Expected closing delimiter '\" + (delimiters[1]) + \"'\"));\n  }\n\n  var content = [];\n\n  var open = delimiters[0];\n  var close = delimiters[1];\n\n  do {\n    if ((child = readClosing(parser, { open: open, close: close }))) {\n      if (child.r !== 'partial') {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      closed = true;\n    } else {\n      child = parser.read(READERS);\n\n      if (!child) {\n        parser.error((\"Expected \" + open + \"/partial\" + close));\n      }\n\n      content.push(child);\n    }\n  } while (!closed);\n\n  return {\n    t: INLINE_PARTIAL,\n    n: name,\n    f: content\n  };\n}\n\nfunction readTemplate(parser) {\n  var fragment = [];\n  var partials = create(null);\n  var hasPartials = false;\n\n  var preserveWhitespace = parser.preserveWhitespace;\n\n  while (parser.pos < parser.str.length) {\n    var pos = parser.pos;\n    var item = (void 0), partial = (void 0);\n\n    if ((partial = parser.read(PARTIAL_READERS))) {\n      if (partials[partial.n]) {\n        parser.pos = pos;\n        parser.error('Duplicated partial definition');\n      }\n\n      cleanup(\n        partial.f,\n        parser.stripComments,\n        preserveWhitespace,\n        !preserveWhitespace,\n        !preserveWhitespace,\n        parser.whiteSpaceElements\n      );\n\n      partials[partial.n] = partial.f;\n      hasPartials = true;\n    } else if ((item = parser.read(READERS))) {\n      fragment.push(item);\n    } else {\n      parser.error('Unexpected template content');\n    }\n  }\n\n  var result = {\n    v: TEMPLATE_VERSION,\n    t: fragment\n  };\n\n  if (hasPartials) {\n    result.p = partials;\n  }\n\n  return result;\n}\n\nfunction insertExpressions(obj, expr) {\n  keys(obj).forEach(function (key) {\n    if (isExpression(key, obj)) { return addTo(obj, expr); }\n\n    var ref = obj[key];\n    if (hasChildren(ref)) { insertExpressions(ref, expr); }\n  });\n}\n\nfunction isExpression(key, obj) {\n  return key === 's' && isArray(obj.r);\n}\n\nfunction addTo(obj, expr) {\n  var s = obj.s;\n  var r = obj.r;\n  if (!expr[s]) { expr[s] = fromExpression(s, r.length); }\n}\n\nfunction hasChildren(ref) {\n  return isArray(ref) || isObject(ref);\n}\n\nvar shared = {};\n\n// See https://github.com/ractivejs/template-spec for information\n// about the Ractive template specification\n\nvar STANDARD_READERS = [\n  readPartial,\n  readUnescaped,\n  readSection,\n  readInterpolator,\n  readComment\n];\nvar TRIPLE_READERS = [readTriple];\n\nvar READERS = [readMustache, readHtmlComment, readElement$1, readText];\nvar PARTIAL_READERS = [readPartialDefinitionSection];\n\nvar preserveWhitespaceElements = { pre: 1, script: 1, style: 1, textarea: 1 };\n\nvar defaultInterpolate = { textarea: true, script: true, style: true, template: true };\n\nvar StandardParser = Parser.extend({\n  init: function init(str, options) {\n    var tripleDelimiters = options.tripleDelimiters || shared.defaults.tripleDelimiters;\n    var staticDelimiters = options.staticDelimiters || shared.defaults.staticDelimiters;\n    var staticTripleDelimiters =\n      options.staticTripleDelimiters || shared.defaults.staticTripleDelimiters;\n\n    this.standardDelimiters = options.delimiters || shared.defaults.delimiters;\n\n    this.tags = [\n      {\n        isStatic: false,\n        isTriple: false,\n        open: this.standardDelimiters[0],\n        close: this.standardDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: false,\n        isTriple: true,\n        open: tripleDelimiters[0],\n        close: tripleDelimiters[1],\n        readers: TRIPLE_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: false,\n        open: staticDelimiters[0],\n        close: staticDelimiters[1],\n        readers: STANDARD_READERS\n      },\n      {\n        isStatic: true,\n        isTriple: true,\n        open: staticTripleDelimiters[0],\n        close: staticTripleDelimiters[1],\n        readers: TRIPLE_READERS\n      }\n    ];\n\n    this.contextLines = options.contextLines || shared.defaults.contextLines;\n\n    this.sortMustacheTags();\n\n    this.sectionDepth = 0;\n    this.elementStack = [];\n\n    this.interpolate = assign(\n      {},\n      defaultInterpolate,\n      shared.defaults.interpolate,\n      options.interpolate\n    );\n\n    if (options.sanitize === true) {\n      options.sanitize = {\n        // blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n        elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split(\n          ' '\n        ),\n        eventAttributes: true\n      };\n    }\n\n    this.stripComments = options.stripComments !== false;\n    this.preserveWhitespace = isObjectType(options.preserveWhitespace)\n      ? false\n      : options.preserveWhitespace;\n    this.sanitizeElements = options.sanitize && options.sanitize.elements;\n    this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n    this.includeLinePositions = options.includeLinePositions;\n    this.textOnlyMode = options.textOnlyMode;\n    this.csp = options.csp;\n    this.allowExpressions = options.allowExpressions;\n\n    if (options.expression) { this.converters = [readExpression]; }\n\n    if (options.attributes) { this.inTag = true; }\n\n    // special whitespace handling requested for certain elements\n    this.whiteSpaceElements = assign({}, options.preserveWhitespace, preserveWhitespaceElements);\n  },\n\n  postProcess: function postProcess(result, options) {\n    var parserResult = result[0];\n\n    if (options.expression) {\n      var expr = flattenExpression(parserResult);\n      expr.e = fromExpression(expr.s, expr.r.length);\n      return expr;\n    } else {\n      // special case - empty string\n      if (!result.length) {\n        return { t: [], v: TEMPLATE_VERSION };\n      }\n\n      if (this.sectionDepth > 0) {\n        this.error('A section was left open');\n      }\n\n      cleanup(\n        parserResult.t,\n        this.stripComments,\n        this.preserveWhitespace,\n        !this.preserveWhitespace,\n        !this.preserveWhitespace,\n        this.whiteSpaceElements\n      );\n\n      if (this.csp !== false) {\n        var expr$1 = {};\n\n        insertExpressions(parserResult.t, expr$1);\n        insertExpressions(parserResult.p || {}, expr$1);\n\n        if (keys(expr$1).length) { parserResult.e = expr$1; }\n      }\n\n      return parserResult;\n    }\n  },\n\n  converters: [readTemplate],\n\n  sortMustacheTags: function sortMustacheTags() {\n    // Sort in order of descending opening delimiter length (longer first),\n    // to protect against opening delimiters being substrings of each other\n    this.tags.sort(function (a, b) {\n      return b.open.length - a.open.length;\n    });\n  }\n});\n\nfunction parse(template, options) {\n  return new StandardParser(template, options || {}).result;\n}\n\nvar parseOptions = [\n  'delimiters',\n  'tripleDelimiters',\n  'staticDelimiters',\n  'staticTripleDelimiters',\n  'csp',\n  'interpolate',\n  'preserveWhitespace',\n  'sanitize',\n  'stripComments',\n  'contextLines',\n  'allowExpressions',\n  'attributes'\n];\n\nvar TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\nvar COMPUTATION_INSTRUCTIONS = \"Either include a version of Ractive that can parse or convert your computation strings to functions.\";\n\nfunction throwNoParse(method, error, instructions) {\n  if (!method) {\n    fatal((\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions));\n  }\n}\n\nfunction createFunction(body, length) {\n  throwNoParse(fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS);\n  return fromExpression(body, length);\n}\n\nfunction createFunctionFromString(str, bindTo) {\n  throwNoParse(parse, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS);\n  var tpl = parse(str, { expression: true });\n  return function() {\n    return tpl.e.apply(bindTo, tpl.r.map(function (r) { return bindTo.get(r); }));\n  };\n}\n\nvar parser = {\n  fromId: function fromId(id, options) {\n    if (!doc) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\"));\n    }\n\n    if (id) { id = id.replace(/^#/, ''); }\n\n    var template;\n\n    if (!(template = doc.getElementById(id))) {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Could not find template element with id #\" + id));\n    }\n\n    if (template.tagName.toUpperCase() !== 'SCRIPT') {\n      if (options && options.noThrow) {\n        return;\n      }\n      throw new Error((\"Template element with id #\" + id + \", must be a <script> element\"));\n    }\n\n    return 'textContent' in template ? template.textContent : template.innerHTML;\n  },\n\n  isParsed: function isParsed(template) {\n    return !isString(template);\n  },\n\n  getParseOptions: function getParseOptions(ractive) {\n    // Could be Ractive or a Component\n    if (ractive.defaults) {\n      ractive = ractive.defaults;\n    }\n\n    return parseOptions.reduce(function (val, key) {\n      val[key] = ractive[key];\n      return val;\n    }, {});\n  },\n\n  parse: function parse$1(template, options) {\n    throwNoParse(parse, 'template', TEMPLATE_INSTRUCTIONS);\n    var parsed = parse(template, options);\n    addFunctions(parsed);\n    return parsed;\n  },\n\n  parseFor: function parseFor(template, ractive) {\n    return this.parse(template, this.getParseOptions(ractive));\n  }\n};\n\nfunction getComputationSignature(ractive, key, signature) {\n  var getter;\n  var setter;\n\n  // useful for debugging\n  var getterString;\n  var getterUseStack;\n  var setterString;\n\n  if (isFunction(signature)) {\n    getter = bind(signature, ractive);\n    getterString = signature.toString();\n    getterUseStack = true;\n  }\n\n  if (isString(signature)) {\n    getter = createFunctionFromString(signature, ractive);\n    getterString = signature;\n  }\n\n  if (isObjectType(signature)) {\n    if (isString(signature.get)) {\n      getter = createFunctionFromString(signature.get, ractive);\n      getterString = signature.get;\n    } else if (isFunction(signature.get)) {\n      getter = bind(signature.get, ractive);\n      getterString = signature.get.toString();\n      getterUseStack = true;\n    } else {\n      fatal('`%s` computation must have a `get()` method', key);\n    }\n\n    if (isFunction(signature.set)) {\n      setter = bind(signature.set, ractive);\n      setterString = signature.set.toString();\n    }\n  }\n\n  return {\n    getter: getter,\n    setter: setter,\n    getterString: getterString,\n    setterString: setterString,\n    getterUseStack: getterUseStack\n  };\n}\n\nvar id = 0;\n\nvar TransitionManager = function TransitionManager(callback, parent) {\n  this.callback = callback;\n  this.parent = parent;\n\n  this.intros = [];\n  this.outros = [];\n\n  this.children = [];\n  this.totalChildren = this.outroChildren = 0;\n\n  this.detachQueue = [];\n  this.outrosComplete = false;\n\n  this.id = id++;\n\n  if (parent) {\n    parent.addChild(this);\n  }\n};\nvar TransitionManager__proto__ = TransitionManager.prototype;\n\nTransitionManager__proto__.add = function add (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  transition.starting = true;\n  list.push(transition);\n};\n\nTransitionManager__proto__.addChild = function addChild (child) {\n  this.children.push(child);\n\n  this.totalChildren += 1;\n  this.outroChildren += 1;\n};\n\nTransitionManager__proto__.checkStart = function checkStart () {\n  if (this.parent && this.parent.started) { this.start(); }\n};\n\nTransitionManager__proto__.decrementOutros = function decrementOutros () {\n  this.outroChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.decrementTotal = function decrementTotal () {\n  this.totalChildren -= 1;\n  check(this);\n};\n\nTransitionManager__proto__.detachNodes = function detachNodes () {\n    var this$1 = this;\n\n  var len = this.detachQueue.length;\n  for (var i = 0; i < len; i++) { this$1.detachQueue[i].detach(); }\n  len = this.children.length;\n  for (var i$1 = 0; i$1 < len; i$1++) { this$1.children[i$1].detachNodes(); }\n  this.detachQueue = [];\n};\n\nTransitionManager__proto__.ready = function ready () {\n  if (this.detachQueue.length) { detachImmediate(this); }\n};\n\nTransitionManager__proto__.remove = function remove (transition) {\n  var list = transition.isIntro ? this.intros : this.outros;\n  removeFromArray(list, transition);\n  check(this);\n};\n\nTransitionManager__proto__.start = function start () {\n  this.started = true;\n  this.children.forEach(function (c) { return c.start(); });\n  this.intros.concat(this.outros).forEach(function (t) { return t.start(); });\n  check(this);\n};\n\nfunction check(tm) {\n  if (!tm.started || tm.outros.length || tm.outroChildren) { return; }\n\n  // If all outros are complete, and we haven't already done this,\n  // we notify the parent if there is one, otherwise\n  // start detaching nodes\n  if (!tm.outrosComplete) {\n    tm.outrosComplete = true;\n\n    if (tm.parent) { tm.parent.decrementOutros(tm); }\n\n    if (!tm.parent || tm.parent.outrosComplete) {\n      tm.detachNodes();\n    }\n  }\n\n  // Once everything is done, we can notify parent transition\n  // manager and call the callback\n  if (!tm.intros.length && !tm.totalChildren) {\n    if (isFunction(tm.callback)) {\n      tm.callback();\n    }\n\n    if (tm.parent && !tm.notifiedTotal) {\n      tm.notifiedTotal = true;\n      tm.parent.decrementTotal();\n    }\n  }\n}\n\n// check through the detach queue to see if a node is up or downstream from a\n// transition and if not, go ahead and detach it\nfunction detachImmediate(manager) {\n  var queue = manager.detachQueue;\n  var outros = collectAllOutros(manager);\n\n  if (!outros.length) {\n    manager.detachNodes();\n  } else {\n    var i = queue.length;\n    var j = 0;\n    var node, trans;\n    var nqueue = (manager.detachQueue = []);\n\n    start: while (i--) {\n      node = queue[i].node;\n      j = outros.length;\n      while (j--) {\n        trans = outros[j].element.node;\n        // check to see if the node is, contains, or is contained by the transitioning node\n        if (trans === node || trans.contains(node) || node.contains(trans)) {\n          nqueue.push(queue[i]);\n          continue start;\n        }\n      }\n\n      // no match, we can drop it\n      queue[i].detach();\n    }\n  }\n}\n\nfunction collectAllOutros(manager, _list) {\n  var list = _list;\n\n  // if there's no list, we're starting at the root to build one\n  if (!list) {\n    list = [];\n    var parent = manager;\n    while (parent.parent) { parent = parent.parent; }\n    return collectAllOutros(parent, list);\n  } else {\n    // grab all outros from child managers\n    var i = manager.children.length;\n    while (i--) {\n      list = collectAllOutros(manager.children[i], list);\n    }\n\n    // grab any from this manager if there are any\n    if (manager.outros.length) { list = list.concat(manager.outros); }\n\n    return list;\n  }\n}\n\nvar batch;\n\nvar runloop = {\n  active: function active() {\n    return !!batch;\n  },\n\n  start: function start() {\n    var fulfilPromise;\n    var promise = new Promise(function (f) { return (fulfilPromise = f); });\n\n    batch = {\n      previousBatch: batch,\n      transitionManager: new TransitionManager(fulfilPromise, batch && batch.transitionManager),\n      fragments: [],\n      tasks: [],\n      immediateObservers: [],\n      deferredObservers: [],\n      promise: promise\n    };\n\n    return promise;\n  },\n\n  end: function end() {\n    flushChanges();\n\n    if (!batch.previousBatch) { batch.transitionManager.start(); }\n    else { batch.transitionManager.checkStart(); }\n\n    batch = batch.previousBatch;\n  },\n\n  addFragment: function addFragment(fragment) {\n    addToArray(batch.fragments, fragment);\n  },\n\n  // TODO: come up with a better way to handle fragments that trigger their own update\n  addFragmentToRoot: function addFragmentToRoot(fragment) {\n    if (!batch) { return; }\n\n    var b = batch;\n    while (b.previousBatch) {\n      b = b.previousBatch;\n    }\n\n    addToArray(b.fragments, fragment);\n  },\n\n  addObserver: function addObserver(observer, defer) {\n    if (!batch) {\n      observer.dispatch();\n    } else {\n      addToArray(defer ? batch.deferredObservers : batch.immediateObservers, observer);\n    }\n  },\n\n  registerTransition: function registerTransition(transition) {\n    transition._manager = batch.transitionManager;\n    batch.transitionManager.add(transition);\n  },\n\n  // synchronise node detachments with transition ends\n  detachWhenReady: function detachWhenReady(thing) {\n    batch.transitionManager.detachQueue.push(thing);\n  },\n\n  scheduleTask: function scheduleTask(task, postRender) {\n    var _batch;\n\n    if (!batch) {\n      task();\n    } else {\n      _batch = batch;\n      while (postRender && _batch.previousBatch) {\n        // this can't happen until the DOM has been fully updated\n        // otherwise in some situations (with components inside elements)\n        // transitions and decorators will initialise prematurely\n        _batch = _batch.previousBatch;\n      }\n\n      _batch.tasks.push(task);\n    }\n  },\n\n  promise: function promise() {\n    if (!batch) { return Promise.resolve(); }\n\n    var target = batch;\n    while (target.previousBatch) {\n      target = target.previousBatch;\n    }\n\n    return target.promise || Promise.resolve();\n  }\n};\n\nfunction dispatch(observer) {\n  observer.dispatch();\n}\n\nfunction flushChanges() {\n  var which = batch.immediateObservers;\n  batch.immediateObservers = [];\n  which.forEach(dispatch);\n\n  // Now that changes have been fully propagated, we can update the DOM\n  // and complete other tasks\n  var i = batch.fragments.length;\n  var fragment;\n\n  which = batch.fragments;\n  batch.fragments = [];\n\n  while (i--) {\n    fragment = which[i];\n    fragment.update();\n  }\n\n  batch.transitionManager.ready();\n\n  which = batch.deferredObservers;\n  batch.deferredObservers = [];\n  which.forEach(dispatch);\n\n  var tasks = batch.tasks;\n  batch.tasks = [];\n\n  for (i = 0; i < tasks.length; i += 1) {\n    tasks[i]();\n  }\n\n  // If updating the view caused some model blowback - e.g. a triple\n  // containing <option> elements caused the binding on the <select>\n  // to update - then we start over\n  if (\n    batch.fragments.length ||\n    batch.immediateObservers.length ||\n    batch.deferredObservers.length ||\n    batch.tasks.length\n  )\n    { return flushChanges(); }\n}\n\n// TODO what happens if a transition is aborted?\n\nvar tickers = [];\nvar running = false;\n\nfunction tick() {\n  runloop.start();\n\n  var now = performance.now();\n\n  var i;\n  var ticker;\n\n  for (i = 0; i < tickers.length; i += 1) {\n    ticker = tickers[i];\n\n    if (!ticker.tick(now)) {\n      // ticker is complete, remove it from the stack, and decrement i so we don't miss one\n      tickers.splice(i--, 1);\n    }\n  }\n\n  runloop.end();\n\n  if (tickers.length) {\n    requestAnimationFrame(tick);\n  } else {\n    running = false;\n  }\n}\n\nvar Ticker = function Ticker(options) {\n  this.duration = options.duration;\n  this.step = options.step;\n  this.complete = options.complete;\n  this.easing = options.easing;\n\n  this.start = performance.now();\n  this.end = this.start + this.duration;\n\n  this.running = true;\n\n  tickers.push(this);\n  if (!running) { requestAnimationFrame(tick); }\n};\nvar Ticker__proto__ = Ticker.prototype;\n\nTicker__proto__.tick = function tick (now) {\n  if (!this.running) { return false; }\n\n  if (now > this.end) {\n    if (this.step) { this.step(1); }\n    if (this.complete) { this.complete(1); }\n\n    return false;\n  }\n\n  var elapsed = now - this.start;\n  var eased = this.easing(elapsed / this.duration);\n\n  if (this.step) { this.step(eased); }\n\n  return true;\n};\n\nTicker__proto__.stop = function stop () {\n  if (this.abort) { this.abort(); }\n  this.running = false;\n};\n\nvar prefixers = {};\n\n// TODO this is legacy. sooner we can replace the old adaptor API the better\n/* istanbul ignore next */\nfunction prefixKeypath(obj, prefix) {\n  var prefixed = {};\n\n  if (!prefix) {\n    return obj;\n  }\n\n  prefix += '.';\n\n  for (var key in obj) {\n    if (hasOwn(obj, key)) {\n      prefixed[prefix + key] = obj[key];\n    }\n  }\n\n  return prefixed;\n}\n\nfunction getPrefixer(rootKeypath) {\n  var rootDot;\n\n  if (!prefixers[rootKeypath]) {\n    rootDot = rootKeypath ? rootKeypath + '.' : '';\n\n    /* istanbul ignore next */\n    prefixers[rootKeypath] = function(relativeKeypath, value) {\n      var obj;\n\n      if (isString(relativeKeypath)) {\n        obj = {};\n        obj[rootDot + relativeKeypath] = value;\n        return obj;\n      }\n\n      if (isObjectType(relativeKeypath)) {\n        // 'relativeKeypath' is in fact a hash, not a keypath\n        return rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n      }\n    };\n  }\n\n  return prefixers[rootKeypath];\n}\n\nvar shared$1 = {};\n\nvar Model = (function (ModelBase) {\n  function Model(parent, key) {\n    ModelBase.call(this, parent);\n\n    this.ticker = null;\n\n    if (parent) {\n      this.key = unescapeKey(key);\n      this.isReadonly = parent.isReadonly;\n\n      if (parent.value) {\n        this.value = parent.value[this.key];\n        if (isArray(this.value)) { this.length = this.value.length; }\n        this.adapt();\n      }\n    }\n  }\n\n  if ( ModelBase ) Model.__proto__ = ModelBase;\n  var Model__proto__ = Model.prototype = Object.create( ModelBase && ModelBase.prototype );\n  Model__proto__.constructor = Model;\n\n  Model__proto__.adapt = function adapt () {\n    var this$1 = this;\n\n    var adaptors = this.root.adaptors;\n    var len = adaptors.length;\n\n    this.rewrap = false;\n\n    // Exit early if no adaptors\n    if (len === 0) { return; }\n\n    var value = this.wrapper\n      ? 'newWrapperValue' in this\n        ? this.newWrapperValue\n        : this.wrapperValue\n      : this.value;\n\n    // TODO remove this legacy nonsense\n    var ractive = this.root.ractive;\n    var keypath = this.getKeypath();\n\n    // tear previous adaptor down if present\n    if (this.wrapper) {\n      var shouldTeardown =\n        this.wrapperValue === value\n          ? false\n          : !this.wrapper.reset || this.wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        this.wrapper.teardown();\n        delete this.wrapper;\n        delete this.wrapperValue;\n        delete this.newWrapperValue;\n\n        // don't branch for undefined values\n        if (this.value !== undefined) {\n          var parentValue = this.parent.value || this.parent.createBranch(this.key);\n          if (parentValue[this.key] !== value) { parentValue[this.key] = value; }\n          this.value = value;\n        }\n      } else {\n        delete this.newWrapperValue;\n        this.value = this.wrapper.get();\n        return;\n      }\n    }\n\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var adaptor = adaptors[i];\n      if (adaptor.filter(value, keypath, ractive)) {\n        this$1.wrapper = adaptor.wrap(ractive, value, keypath, getPrefixer(keypath));\n        this$1.wrapperValue = value;\n        this$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\n        this$1.value = this$1.wrapper.get();\n\n        break;\n      }\n    }\n  };\n\n  Model__proto__.animate = function animate (from, to, options, interpolator) {\n    var this$1 = this;\n\n    if (this.ticker) { this.ticker.stop(); }\n\n    var fulfilPromise;\n    var promise = new Promise(function (fulfil) { return (fulfilPromise = fulfil); });\n\n    this.ticker = new Ticker({\n      duration: options.duration,\n      easing: options.easing,\n      step: function (t) {\n        var value = interpolator(t);\n        this$1.applyValue(value);\n        if (options.step) { options.step(t, value); }\n      },\n      complete: function () {\n        this$1.applyValue(to);\n        if (options.complete) { options.complete(to); }\n\n        this$1.ticker = null;\n        fulfilPromise(to);\n      }\n    });\n\n    promise.stop = this.ticker.stop;\n    return promise;\n  };\n\n  Model__proto__.applyValue = function applyValue (value, notify) {\n    if ( notify === void 0 ) notify = true;\n\n    if (isEqual(value, this.value)) { return; }\n    if (this.boundValue) { this.boundValue = null; }\n\n    if (this.parent.wrapper && this.parent.wrapper.set) {\n      this.parent.wrapper.set(this.key, value);\n      this.parent.value = this.parent.wrapper.get();\n\n      this.value = this.parent.value[this.key];\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    } else if (this.wrapper) {\n      this.newWrapperValue = value;\n      this.adapt();\n    } else {\n      var parentValue = this.parent.value || this.parent.createBranch(this.key);\n      if (isObjectLike(parentValue)) {\n        parentValue[this.key] = value;\n      } else {\n        warnIfDebug((\"Attempted to set a property of a non-object '\" + (this.getKeypath()) + \"'\"));\n        return;\n      }\n\n      this.value = value;\n      this.adapt();\n    }\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    // keep track of array stuff\n    if (isArray(value)) {\n      this.length = value.length;\n      this.isArray = true;\n    } else {\n      this.isArray = false;\n    }\n\n    // notify dependants\n    this.links.forEach(handleChange);\n    this.children.forEach(mark);\n    this.deps.forEach(handleChange);\n\n    if (notify) { this.notifyUpstream(); }\n\n    if (this.parent.isArray) {\n      if (this.key === 'length') { this.parent.length = value; }\n      else { this.parent.joinKey('length').mark(); }\n    }\n  };\n\n  Model__proto__.compute = function compute (key, computed) {\n    var registry = this.computed || (this.computed = {});\n\n    if (registry[key]) {\n      registry[key].signature = getComputationSignature(this.root.ractive, key, computed);\n      registry[key].mark();\n    } else {\n      registry[key] = new shared$1.Computation(\n        this,\n        getComputationSignature(this.root.ractive, key, computed),\n        key\n      );\n    }\n\n    return registry[key];\n  };\n\n  Model__proto__.createBranch = function createBranch (key) {\n    var branch = isNumeric(key) ? [] : {};\n    this.applyValue(branch, false);\n\n    return branch;\n  };\n\n  Model__proto__.get = function get (shouldCapture, opts) {\n    if (this._link) { return this._link.get(shouldCapture, opts); }\n    if (shouldCapture) { capture(this); }\n    // if capturing, this value needs to be unwrapped because it's for external use\n    if (opts && opts.virtual) { return this.getVirtual(false); }\n    return maybeBind(\n      this,\n      (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Model__proto__.joinKey = function joinKey (key, opts) {\n    var this$1 = this;\n\n    if (this._link) {\n      if (opts && opts.lastLink !== false && (isUndefined(key) || key === '')) { return this; }\n      return this._link.joinKey(key);\n    }\n\n    if (isUndefined(key) || key === '') { return this; }\n\n    var child;\n    if (hasOwn(this.childByKey, key)) { child = this.childByKey[key]; }\n    else { child = this.computed && this.computed[key]; }\n\n    if (!child) {\n      var computed;\n      if (this.isRoot && this.ractive && (computed = this.ractive.computed[key])) {\n        child = this.compute(key, computed);\n      } else if (!this.isRoot && this.root.ractive) {\n        var registry = this.root.ractive.computed;\n        for (var k in registry) {\n          computed = registry[k];\n          if (computed.pattern && computed.pattern.test(this$1.getKeypath() + '.' + key)) {\n            child = this$1.compute(key, computed);\n          }\n        }\n      }\n    }\n\n    if (!child) {\n      child = new Model(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n\n      if (key === 'data') {\n        var val = this.retrieve();\n        if (val && val.viewmodel && val.viewmodel.isRoot) {\n          child.link(val.viewmodel, 'data');\n          this.dataModel = val;\n        }\n      }\n    }\n\n    if (child._link && (!opts || opts.lastLink !== false)) { return child._link; }\n\n    return child;\n  };\n\n  Model__proto__.mark = function mark$1 (force) {\n    if (this._link) { return this._link.mark(force); }\n\n    var old = this.value;\n    var value = this.retrieve();\n\n    if (this.dataModel || (value && value.viewmodel && value.viewmodel.isRoot)) {\n      checkDataLink(this, value);\n    }\n\n    if (force || !isEqual(value, old)) {\n      this.value = value;\n      if (this.boundValue) { this.boundValue = null; }\n\n      // make sure the wrapper stays in sync\n      if (old !== value || this.rewrap) {\n        if (this.wrapper) { this.newWrapperValue = value; }\n        this.adapt();\n      }\n\n      // keep track of array stuff\n      if (isArray(value)) {\n        this.length = value.length;\n        this.isArray = true;\n      } else {\n        this.isArray = false;\n      }\n\n      this.children.forEach(force ? markForce : mark);\n      this.links.forEach(marked);\n\n      this.deps.forEach(handleChange);\n    }\n  };\n\n  Model__proto__.merge = function merge (array, comparator) {\n    var newIndices = buildNewIndices(\n      this.value === array ? recreateArray(this) : this.value,\n      array,\n      comparator\n    );\n    this.parent.value[this.key] = array;\n    this.shuffle(newIndices, true);\n  };\n\n  Model__proto__.retrieve = function retrieve () {\n    return this.parent.value ? this.parent.value[this.key] : undefined;\n  };\n\n  Model__proto__.set = function set (value) {\n    if (this.ticker) { this.ticker.stop(); }\n    this.applyValue(value);\n  };\n\n  Model__proto__.shuffle = function shuffle$2 (newIndices, unsafe) {\n    shuffle(this, newIndices, false, unsafe);\n  };\n\n  Model__proto__.source = function source () {\n    return this;\n  };\n\n  Model__proto__.teardown = function teardown$4 () {\n    var this$1 = this;\n\n    if (this._link) {\n      this._link.teardown();\n      this._link = null;\n    }\n    this.children.forEach(teardown);\n    if (this.wrapper) { this.wrapper.teardown(); }\n    if (this.computed) { keys(this.computed).forEach(function (k) { return this$1.computed[k].teardown(); }); }\n  };\n\n  return Model;\n}(ModelBase));\n\nfunction recreateArray(model) {\n  var array = [];\n\n  for (var i = 0; i < model.length; i++) {\n    array[i] = (model.childByKey[i] || {}).value;\n  }\n\n  return array;\n}\n\n/* global global */\nvar data = {};\n\nvar SharedModel = (function (Model) {\n  function SharedModel(value, name, ractive) {\n    Model.call(this, null, (\"@\" + name));\n    this.key = \"@\" + name;\n    this.value = value;\n    this.isRoot = true;\n    this.root = this;\n    this.adaptors = [];\n    this.ractive = ractive;\n  }\n\n  if ( Model ) SharedModel.__proto__ = Model;\n  var SharedModel__proto__ = SharedModel.prototype = Object.create( Model && Model.prototype );\n  SharedModel__proto__.constructor = SharedModel;\n\n  SharedModel__proto__.getKeypath = function getKeypath () {\n    return this.key;\n  };\n\n  SharedModel__proto__.retrieve = function retrieve () {\n    return this.value;\n  };\n\n  return SharedModel;\n}(Model));\n\nvar SharedModel$1 = new SharedModel(data, 'shared');\n\nvar GlobalModel = new SharedModel(base, 'global');\n\nfunction findContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context && !frag.aliases) { frag = frag.parent; }\n  return frag;\n}\n\nfunction resolveReference(fragment, ref) {\n  var initialFragment = fragment;\n  // current context ref\n  if (ref === '.') { return fragment.findContext(); }\n\n  // ancestor references\n  if (ref[0] === '~') { return fragment.ractive.viewmodel.joinAll(splitKeypath(ref.slice(2))); }\n\n  // scoped references\n  if (ref[0] === '.' || ref[0] === '^') {\n    var frag = fragment;\n    var parts = ref.split('/');\n    var explicitContext = parts[0] === '^^';\n\n    // find nearest context node\n    while (frag && !frag.context) {\n      frag = up(frag);\n    }\n    var context$1 = frag && frag.context;\n\n    // walk up the context chain\n    while (frag && parts[0] === '^^') {\n      parts.shift();\n\n      // the current fragment should always be a context,\n      // and if it happens to be an iteration, jump above the each block\n      if (frag.isIteration) {\n        frag = frag.parent.parent;\n      } else {\n        // otherwise jump above the current fragment\n        frag = up(frag);\n      }\n\n      // walk to the next contexted fragment\n      while (frag && !frag.context) {\n        frag = up(frag);\n      }\n      context$1 = frag && frag.context;\n    }\n\n    if (!context$1 && explicitContext) {\n      throw new Error(\n        (\"Invalid context parent reference ('\" + ref + \"'). There is not context at that level.\")\n      );\n    }\n\n    // walk up the context path\n    while (parts[0] === '.' || parts[0] === '..') {\n      var part = parts.shift();\n\n      if (part === '..') {\n        context$1 = context$1.parent;\n      }\n    }\n\n    ref = parts.join('/');\n\n    // special case - `{{.foo}}` means the same as `{{./foo}}`\n    if (ref[0] === '.') { ref = ref.slice(1); }\n    return context$1.joinAll(splitKeypath(ref));\n  }\n\n  var keys$$1 = splitKeypath(ref);\n  if (!keys$$1.length) { return; }\n  var base = keys$$1.shift();\n\n  // special refs\n  if (base[0] === '@') {\n    // shorthand from outside the template\n    // @this referring to local ractive instance\n    if (base === '@this' || base === '@') {\n      return fragment.ractive.viewmodel.getRactiveModel().joinAll(keys$$1);\n    } else if (base === '@index' || base === '@key') {\n      // @index or @key referring to the nearest repeating index or key\n      if (keys$$1.length) { badReference(base); }\n      var repeater = findIter(fragment);\n      return repeater && repeater[(\"get\" + (base[1] === 'i' ? 'Index' : 'Key'))]();\n    } else if (base === '@last') {\n      var repeater$1 = findIter(fragment);\n      return repeater$1 && repeater$1.parent.getLast();\n    } else if (base === '@global') {\n      // @global referring to window or global\n      return GlobalModel.joinAll(keys$$1);\n    } else if (base === '@shared') {\n      // @global referring to window or global\n      return SharedModel$1.joinAll(keys$$1);\n    } else if (base === '@keypath' || base === '@rootpath') {\n      // @keypath or @rootpath, the current keypath string\n      var root = ref[1] === 'r' ? fragment.ractive.root : null;\n      var f = fragment;\n\n      while (\n        f &&\n        (!f.context || (f.isRoot && f.ractive.component && (root || !f.ractive.isolated)))\n      ) {\n        f = f.isRoot ? f.componentParent : f.parent;\n      }\n\n      return f.getKeypath(root);\n    } else if (base === '@context') {\n      return new SharedModel(fragment.getContext(), 'context').joinAll(keys$$1);\n    } else if (base === '@local') {\n      // @context-local data\n      return fragment.getContext()._data.joinAll(keys$$1);\n    } else if (base === '@style') {\n      // @style shared model\n      return fragment.ractive.constructor._cssModel.joinAll(keys$$1);\n    } else if (base === '@helpers') {\n      // @helpers instance model\n      return fragment.ractive.viewmodel.getHelpers().joinAll(keys$$1);\n    } else if (base === '@macro') {\n      var handle = findMacro(fragment);\n      if (handle) { return new SharedModel(handle, 'macro').joinAll(keys$$1); }\n      else { return; }\n    } else {\n      // nope\n      throw new Error((\"Invalid special reference '\" + base + \"'\"));\n    }\n  }\n\n  // helpers\n  if (base && !keys$$1.length) {\n    var helpers = fragment.ractive.viewmodel.getHelpers();\n    if (helpers.has(base)) { return helpers.joinKey(base); }\n  }\n\n  var context = findContext(fragment);\n\n  // check immediate context for a match\n  if (context) {\n    if (context.context) {\n      context = context.context;\n    } else {\n      // alias block, so get next full context for later\n      context = fragment.findContext();\n    }\n  } else {\n    context = fragment.findContext();\n  }\n\n  // walk up the fragment hierarchy looking for a matching ref, alias, or key in a context\n  var createMapping = false;\n  var shouldWarn = fragment.ractive.warnAboutAmbiguity;\n  var crossed = 0;\n  var model;\n\n  while (fragment) {\n    // repeated fragments\n    if (fragment.isIteration) {\n      if (base === fragment.parent.keyRef) {\n        model = fragment.getKey();\n      } else if (base === fragment.parent.indexRef) {\n        model = fragment.getIndex();\n      }\n\n      if (model && keys$$1.length) { badReference(base); }\n    }\n\n    // alias node or iteration\n    if (!model && fragment.aliases && hasOwn(fragment.aliases, base)) {\n      model = fragment.aliases[base];\n    }\n\n    // check fragment context to see if it has the key we need\n    if (!model && fragment.context && fragment.context.has(base)) {\n      model = fragment.context.joinKey(base);\n\n      // this is an implicit mapping\n      if (createMapping) {\n        if (shouldWarn)\n          { warnIfDebug(\n            (\"'\" + ref + \"' resolved but is ambiguous and will create a mapping to a parent component.\")\n          ); }\n      } else if (shouldWarn && crossed) { warnIfDebug((\"'\" + ref + \"' resolved but is ambiguous.\")); }\n    }\n\n    if (model) {\n      if (createMapping) {\n        model = initialFragment.ractive.viewmodel.createLink(base, model, base, { implicit: true });\n      }\n\n      if (keys$$1.length > 0 && isFunction(model.joinAll)) {\n        model = model.joinAll(keys$$1);\n      }\n\n      return model;\n    }\n\n    // don't consider alias blocks when checking for ambiguity\n    if (fragment.context && !fragment.aliases) { crossed = 1; }\n\n    if (\n      (fragment.componentParent || (!fragment.parent && fragment.ractive.component)) &&\n      !fragment.ractive.isolated\n    ) {\n      // ascend through component boundary\n      fragment = fragment.componentParent || fragment.ractive.component.up;\n      createMapping = true;\n    } else {\n      fragment = fragment.parent;\n    }\n  }\n\n  // if enabled, check the instance for a match\n  var instance = initialFragment.ractive;\n  if (instance.resolveInstanceMembers && base !== 'data' && base in instance) {\n    return instance.viewmodel\n      .getRactiveModel()\n      .joinKey(base)\n      .joinAll(keys$$1);\n  }\n\n  if (shouldWarn) {\n    warnIfDebug((\"'\" + ref + \"' is ambiguous and did not resolve.\"));\n  }\n\n  // didn't find anything, so go ahead and create the key on the local model\n  return context.joinKey(base).joinAll(keys$$1);\n}\n\nfunction up(fragment) {\n  return fragment && ((!fragment.ractive.isolated && fragment.componentParent) || fragment.parent);\n}\n\nfunction findIter(start) {\n  var fragment = start;\n  var next;\n  while (!fragment.isIteration && (next = up(fragment))) {\n    fragment = next;\n  }\n\n  return fragment.isIteration && fragment;\n}\n\nfunction findMacro(start) {\n  var fragment = start;\n  while (fragment) {\n    if (fragment.owner.handle) { return fragment.owner.handle; }\n    fragment = up(fragment);\n  }\n}\n\nfunction badReference(key) {\n  throw new Error((\"An index or key reference (\" + key + \") cannot have child properties\"));\n}\n\nvar extern = {};\n\nfunction getRactiveContext(ractive) {\n  var assigns = [], len = arguments.length - 1;\n  while ( len-- > 0 ) assigns[ len ] = arguments[ len + 1 ];\n\n  var fragment =\n    ractive.fragment ||\n    ractive._fakeFragment ||\n    (ractive._fakeFragment = new FakeFragment(ractive));\n  return fragment.getContext.apply(fragment, assigns);\n}\n\nfunction getContext() {\n  var assigns = [], len = arguments.length;\n  while ( len-- ) assigns[ len ] = arguments[ len ];\n\n  if (!this.ctx) { this.ctx = new extern.Context(this); }\n  assigns.unshift(create(this.ctx));\n  return assign.apply(null, assigns);\n}\n\nvar FakeFragment = function FakeFragment(ractive) {\n  this.ractive = ractive;\n};\n\nFakeFragment.prototype.findContext = function findContext () {\n  return this.ractive.viewmodel;\n};\nvar proto = FakeFragment.prototype;\nproto.getContext = getContext;\nproto.find = proto.findComponent = proto.findAll = proto.findAllComponents = noop;\n\nfunction findParentWithContext(fragment) {\n  var frag = fragment;\n  while (frag && !frag.context) { frag = frag.parent; }\n  if (!frag) { return fragment && fragment.ractive.fragment; }\n  else { return frag; }\n}\n\nvar keep = false;\n\nfunction set(pairs, options) {\n  var k = keep;\n\n  var deep = options && options.deep;\n  var shuffle = options && options.shuffle;\n  var promise = runloop.start();\n  if (options && 'keep' in options) { keep = options.keep; }\n\n  var i = pairs.length;\n  while (i--) {\n    var model = pairs[i][0];\n    var value = pairs[i][1];\n    var keypath = pairs[i][2];\n\n    if (!model) {\n      runloop.end();\n      throw new Error((\"Failed to set invalid keypath '\" + keypath + \"'\"));\n    }\n\n    if (deep) { deepSet(model, value); }\n    else if (shuffle) {\n      var array = value;\n      var target = model.get();\n      // shuffle target array with itself\n      if (!array) { array = target; }\n\n      // if there's not an array there yet, go ahead and set\n      if (isUndefined(target)) {\n        model.set(array);\n      } else {\n        if (!isArray(target) || !isArray(array)) {\n          runloop.end();\n          throw new Error('You cannot merge an array with a non-array');\n        }\n\n        var comparator = getComparator(shuffle);\n        model.merge(array, comparator);\n      }\n    } else { model.set(value); }\n  }\n\n  runloop.end();\n\n  keep = k;\n\n  return promise;\n}\n\nvar star = /\\*/;\nfunction gather(ractive, keypath, base, isolated) {\n  if (!base && (keypath[0] === '.' || keypath[1] === '^')) {\n    warnIfDebug(\n      \"Attempted to set a relative keypath from a non-relative context. You can use a context object to set relative keypaths.\"\n    );\n    return [];\n  }\n\n  var keys$$1 = splitKeypath(keypath);\n  var model = base || ractive.viewmodel;\n\n  if (star.test(keypath)) {\n    return model.findMatches(keys$$1);\n  } else {\n    if (model === ractive.viewmodel) {\n      // allow implicit mappings\n      if (\n        ractive.component &&\n        !ractive.isolated &&\n        !model.has(keys$$1[0]) &&\n        keypath[0] !== '@' &&\n        keypath[0] &&\n        !isolated\n      ) {\n        return [resolveReference(ractive.fragment || new FakeFragment(ractive), keypath)];\n      } else {\n        return [model.joinAll(keys$$1)];\n      }\n    } else {\n      return [model.joinAll(keys$$1)];\n    }\n  }\n}\n\nfunction build(ractive, keypath, value, isolated) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    var loop = function ( k ) {\n      if (hasOwn(keypath, k)) {\n        sets.push.apply(sets, gather(ractive, k, null, isolated).map(function (m) { return [m, keypath[k], k]; }));\n      }\n    };\n\n    for (var k in keypath) loop( k );\n  } else {\n    // set a single keypath\n    sets.push.apply(sets, gather(ractive, keypath, null, isolated).map(function (m) { return [m, value, keypath]; }));\n  }\n\n  return sets;\n}\n\nvar deepOpts = { virtual: false };\nfunction deepSet(model, value) {\n  var dest = model.get(false, deepOpts);\n\n  // if dest doesn't exist, just set it\n  if (dest == null || !isObjectType(value)) { return model.set(value); }\n  if (!isObjectType(dest)) { return model.set(value); }\n\n  for (var k in value) {\n    if (hasOwn(value, k)) {\n      deepSet(model.joinKey(k), value[k]);\n    }\n  }\n}\n\nvar comparators = {};\nfunction getComparator(option) {\n  if (option === true) { return null; } // use existing arrays\n  if (isFunction(option)) { return option; }\n\n  if (isString(option)) {\n    return comparators[option] || (comparators[option] = function (thing) { return thing[option]; });\n  }\n\n  throw new Error('If supplied, options.compare must be a string, function, or true'); // TODO link to docs\n}\n\nvar errorMessage = 'Cannot add to a non-numeric value';\n\nfunction add(ractive, keypath, d, options) {\n  if (!isString(keypath) || !isNumeric(d)) {\n    throw new Error('Bad arguments');\n  }\n\n  var sets = build(ractive, keypath, d, options && options.isolated);\n\n  return set(\n    sets.map(function (pair) {\n      var model = pair[0];\n      var add = pair[1];\n      var value = model.get();\n      if (!isNumeric(add) || !isNumeric(value)) { throw new Error(errorMessage); }\n      return [model, value + add];\n    })\n  );\n}\n\nfunction Ractive$add(keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction immediate(value) {\n  var result = Promise.resolve(value);\n  defineProperty(result, 'stop', { value: noop });\n  return result;\n}\n\nvar linear = easing.linear;\n\nfunction getOptions(options, instance) {\n  options = options || {};\n\n  var easing$$1;\n  if (options.easing) {\n    easing$$1 = isFunction(options.easing) ? options.easing : instance.easing[options.easing];\n  }\n\n  return {\n    easing: easing$$1 || linear,\n    duration: 'duration' in options ? options.duration : 400,\n    complete: options.complete || noop,\n    step: options.step || noop,\n    interpolator: options.interpolator\n  };\n}\n\nfunction animate(ractive, model, to, options) {\n  options = getOptions(options, ractive);\n  var from = model.get();\n\n  // don't bother animating values that stay the same\n  if (isEqual(from, to)) {\n    options.complete(options.to);\n    return immediate(to);\n  }\n\n  var interpolator = interpolate(from, to, ractive, options.interpolator);\n\n  // if we can't interpolate the value, set it immediately\n  if (!interpolator) {\n    runloop.start();\n    model.set(to);\n    runloop.end();\n\n    return immediate(to);\n  }\n\n  return model.animate(from, to, options, interpolator);\n}\n\nfunction Ractive$animate(keypath, to, options) {\n  if (isObjectType(keypath)) {\n    var keys$$1 = keys(keypath);\n\n    throw new Error((\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys$$1.map(function (key) { return (\"'\" + key + \"': \" + (keypath[key])); }).join('\\n  ')) + \"\\n}, {...}), do\\n\\n\" + (keys$$1.map(function (key) { return (\"ractive.animate('\" + key + \"', \" + (keypath[key]) + \", {...});\"); }).join('\\n')) + \"\\n\"));\n  }\n\n  return animate(this, this.viewmodel.joinAll(splitKeypath(keypath)), to, options);\n}\n\nfunction enqueue(ractive, event) {\n  if (ractive.event) {\n    ractive._eventQueue.push(ractive.event);\n  }\n\n  ractive.event = event;\n}\n\nfunction dequeue(ractive) {\n  if (ractive._eventQueue.length) {\n    ractive.event = ractive._eventQueue.pop();\n  } else {\n    ractive.event = null;\n  }\n}\n\nvar initStars = {};\nvar bubbleStars = {};\n\n// cartesian product of name parts and stars\n// adjusted appropriately for special cases\nfunction variants(name, initial) {\n  var map = initial ? initStars : bubbleStars;\n  if (map[name]) { return map[name]; }\n\n  var parts = name.split('.');\n  var result = [];\n  var base = false;\n\n  // initial events the implicit namespace of 'this'\n  if (initial) {\n    parts.unshift('this');\n    base = true;\n  }\n\n  // use max - 1 bits as a bitmap to pick a part or a *\n  // need to skip the full star case if the namespace is synthetic\n  var max = Math.pow(2, parts.length) - (initial ? 1 : 0);\n  for (var i = 0; i < max; i++) {\n    var join = [];\n    for (var j = 0; j < parts.length; j++) {\n      join.push(1 & (i >> j) ? '*' : parts[j]);\n    }\n    result.unshift(join.join('.'));\n  }\n\n  if (base) {\n    // include non-this-namespaced versions\n    if (parts.length > 2) {\n      result.push.apply(result, variants(name, false));\n    } else {\n      result.push('*');\n      result.push(name);\n    }\n  }\n\n  map[name] = result;\n  return result;\n}\n\nfunction fireEvent(ractive, eventName, context, args) {\n  if ( args === void 0 ) args = [];\n\n  if (!eventName) {\n    return;\n  }\n\n  context.name = eventName;\n  args.unshift(context);\n\n  var eventNames = ractive._nsSubs ? variants(eventName, true) : ['*', eventName];\n\n  return fireEventAs(ractive, eventNames, context, args, true);\n}\n\nfunction fireEventAs(ractive, eventNames, context, args, initialFire) {\n  if ( initialFire === void 0 ) initialFire = false;\n\n  var bubble = true;\n\n  if (initialFire || ractive._nsSubs) {\n    enqueue(ractive, context);\n\n    var i = eventNames.length;\n    while (i--) {\n      if (eventNames[i] in ractive._subs) {\n        bubble = notifySubscribers(ractive, ractive._subs[eventNames[i]], context, args) && bubble;\n      }\n    }\n\n    dequeue(ractive);\n  }\n\n  if (ractive.parent && bubble) {\n    if (initialFire && ractive.component) {\n      var fullName = ractive.component.name + '.' + eventNames[eventNames.length - 1];\n      eventNames = variants(fullName, false);\n\n      if (context && !context.component) {\n        context.component = ractive;\n      }\n    }\n\n    bubble = fireEventAs(ractive.parent, eventNames, context, args);\n  }\n\n  return bubble;\n}\n\nfunction notifySubscribers(ractive, subscribers, context, args) {\n  var originalEvent = null;\n  var stopEvent = false;\n\n  // subscribers can be modified inflight, e.g. \"once\" functionality\n  // so we need to copy to make sure everyone gets called\n  subscribers = subscribers.slice();\n\n  for (var i = 0, len = subscribers.length; i < len; i += 1) {\n    if (!subscribers[i].off && subscribers[i].handler.apply(ractive, args) === false) {\n      stopEvent = true;\n    }\n  }\n\n  if (context && stopEvent && (originalEvent = context.event)) {\n    originalEvent.preventDefault && originalEvent.preventDefault();\n    originalEvent.stopPropagation && originalEvent.stopPropagation();\n  }\n\n  return !stopEvent;\n}\n\nvar Hook = function Hook(event) {\n  this.event = event;\n  this.method = 'on' + event;\n};\n\nHook.prototype.fire = function fire (ractive, arg) {\n  var context = getRactiveContext(ractive);\n  var method = this.method;\n\n  if (ractive[method]) {\n    arg ? ractive[method](context, arg) : ractive[method](context);\n  }\n\n  fireEvent(ractive, this.event, context, arg ? [arg, ractive] : [ractive]);\n};\n\nfunction getChildQueue(queue, ractive) {\n  return queue[ractive._guid] || (queue[ractive._guid] = []);\n}\n\nfunction fire(hookQueue, ractive) {\n  var childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  hookQueue.hook.fire(ractive);\n\n  // queue is \"live\" because components can end up being\n  // added while hooks fire on parents that modify data values.\n  while (childQueue.length) {\n    fire(hookQueue, childQueue.shift());\n  }\n\n  delete hookQueue.queue[ractive._guid];\n}\n\nvar HookQueue = function HookQueue(event) {\n  this.hook = new Hook(event);\n  this.inProcess = {};\n  this.queue = {};\n};\nvar HookQueue__proto__ = HookQueue.prototype;\n\nHookQueue__proto__.begin = function begin (ractive) {\n  this.inProcess[ractive._guid] = true;\n};\n\nHookQueue__proto__.end = function end (ractive) {\n  var parent = ractive.parent;\n\n  // If this is *isn't* a child of a component that's in process,\n  // it should call methods or fire at this point\n  if (!parent || !this.inProcess[parent._guid]) {\n    fire(this, ractive);\n  } else {\n    // elsewise, handoff to parent to fire when ready\n    getChildQueue(this.queue, parent).push(ractive);\n  }\n\n  delete this.inProcess[ractive._guid];\n};\n\nvar hooks = {};\n[\n  'construct',\n  'config',\n  'attachchild',\n  'detach',\n  'detachchild',\n  'insert',\n  'complete',\n  'reset',\n  'render',\n  'unrendering',\n  'unrender',\n  'teardown',\n  'destruct',\n  'update'\n].forEach(function (hook) {\n  hooks[hook] = new Hook(hook);\n});\nhooks.init = new HookQueue('init');\n\nfunction findAnchors(fragment, name) {\n  if ( name === void 0 ) name = null;\n\n  var res = [];\n\n  findAnchorsIn(fragment, name, res);\n\n  return res;\n}\n\nfunction findAnchorsIn(item, name, result) {\n  if (item.isAnchor) {\n    if (!name || item.name === name) {\n      result.push(item);\n    }\n  } else if (item.items) {\n    item.items.forEach(function (i) { return findAnchorsIn(i, name, result); });\n  } else if (item.iterations) {\n    item.iterations.forEach(function (i) { return findAnchorsIn(i, name, result); });\n  } else if (item.fragment && !item.component) {\n    findAnchorsIn(item.fragment, name, result);\n  }\n}\n\nfunction updateAnchors(instance, name) {\n  if ( name === void 0 ) name = null;\n\n  var anchors = findAnchors(instance.fragment, name);\n  var idxs = {};\n  var children = instance._children.byName;\n\n  anchors.forEach(function (a) {\n    var name = a.name;\n    if (!(name in idxs)) { idxs[name] = 0; }\n    var idx = idxs[name];\n    var child = (children[name] || [])[idx];\n\n    if (child && child.lastBound !== a) {\n      if (child.lastBound) { child.lastBound.removeChild(child); }\n      a.addChild(child);\n    }\n\n    idxs[name]++;\n  });\n}\n\nfunction unrenderChild(meta) {\n  if (meta.instance.fragment.rendered) {\n    meta.shouldDestroy = true;\n    meta.instance.unrender();\n  }\n  meta.instance.el = null;\n}\n\nfunction attachChild(child, options) {\n  if ( options === void 0 ) options = {};\n\n  var children = this._children;\n  var idx;\n\n  if (child.parent && child.parent !== this)\n    { throw new Error(\n      (\"Instance \" + (child._guid) + \" is already attached to a different instance \" + (child.parent._guid) + \". Please detach it from the other instance using detachChild first.\")\n    ); }\n  else if (child.parent)\n    { throw new Error((\"Instance \" + (child._guid) + \" is already attached to this instance.\")); }\n\n  var meta = {\n    instance: child,\n    ractive: this,\n    name: options.name || child.constructor.name || 'Ractive',\n    target: options.target || false,\n    bubble: bubble,\n    findNextNode: findNextNode\n  };\n  meta.nameOption = options.name;\n\n  // child is managing itself\n  if (!meta.target) {\n    meta.up = this.fragment;\n    meta.external = true;\n  } else {\n    var list;\n    if (!(list = children.byName[meta.target])) {\n      list = [];\n      this.set((\"@this.children.byName.\" + (meta.target)), list);\n    }\n    idx = options.prepend ? 0 : options.insertAt !== undefined ? options.insertAt : list.length;\n  }\n\n  child.parent = this;\n  child.root = this.root;\n  child.component = meta;\n  children.push(meta);\n\n  var promise = runloop.start();\n\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).link(this.viewmodel.getRactiveModel());\n  rm.joinKey('root', { lastLink: false }).link(this.root.viewmodel.getRactiveModel());\n\n  hooks.attachchild.fire(child);\n\n  if (meta.target) {\n    unrenderChild(meta);\n    this.splice((\"@this.children.byName.\" + (meta.target)), idx, 0, meta);\n    updateAnchors(this, meta.target);\n  } else {\n    if (!child.isolated) { child.viewmodel.attached(this.fragment); }\n  }\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction bubble() {\n  runloop.addFragment(this.instance.fragment);\n}\n\nfunction findNextNode() {\n  if (this.anchor) { return this.anchor.findNextNode(); }\n}\n\nfunction compute(path, computed) {\n  this.computed[path] = computed;\n  if (isString(computed) || isFunction(computed))\n    { computed = this.computed[path] = { get: computed }; }\n\n  var keys = splitKeypath(path);\n  if (!~path.indexOf('*')) {\n    var last = keys.pop();\n    return this.viewmodel.joinAll(keys).compute(last, computed);\n  } else {\n    computed.pattern = new RegExp(\n      '^' +\n        keys\n          .map(function (k) { return k.replace(/\\*\\*/g, '(.+)').replace(/\\*/g, '((?:\\\\\\\\.|[^\\\\.])+)'); })\n          .join('\\\\.') +\n        '$'\n    );\n  }\n}\n\nfunction Ractive$compute(path, computed) {\n  var promise = runloop.start();\n  var comp = compute.call(this, path, computed);\n\n  if (comp) {\n    var keys = splitKeypath(path);\n    if (keys.length === 1 && !comp.isReadonly) {\n      comp.set(this.viewmodel.value[keys[0]]);\n    }\n\n    var first = keys.reduce(function (a, c) { return a && a.childByKey[c]; }, this.viewmodel);\n    if (first) {\n      first.rebind(comp, first, false);\n      if (first.parent) { delete first.parent.childByKey[first.key]; }\n      fireShuffleTasks();\n    }\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction Ractive$detach() {\n  if (this.isDetached) {\n    return this.el;\n  }\n\n  if (this.el) {\n    removeFromArray(this.el.__ractive_instances__, this);\n  }\n\n  this.el = this.fragment.detach();\n  this.isDetached = true;\n\n  hooks.detach.fire(this);\n  return this.el;\n}\n\nfunction detachChild(child) {\n  var children = this._children;\n  var meta, index;\n\n  var i = children.length;\n  while (i--) {\n    if (children[i].instance === child) {\n      index = i;\n      meta = children[i];\n      break;\n    }\n  }\n\n  if (!meta || child.parent !== this)\n    { throw new Error((\"Instance \" + (child._guid) + \" is not attached to this instance.\")); }\n\n  var promise = runloop.start();\n\n  if (meta.anchor) { meta.anchor.removeChild(meta); }\n  if (!child.isolated) { child.viewmodel.detached(); }\n\n  children.splice(index, 1);\n  if (meta.target) {\n    this.splice(\n      (\"@this.children.byName.\" + (meta.target)),\n      children.byName[meta.target].indexOf(meta),\n      1\n    );\n    updateAnchors(this, meta.target);\n  }\n  var rm = child.viewmodel.getRactiveModel();\n  rm.joinKey('parent', { lastLink: false }).unlink();\n  rm.joinKey('root', { lastLink: false }).link(rm);\n  child.root = child;\n  child.parent = null;\n  child.component = null;\n\n  hooks.detachchild.fire(child);\n\n  runloop.end();\n\n  promise.ractive = child;\n  return promise.then(function () { return child; });\n}\n\nfunction Ractive$find(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\")\n    ); }\n\n  var node = this.fragment.find(selector, options);\n  if (node) { return node; }\n\n  if (options.remote) {\n    for (var i = 0; i < this._children.length; i++) {\n      if (!this$1._children[i].instance.fragment.rendered) { continue; }\n      node = this$1._children[i].instance.find(selector, options);\n      if (node) { return node; }\n    }\n  }\n}\n\nfunction Ractive$findAll(selector, options) {\n  if ( options === void 0 ) options = {};\n\n  if (!this.rendered)\n    { throw new Error(\n      (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\")\n    ); }\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAll(selector, options);\n\n  if (options.remote) {\n    // seach non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        c.instance.findAll(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findAllComponents(selector, options) {\n  if (!options && isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  options = options || {};\n\n  if (!isArray(options.result)) { options.result = []; }\n\n  this.fragment.findAllComponents(selector, options);\n\n  if (options.remote) {\n    // search non-fragment children\n    this._children.forEach(function (c) {\n      if (!c.target && c.instance.fragment && c.instance.fragment.rendered) {\n        if (!selector || c.name === selector) {\n          options.result.push(c.instance);\n        }\n\n        c.instance.findAllComponents(selector, options);\n      }\n    });\n  }\n\n  return options.result;\n}\n\nfunction Ractive$findComponent(selector, options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  if (isObjectType(selector)) {\n    options = selector;\n    selector = '';\n  }\n\n  var child = this.fragment.findComponent(selector, options);\n  if (child) { return child; }\n\n  if (options.remote) {\n    if (!selector && this._children.length) { return this._children[0].instance; }\n    for (var i = 0; i < this._children.length; i++) {\n      // skip children that are or should be in an anchor\n      if (this$1._children[i].target) { continue; }\n      if (this$1._children[i].name === selector) { return this$1._children[i].instance; }\n      child = this$1._children[i].instance.findComponent(selector, options);\n      if (child) { return child; }\n    }\n  }\n}\n\nfunction Ractive$findContainer(selector) {\n  if (this.container) {\n    if (this.container.component && this.container.component.name === selector) {\n      return this.container;\n    } else {\n      return this.container.findContainer(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction Ractive$findParent(selector) {\n  if (this.parent) {\n    if (this.parent.component && this.parent.component.name === selector) {\n      return this.parent;\n    } else {\n      return this.parent.findParent(selector);\n    }\n  }\n\n  return null;\n}\n\nfunction findElement(start, orComponent, name) {\n  if ( orComponent === void 0 ) orComponent = true;\n\n  while (\n    start &&\n    (start.type !== ELEMENT || (name && start.name !== name)) &&\n    (!orComponent || (start.type !== COMPONENT && start.type !== ANCHOR))\n  ) {\n    // start is a fragment - look at the owner\n    if (start.owner) { start = start.owner; }\n    else if (start.component || start.yield)\n      // start is a component or yielder - look at the container\n      { start = start.containerFragment || start.component.up; }\n    else if (start.parent)\n      // start is an item - look at the parent\n      { start = start.parent; }\n    else if (start.up)\n      // start is an item without a parent - look at the parent fragment\n      { start = start.up; }\n    else { start = undefined; }\n  }\n\n  return start;\n}\n\n// This function takes an array, the name of a mutator method, and the\n// arguments to call that mutator method with, and returns an array that\n// maps the old indices to their new indices.\n\n// So if you had something like this...\n//\n//     array = [ 'a', 'b', 'c', 'd' ];\n//     array.push( 'e' );\n//\n// ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n// have changed. If you then did this...\n//\n//     array.unshift( 'z' );\n//\n// ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n// one higher to make room for the 'z'. If you removed an item, the new index\n// would be -1...\n//\n//     array.splice( 2, 2 );\n//\n// ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n//\n// This information is used to enable fast, non-destructive shuffling of list\n// sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\nfunction getNewIndices(length, methodName, args) {\n  var newIndices = [];\n\n  var spliceArguments = getSpliceEquivalent(length, methodName, args);\n\n  if (!spliceArguments) {\n    return null; // TODO support reverse and sort?\n  }\n\n  var balance = spliceArguments.length - 2 - spliceArguments[1];\n\n  var removeStart = Math.min(length, spliceArguments[0]);\n  var removeEnd = removeStart + spliceArguments[1];\n  newIndices.startIndex = removeStart;\n\n  var i;\n  for (i = 0; i < removeStart; i += 1) {\n    newIndices.push(i);\n  }\n\n  for (; i < removeEnd; i += 1) {\n    newIndices.push(-1);\n  }\n\n  for (; i < length; i += 1) {\n    newIndices.push(i + balance);\n  }\n\n  // there is a net shift for the rest of the array starting with index + balance\n  if (balance !== 0) {\n    newIndices.touchedFrom = spliceArguments[0];\n  } else {\n    newIndices.touchedFrom = length;\n  }\n\n  return newIndices;\n}\n\n// The pop, push, shift an unshift methods can all be represented\n// as an equivalent splice\nfunction getSpliceEquivalent(length, methodName, args) {\n  switch (methodName) {\n    case 'splice':\n      if (args[0] !== undefined && args[0] < 0) {\n        args[0] = length + Math.max(args[0], -length);\n      }\n\n      if (isUndefined(args[0])) { args[0] = 0; }\n\n      while (args.length < 2) {\n        args.push(length - args[0]);\n      }\n\n      if (!isNumber(args[1])) {\n        args[1] = length - args[0];\n      }\n\n      // ensure we only remove elements that exist\n      args[1] = Math.min(args[1], length - args[0]);\n\n      return args;\n\n    case 'sort':\n    case 'reverse':\n      return null;\n\n    case 'pop':\n      if (length) {\n        return [length - 1, 1];\n      }\n      return [0, 0];\n\n    case 'push':\n      return [length, 0].concat(args);\n\n    case 'shift':\n      return [0, length ? 1 : 0];\n\n    case 'unshift':\n      return [0, 0].concat(args);\n  }\n}\n\nvar arrayProto = Array.prototype;\n\nfunction makeArrayMethod(methodName) {\n  function path(keypath) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    return model(this.viewmodel.joinAll(splitKeypath(keypath)), args);\n  }\n\n  function model(mdl, args) {\n    var array = mdl.get();\n\n    if (!isArray(array)) {\n      if (isUndefined(array)) {\n        array = [];\n        var result$1 = arrayProto[methodName].apply(array, args);\n        var promise$1 = runloop.start().then(function () { return result$1; });\n        mdl.set(array);\n        runloop.end();\n        return promise$1;\n      } else {\n        throw new Error(\n          (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath()))\n        );\n      }\n    }\n\n    var newIndices = getNewIndices(array.length, methodName, args);\n    var result = arrayProto[methodName].apply(array, args);\n\n    var promise = runloop.start().then(function () { return result; });\n    promise.result = result;\n\n    if (newIndices) {\n      if (mdl.shuffle) {\n        mdl.shuffle(newIndices);\n      } else {\n        // it's a computation, which don't have a shuffle, so just invalidate\n        mdl.mark();\n      }\n    } else {\n      mdl.set(result);\n    }\n\n    runloop.end();\n\n    return promise;\n  }\n\n  return { path: path, model: model };\n}\n\nfunction update$1(ractive, model, options) {\n  // if the parent is wrapped, the adaptor will need to be updated before\n  // updating on this keypath\n  if (model.parent && model.parent.wrapper) {\n    model.parent.adapt();\n  }\n\n  var promise = runloop.start();\n\n  model.mark(options && options.force);\n\n  // notify upstream of changes\n  model.notifyUpstream();\n\n  runloop.end();\n\n  hooks.update.fire(ractive, model);\n\n  return promise;\n}\n\nfunction Ractive$update(keypath, options) {\n  var opts, path;\n\n  if (isString(keypath)) {\n    path = splitKeypath(keypath);\n    opts = options;\n  } else {\n    opts = keypath;\n  }\n\n  return update$1(this, path ? this.viewmodel.joinAll(path) : this.viewmodel, opts);\n}\n\nvar modelPush = makeArrayMethod('push').model;\nvar modelPop = makeArrayMethod('pop').model;\nvar modelShift = makeArrayMethod('shift').model;\nvar modelUnshift = makeArrayMethod('unshift').model;\nvar modelSort = makeArrayMethod('sort').model;\nvar modelSplice = makeArrayMethod('splice').model;\nvar modelReverse = makeArrayMethod('reverse').model;\n\nvar ContextData = (function (Model) {\n  function ContextData(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.value = {};\n    this.ractive = options.ractive;\n    this.adaptors = [];\n    this.context = options.context;\n  }\n\n  if ( Model ) ContextData.__proto__ = Model;\n  var ContextData__proto__ = ContextData.prototype = Object.create( Model && Model.prototype );\n  ContextData__proto__.constructor = ContextData;\n\n  ContextData__proto__.getKeypath = function getKeypath () {\n    return '@context.data';\n  };\n\n  ContextData__proto__.rebound = function rebound () {};\n\n  return ContextData;\n}(Model));\n\nvar Context = function Context(fragment, element) {\n  this.fragment = fragment;\n  this.element = element || findElement(fragment);\n  this.node = this.element && this.element.node;\n  this.ractive = fragment.ractive;\n  this.root = this;\n};\nvar Context__proto__ = Context.prototype;\n\nvar prototypeAccessors = { decorators: {},_data: {} };\n\nprototypeAccessors.decorators.get = function () {\n  var items = {};\n  if (!this.element) { return items; }\n  this.element.decorators.forEach(function (d) { return (items[d.name] = d.handle); });\n  return items;\n};\n\nprototypeAccessors._data.get = function () {\n  return (\n    this.model ||\n    (this.root.model = new ContextData({\n      ractive: this.ractive,\n      context: this.root\n    }))\n  );\n};\n\n// the usual mutation suspects\nContext__proto__.add = function add (keypath, d, options) {\n  var num = isNumber(d) ? +d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value + val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.animate = function animate$1 (keypath, value, options) {\n  var model = findModel(this, keypath).model;\n  return animate(this.ractive, model, value, options);\n};\n\nContext__proto__.find = function find (selector) {\n  return this.fragment.find(selector);\n};\n\nContext__proto__.findAll = function findAll (selector) {\n  var result = [];\n  this.fragment.findAll(selector, { result: result });\n  return result;\n};\n\nContext__proto__.findAllComponents = function findAllComponents (selector) {\n  var result = [];\n  this.fragment.findAllComponents(selector, { result: result });\n  return result;\n};\n\nContext__proto__.findComponent = function findComponent (selector) {\n  return this.fragment.findComponent(selector);\n};\n\n// get relative keypaths and values\nContext__proto__.get = function get (keypath) {\n  if (!keypath) { return this.fragment.findContext().get(true); }\n\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n\n  return model ? model.get(true) : undefined;\n};\n\nContext__proto__.getParent = function getParent (component) {\n  var fragment = this.fragment;\n\n  if (!fragment.parent && component) { fragment = fragment.componentParent; }\n  else {\n    if (fragment.context) { fragment = findParentWithContext(fragment.parent); }\n    else {\n      fragment = findParentWithContext(fragment.parent);\n      if (fragment) {\n        if (!fragment.parent && component) { fragment = fragment.componentParent; }\n        else { fragment = findParentWithContext(fragment.parent); }\n      }\n    }\n  }\n\n  if (!fragment || fragment === this.fragment) { return; }\n  else { return fragment.getContext(); }\n};\n\nContext__proto__.hasListener = function hasListener (name, bubble) {\n  // if the owner is a component, start there because the nearest element\n  // may exist outside of the immediate context (yield)\n  var el = this.fragment.owner.component\n    ? this.fragment.owner\n    : this.element || this.fragment.owner;\n  var base;\n\n  do {\n    base = el.component || el;\n    if (base.template.t === ELEMENT) {\n      if (findEvent(base, name)) { return true; }\n    }\n    el = el.up && el.up.owner;\n    if (el && el.component) { el = el.component; }\n  } while (el && bubble);\n};\n\nContext__proto__.link = function link (source, dest) {\n  var there = findModel(this, source).model;\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  here.link(there, source);\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.listen = function listen (event, handler) {\n  var el = this.element;\n  el.on(event, handler);\n  return {\n    cancel: function cancel() {\n      el.off(event, handler);\n    }\n  };\n};\n\nContext__proto__.observe = function observe (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observe(keypath, callback, options);\n};\n\nContext__proto__.observeOnce = function observeOnce (keypath, callback, options) {\n    if ( options === void 0 ) options = {};\n\n  if (isObject(keypath)) { options = callback || {}; }\n  options.fragment = this.fragment;\n  return this.ractive.observeOnce(keypath, callback, options);\n};\n\nContext__proto__.pop = function pop (keypath) {\n  return modelPop(findModel(this, keypath).model, []);\n};\n\nContext__proto__.push = function push (keypath) {\n    var values = [], len = arguments.length - 1;\n    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n  return modelPush(findModel(this, keypath).model, values);\n};\n\nContext__proto__.raise = function raise (name, event) {\n    var args = [], len = arguments.length - 2;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 2 ];\n\n  var el = this.element;\n  var ev;\n\n  while (el) {\n    if (el.component) { el = el.component; }\n    ev = findEvent(el, name);\n    if (ev) {\n      return ev.fire(\n        ev.element.getContext(\n          event || {},\n          event && !('original' in event) ? { original: {} } : {}\n        ),\n        args\n      );\n    }\n\n    el = el.up && el.up.owner;\n  }\n};\n\nContext__proto__.readLink = function readLink (keypath, options) {\n  return this.ractive.readLink(this.resolve(keypath), options);\n};\n\nContext__proto__.resolve = function resolve (path, ractive) {\n  var ref = findModel(this, path);\n    var model = ref.model;\n    var instance = ref.instance;\n  return model ? model.getKeypath(ractive || instance) : path;\n};\n\nContext__proto__.reverse = function reverse (keypath) {\n  return modelReverse(findModel(this, keypath).model, []);\n};\n\nContext__proto__.set = function set$2 (keypath, value, options) {\n  return set(build$1(this, keypath, value), options);\n};\n\nContext__proto__.shift = function shift (keypath) {\n  return modelShift(findModel(this, keypath).model, []);\n};\n\nContext__proto__.splice = function splice (keypath, index, drop) {\n    var add = [], len = arguments.length - 3;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\n  add.unshift(index, drop);\n  return modelSplice(findModel(this, keypath).model, add);\n};\n\nContext__proto__.sort = function sort (keypath) {\n  return modelSort(findModel(this, keypath).model, []);\n};\n\nContext__proto__.subtract = function subtract (keypath, d, options) {\n  var num = isNumber(d) ? d : 1;\n  var opts = isObjectType(d) ? d : options;\n  return set(\n    build$1(this, keypath, num).map(function (pair) {\n      var model = pair[0];\n        var val = pair[1];\n      var value = model.get();\n      if (!isNumeric(val) || !isNumeric(value)) { throw new Error('Cannot add non-numeric value'); }\n      return [model, value - val];\n    }),\n    opts\n  );\n};\n\nContext__proto__.toggle = function toggle (keypath, options) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  return set([[model, !model.get()]], options);\n};\n\nContext__proto__.unlink = function unlink (dest) {\n  var here = findModel(this, dest).model;\n  var promise = runloop.start();\n  if (here.owner && here.owner._link) { here.owner.unlink(); }\n  runloop.end();\n  return promise;\n};\n\nContext__proto__.unlisten = function unlisten (event, handler) {\n  this.element.off(event, handler);\n};\n\nContext__proto__.unshift = function unshift (keypath) {\n    var add = [], len = arguments.length - 1;\n    while ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\n  return modelUnshift(findModel(this, keypath).model, add);\n};\n\nContext__proto__.update = function update (keypath, options) {\n  return update$1(this.ractive, findModel(this, keypath).model, options);\n};\n\nContext__proto__.updateModel = function updateModel (keypath, cascade) {\n  var ref = findModel(this, keypath);\n    var model = ref.model;\n  var promise = runloop.start();\n  model.updateFromBindings(cascade);\n  runloop.end();\n  return promise;\n};\n\n// two-way binding related helpers\nContext__proto__.isBound = function isBound () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return !!model;\n};\n\nContext__proto__.getBindingPath = function getBindingPath (ractive) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n    var instance = ref.instance;\n  if (model) { return model.getKeypath(ractive || instance); }\n};\n\nContext__proto__.getBinding = function getBinding () {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  if (model) { return model.get(true); }\n};\n\nContext__proto__.getBindingModel = function getBindingModel (ctx) {\n  var el = ctx.element;\n  return { model: el.binding && el.binding.model, instance: el.up.ractive };\n};\n\nContext__proto__.setBinding = function setBinding (value) {\n  var ref = this.getBindingModel(this);\n    var model = ref.model;\n  return set([[model, value]]);\n};\n\nObject.defineProperties( Context__proto__, prototypeAccessors );\n\nContext.forRactive = getRactiveContext;\n// circular deps are fun\nextern.Context = Context;\n\n// TODO: at some point perhaps this could support relative * keypaths?\nfunction build$1(ctx, keypath, value) {\n  var sets = [];\n\n  // set multiple keypaths in one go\n  if (isObject(keypath)) {\n    for (var k in keypath) {\n      if (hasOwn(keypath, k)) {\n        sets.push([findModel(ctx, k).model, keypath[k]]);\n      }\n    }\n  } else {\n    // set a single keypath\n    sets.push([findModel(ctx, keypath).model, value]);\n  }\n\n  return sets;\n}\n\nfunction findModel(ctx, path) {\n  var frag = ctx.fragment;\n\n  if (!isString(path)) {\n    return { model: frag.findContext(), instance: path };\n  }\n\n  return { model: resolveReference(frag, path), instance: frag.ractive };\n}\n\nfunction findEvent(el, name) {\n  return el.events && el.events.find && el.events.find(function (e) { return ~e.template.n.indexOf(name); });\n}\n\nfunction Ractive$fire(eventName) {\n  var args = [], len = arguments.length - 1;\n  while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  var ctx;\n\n  // watch for reproxy\n  if (args[0] instanceof Context) {\n    var proto = args.shift();\n    ctx = create(proto);\n    assign(ctx, proto);\n  } else if (isObjectType(args[0]) && (args[0] === null || args[0].constructor === Object)) {\n    ctx = Context.forRactive(this, args.shift());\n  } else {\n    ctx = Context.forRactive(this);\n  }\n\n  return fireEvent(this, eventName, ctx, args);\n}\n\nfunction Ractive$get(keypath, opts) {\n  if (!isString(keypath)) { return this.viewmodel.get(true, keypath); }\n\n  var keys = splitKeypath(keypath);\n  var key = keys[0];\n\n  var model;\n\n  if (!this.viewmodel.has(key)) {\n    // if this is an inline component, we may need to create\n    // an implicit mapping\n    if (this.component && !this.isolated) {\n      model = resolveReference(this.fragment || new FakeFragment(this), key);\n    }\n  }\n\n  model = this.viewmodel.joinAll(keys);\n  return model.get(true, opts);\n}\n\nvar query = doc && doc.querySelector;\n\nfunction getContext$1(node) {\n  if (isString(node) && query) {\n    node = query.call(document, node);\n  }\n\n  var instances;\n  if (node) {\n    if (node._ractive) {\n      return node._ractive.proxy.getContext();\n    } else if ((instances = node.__ractive_instances__)) {\n      if (instances.length === 1) { return getRactiveContext(instances[0]); }\n    } else { return getContext$1(node.parentNode); }\n  }\n}\n\nfunction getContext$2(node, options) {\n  if (!node) { return getRactiveContext(this); }\n\n  if (isString(node)) {\n    node = this.find(node, options);\n  }\n\n  return getContext$1(node);\n}\n\nvar html = 'http://www.w3.org/1999/xhtml';\nvar mathml = 'http://www.w3.org/1998/Math/MathML';\nvar svg$1 = 'http://www.w3.org/2000/svg';\nvar xlink = 'http://www.w3.org/1999/xlink';\nvar xml = 'http://www.w3.org/XML/1998/namespace';\nvar xmlns = 'http://www.w3.org/2000/xmlns';\n\nvar namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\nvar createElement;\nvar matches;\nvar div;\nvar methodNames;\nvar unprefixed;\nvar prefixed;\nvar i;\nvar j;\nvar makeFunction;\n\n// Test for SVG support\nif (!svg) {\n  /* istanbul ignore next */\n  createElement = function (type, ns, extend) {\n    if (ns && ns !== html) {\n      throw \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://ractive.js.org/support/#svgs for more information\";\n    }\n\n    return extend ? doc.createElement(type, extend) : doc.createElement(type);\n  };\n} else {\n  createElement = function (type, ns, extend) {\n    if (!ns || ns === html) {\n      return extend ? doc.createElement(type, extend) : doc.createElement(type);\n    }\n\n    return extend ? doc.createElementNS(ns, type, extend) : doc.createElementNS(ns, type);\n  };\n}\n\nfunction createDocumentFragment() {\n  return doc.createDocumentFragment();\n}\n\nfunction getElement(input) {\n  var output;\n\n  if (!input || typeof input === 'boolean') {\n    return;\n  }\n\n  /* istanbul ignore next */\n  if (!win || !doc || !input) {\n    return null;\n  }\n\n  // We already have a DOM node - no work to do. (Duck typing alert!)\n  if (input.nodeType) {\n    return input;\n  }\n\n  // Get node from string\n  if (isString(input)) {\n    // try ID first\n    output = doc.getElementById(input);\n\n    // then as selector, if possible\n    if (!output && doc.querySelector) {\n      try {\n        output = doc.querySelector(input);\n      } catch (e) {\n        /* this space intentionally left blank */\n      }\n    }\n\n    // did it work?\n    if (output && output.nodeType) {\n      return output;\n    }\n  }\n\n  // If we've been given a collection (jQuery, Zepto etc), extract the first item\n  if (input[0] && input[0].nodeType) {\n    return input[0];\n  }\n\n  return null;\n}\n\nif (!isClient) {\n  matches = null;\n} else {\n  div = createElement('div');\n  methodNames = ['matches', 'matchesSelector'];\n\n  makeFunction = function(methodName) {\n    return function(node, selector) {\n      return node[methodName](selector);\n    };\n  };\n\n  i = methodNames.length;\n\n  while (i-- && !matches) {\n    unprefixed = methodNames[i];\n\n    if (div[unprefixed]) {\n      matches = makeFunction(unprefixed);\n    } else {\n      j = vendors.length;\n      while (j--) {\n        prefixed = vendors[i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n        if (div[prefixed]) {\n          matches = makeFunction(prefixed);\n          break;\n        }\n      }\n    }\n  }\n\n  // IE8... and apparently phantom some?\n  /* istanbul ignore next */\n  if (!matches) {\n    matches = function(node, selector) {\n      var parentNode, i;\n\n      parentNode = node.parentNode;\n\n      if (!parentNode) {\n        // empty dummy <div>\n        div.innerHTML = '';\n\n        parentNode = div;\n        node = node.cloneNode();\n\n        div.appendChild(node);\n      }\n\n      var nodes = parentNode.querySelectorAll(selector);\n\n      i = nodes.length;\n      while (i--) {\n        if (nodes[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n}\n\nfunction detachNode(node) {\n  // stupid ie\n  // eslint-disable-next-line valid-typeof\n  if (node && typeof node.parentNode !== 'unknown' && node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n\n  return node;\n}\n\nfunction safeToStringValue(value) {\n  return value == null || (isNumber(value) && isNaN(value)) || !value.toString ? '' : '' + value;\n}\n\nfunction safeAttributeString(string) {\n  return safeToStringValue(string)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction Ractive$insert(target, anchor) {\n  if (!this.fragment.rendered) {\n    // TODO create, and link to, documentation explaining this\n    throw new Error(\n      'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.'\n    );\n  }\n\n  target = getElement(target);\n  anchor = getElement(anchor) || null;\n\n  if (!target) {\n    throw new Error('You must specify a valid target to insert into');\n  }\n\n  target.insertBefore(this.detach(), anchor);\n  this.el = target;\n\n  (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  this.isDetached = false;\n\n  fireInsertHook(this);\n}\n\nfunction fireInsertHook(ractive) {\n  hooks.insert.fire(ractive);\n\n  ractive.findAllComponents('*').forEach(function (child) {\n    fireInsertHook(child.instance);\n  });\n}\n\nfunction link(there, here, options) {\n  var model;\n  var target = (options && (options.ractive || options.instance)) || this;\n\n  // may need to allow a mapping to resolve implicitly\n  var sourcePath = splitKeypath(there);\n  if (!target.viewmodel.has(sourcePath[0]) && target.component) {\n    model = resolveReference(target.component.up, sourcePath[0]);\n    model = model.joinAll(sourcePath.slice(1));\n  }\n\n  var src = model || target.viewmodel.joinAll(sourcePath);\n  var dest = this.viewmodel.joinAll(splitKeypath(here), { lastLink: false });\n\n  if (isUpstream(src, dest) || isUpstream(dest, src)) {\n    throw new Error('A keypath cannot be linked to itself.');\n  }\n\n  var promise = runloop.start();\n\n  dest.link(src, (options && options.keypath) || there);\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction isUpstream(check, start) {\n  var model = start;\n  while (model) {\n    if (model === check || model.owner === check) { return true; }\n    model = model.target || model.parent;\n  }\n}\n\nvar Observer = function Observer(ractive, model, callback, options) {\n  this.context = options.context || ractive;\n  this.callback = callback;\n  this.ractive = ractive;\n  this.keypath = options.keypath;\n  this.options = options;\n\n  if (model) { this.resolved(model); }\n\n  if (isFunction(options.old)) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  if (options.init !== false) {\n    this.dirty = true;\n    this.dispatch();\n  } else {\n    updateOld(this);\n  }\n\n  this.dirty = false;\n};\nvar Observer__proto__ = Observer.prototype;\n\nObserver__proto__.cancel = function cancel () {\n  this.cancelled = true;\n  if (this.model) {\n    this.model.unregister(this);\n  } else {\n    this.resolver.unbind();\n  }\n  removeFromArray(this.ractive._observers, this);\n};\n\nObserver__proto__.dispatch = function dispatch () {\n  if (!this.cancelled) {\n    this.callback.call(this.context, this.newValue, this.oldValue, this.keypath);\n    updateOld(this, true);\n    this.dirty = false;\n  }\n};\n\nObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty) {\n    var newValue = this.model.get();\n    if (isEqual(newValue, this.oldValue)) { return; }\n\n    this.newValue = newValue;\n\n    if (this.options.strict && this.newValue === this.oldValue) { return; }\n\n    runloop.addObserver(this, this.options.defer);\n    this.dirty = true;\n\n    if (this.options.once) { runloop.scheduleTask(function () { return this$1.cancel(); }); }\n  } else {\n    // make sure the newValue stays updated in case this observer gets touched multiple times in one loop\n    this.newValue = this.model.get();\n  }\n};\n\nObserver__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  next = rebindMatch(this.keypath, next, previous);\n  if (next === this.model) { return false; }\n\n  if (this.model) { this.model.unregister(this); }\n  if (next) { next.addShuffleTask(function () { return this$1.resolved(next); }); }\n};\n\nObserver__proto__.resolved = function resolved (model) {\n  this.model = model;\n\n  this.oldValue = undefined;\n  this.newValue = model.get();\n\n  model.register(this);\n};\n\nfunction updateOld(observer, fresh) {\n  var next = fresh\n    ? observer.model\n      ? observer.model.get()\n      : observer.newValue\n    : observer.newValue;\n  observer.oldValue = observer.oldFn\n    ? observer.oldFn.call(observer.oldContext, undefined, next, observer.keypath)\n    : next;\n}\n\nvar star$1 = /\\*+/g;\n\nvar PatternObserver = function PatternObserver(ractive, baseModel, keys$$1, callback, options) {\n  var this$1 = this;\n\n  this.context = options.context || ractive;\n  this.ractive = ractive;\n  this.baseModel = baseModel;\n  this.keys = keys$$1;\n  this.callback = callback;\n\n  var pattern = keys$$1.join('\\\\.').replace(star$1, '(.+)');\n  var baseKeypath = (this.baseKeypath = baseModel.getKeypath(ractive));\n  this.pattern = new RegExp((\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + pattern + \"$\"));\n  this.recursive = keys$$1.length === 1 && keys$$1[0] === '**';\n  if (this.recursive) { this.keys = ['*']; }\n  if (options.old) {\n    this.oldContext = create(ractive);\n    this.oldFn = options.old;\n  }\n\n  this.oldValues = {};\n  this.newValues = {};\n\n  this.defer = options.defer;\n  this.once = options.once;\n  this.strict = options.strict;\n\n  this.dirty = false;\n  this.changed = [];\n  this.partial = false;\n  this.links = options.links;\n\n  var models = baseModel.findMatches(this.keys);\n\n  models.forEach(function (model) {\n    this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n  });\n\n  if (options.init !== false) {\n    this.dispatch();\n  } else {\n    updateOld$1(this, this.newValues);\n  }\n\n  baseModel.registerPatternObserver(this);\n};\nvar PatternObserver__proto__ = PatternObserver.prototype;\n\nPatternObserver__proto__.cancel = function cancel () {\n  this.baseModel.unregisterPatternObserver(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nPatternObserver__proto__.dispatch = function dispatch () {\n    var this$1 = this;\n\n  var newValues = this.newValues;\n  this.newValues = {};\n  keys(newValues).forEach(function (keypath) {\n    var newValue = newValues[keypath];\n    var oldValue = this$1.oldValues[keypath];\n\n    if (this$1.strict && newValue === oldValue) { return; }\n    if (isEqual(newValue, oldValue)) { return; }\n\n    var args = [newValue, oldValue, keypath];\n    if (keypath) {\n      var wildcards = this$1.pattern.exec(keypath);\n      if (wildcards) {\n        args = args.concat(wildcards.slice(1));\n      }\n    }\n\n    this$1.callback.apply(this$1.context, args);\n  });\n\n  updateOld$1(this, newValues, this.partial);\n\n  this.dirty = false;\n};\n\nPatternObserver__proto__.notify = function notify (key) {\n  this.changed.push(key);\n};\n\nPatternObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  if (!isArray(this.baseModel.value)) { return; }\n\n  var max = this.baseModel.value.length;\n\n  for (var i = 0; i < newIndices.length; i++) {\n    if (newIndices[i] === -1 || newIndices[i] === i) { continue; }\n    this$1.changed.push([i]);\n  }\n\n  for (var i$1 = newIndices.touchedFrom; i$1 < max; i$1++) {\n    this$1.changed.push([i$1]);\n  }\n};\n\nPatternObserver__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  if (!this.dirty || this.changed.length) {\n    if (!this.dirty) { this.newValues = {}; }\n\n    if (!this.changed.length) {\n      this.baseModel.findMatches(this.keys).forEach(function (model) {\n        var keypath = model.getKeypath(this$1.ractive);\n        this$1.newValues[keypath] = model.get();\n      });\n      this.partial = false;\n    } else {\n      var count = 0;\n\n      if (this.recursive) {\n        this.changed.forEach(function (keys$$1) {\n          var model = this$1.baseModel.joinAll(keys$$1);\n          if (model.isLink && !this$1.links) { return; }\n          count++;\n          this$1.newValues[model.getKeypath(this$1.ractive)] = model.get();\n        });\n      } else {\n        var ok = this.baseModel.isRoot\n          ? this.changed.map(function (keys$$1) { return keys$$1.map(escapeKey).join('.'); })\n          : this.changed.map(function (keys$$1) { return this$1.baseKeypath + '.' + keys$$1.map(escapeKey).join('.'); });\n\n        this.baseModel.findMatches(this.keys).forEach(function (model) {\n          var keypath = model.getKeypath(this$1.ractive);\n          var check = function (k) {\n            return (\n              (k.indexOf(keypath) === 0 &&\n                (k.length === keypath.length || k[keypath.length] === '.')) ||\n              (keypath.indexOf(k) === 0 &&\n                (k.length === keypath.length || keypath[k.length] === '.'))\n            );\n          };\n\n          // is this model on a changed keypath?\n          if (ok.filter(check).length) {\n            count++;\n            this$1.newValues[keypath] = model.get();\n          }\n        });\n      }\n\n      // no valid change triggered, so bail to avoid breakage\n      if (!count) { return; }\n\n      this.partial = true;\n    }\n\n    runloop.addObserver(this, this.defer);\n    this.dirty = true;\n    this.changed.length = 0;\n\n    if (this.once) { this.cancel(); }\n  }\n};\n\nfunction updateOld$1(observer, vals, partial) {\n  var olds = observer.oldValues;\n\n  if (observer.oldFn) {\n    if (!partial) { observer.oldValues = {}; }\n\n    keys(vals).forEach(function (k) {\n      var args = [olds[k], vals[k], k];\n      var parts = observer.pattern.exec(k);\n      if (parts) {\n        args.push.apply(args, parts.slice(1));\n      }\n      observer.oldValues[k] = observer.oldFn.apply(observer.oldContext, args);\n    });\n  } else {\n    if (partial) {\n      keys(vals).forEach(function (k) { return (olds[k] = vals[k]); });\n    } else {\n      observer.oldValues = vals;\n    }\n  }\n}\n\nfunction negativeOne() {\n  return -1;\n}\n\nvar ArrayObserver = function ArrayObserver(ractive, model, callback, options) {\n  this.ractive = ractive;\n  this.model = model;\n  this.keypath = model.getKeypath();\n  this.callback = callback;\n  this.options = options;\n\n  this.pending = null;\n\n  model.register(this);\n\n  if (options.init !== false) {\n    this.sliced = [];\n    this.shuffle([]);\n    this.dispatch();\n  } else {\n    this.sliced = this.slice();\n  }\n};\nvar ArrayObserver__proto__ = ArrayObserver.prototype;\n\nArrayObserver__proto__.cancel = function cancel () {\n  this.model.unregister(this);\n  removeFromArray(this.ractive._observers, this);\n};\n\nArrayObserver__proto__.dispatch = function dispatch () {\n  this.callback(this.pending);\n  this.pending = null;\n  if (this.options.once) { this.cancel(); }\n};\n\nArrayObserver__proto__.handleChange = function handleChange (path) {\n  if (this.pending) {\n    // post-shuffle\n    runloop.addObserver(this, this.options.defer);\n  } else if (!path) {\n    // entire array changed\n    this.shuffle(this.sliced.map(negativeOne));\n    this.handleChange();\n  }\n};\n\nArrayObserver__proto__.shuffle = function shuffle (newIndices) {\n    var this$1 = this;\n\n  var newValue = this.slice();\n\n  var inserted = [];\n  var deleted = [];\n  var start;\n\n  var hadIndex = {};\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    hadIndex[newIndex] = true;\n\n    if (newIndex !== oldIndex && isUndefined(start)) {\n      start = oldIndex;\n    }\n\n    if (newIndex === -1) {\n      deleted.push(this$1.sliced[oldIndex]);\n    }\n  });\n\n  if (isUndefined(start)) { start = newIndices.length; }\n\n  var len = newValue.length;\n  for (var i = 0; i < len; i += 1) {\n    if (!hadIndex[i]) { inserted.push(newValue[i]); }\n  }\n\n  this.pending = { inserted: inserted, deleted: deleted, start: start };\n  this.sliced = newValue;\n};\n\nArrayObserver__proto__.slice = function slice () {\n  var value = this.model.get();\n  return isArray(value) ? value.slice() : [];\n};\n\nfunction observe(keypath, callback, options) {\n  var this$1 = this;\n\n  var observers = [];\n  var map;\n  var opts;\n\n  if (isObject(keypath)) {\n    map = keypath;\n    opts = callback || {};\n  } else {\n    if (isFunction(keypath)) {\n      map = { '': keypath };\n      opts = callback || {};\n    } else {\n      map = {};\n      map[keypath] = callback;\n      opts = options || {};\n    }\n  }\n\n  var silent = false;\n  keys(map).forEach(function (keypath) {\n    var callback = map[keypath];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (silent) { return; }\n      return callback.apply(this, args);\n    };\n\n    var keypaths = keypath.split(' ');\n    if (keypaths.length > 1) { keypaths = keypaths.filter(function (k) { return k; }); }\n\n    keypaths.forEach(function (keypath) {\n      opts.keypath = keypath;\n      var observer = createObserver(this$1, keypath, caller, opts);\n      if (observer) { observers.push(observer); }\n    });\n  });\n\n  // add observers to the Ractive instance, so they can be\n  // cancelled on ractive.teardown()\n  this._observers.push.apply(this._observers, observers);\n\n  return {\n    cancel: function () { return observers.forEach(function (o) { return o.cancel(); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction createObserver(ractive, keypath, callback, options) {\n  var keys$$1 = splitKeypath(keypath);\n  var wildcardIndex = keys$$1.indexOf('*');\n  if (!~wildcardIndex) { wildcardIndex = keys$$1.indexOf('**'); }\n\n  options.fragment = options.fragment || ractive.fragment;\n\n  var model;\n  if (!options.fragment) {\n    model = ractive.viewmodel.joinKey(keys$$1[0]);\n  } else {\n    // .*.whatever relative wildcard is a special case because splitkeypath doesn't handle the leading .\n    if (~keys$$1[0].indexOf('.*')) {\n      model = options.fragment.findContext();\n      wildcardIndex = 0;\n      keys$$1[0] = keys$$1[0].slice(1);\n    } else {\n      model =\n        wildcardIndex === 0\n          ? options.fragment.findContext()\n          : resolveReference(options.fragment, keys$$1[0]);\n    }\n  }\n\n  // the model may not exist key\n  if (!model) { model = ractive.viewmodel.joinKey(keys$$1[0]); }\n\n  if (!~wildcardIndex) {\n    model = model.joinAll(keys$$1.slice(1));\n    if (options.array) {\n      return new ArrayObserver(ractive, model, callback, options);\n    } else {\n      return new Observer(ractive, model, callback, options);\n    }\n  } else {\n    var double = keys$$1.indexOf('**');\n    if (~double) {\n      if (double + 1 !== keys$$1.length || ~keys$$1.indexOf('*')) {\n        warnOnceIfDebug(\n          \"Recursive observers may only specify a single '**' at the end of the path.\"\n        );\n        return;\n      }\n    }\n\n    model = model.joinAll(keys$$1.slice(1, wildcardIndex));\n\n    return new PatternObserver(ractive, model, keys$$1.slice(wildcardIndex), callback, options);\n  }\n}\n\nvar onceOptions = { init: false, once: true };\n\nfunction observeOnce(keypath, callback, options) {\n  if (isObject(keypath) || isFunction(keypath)) {\n    options = assign(callback || {}, onceOptions);\n    return this.observe(keypath, options);\n  }\n\n  options = assign(options || {}, onceOptions);\n  return this.observe(keypath, callback, options);\n}\n\nvar trim = function (str) { return str.trim(); };\n\nvar notEmptyString = function (str) { return str !== ''; };\n\nfunction Ractive$off(eventName, callback) {\n  var this$1 = this;\n\n  // if no event is specified, remove _all_ event listeners\n  if (!eventName) {\n    this._subs = {};\n  } else {\n    // Handle multiple space-separated event names\n    var eventNames = eventName\n      .split(' ')\n      .map(trim)\n      .filter(notEmptyString);\n\n    eventNames.forEach(function (event) {\n      var subs = this$1._subs[event];\n      // if given a specific callback to remove, remove only it\n      if (subs && callback) {\n        var entry = subs.find(function (s) { return s.callback === callback; });\n        if (entry) {\n          removeFromArray(subs, entry);\n          entry.off = true;\n\n          if (event.indexOf('.')) { this$1._nsSubs--; }\n        }\n      } else if (subs) {\n        // otherwise, remove all listeners for this event\n        if (event.indexOf('.')) { this$1._nsSubs -= subs.length; }\n        subs.length = 0;\n      }\n    });\n  }\n\n  return this;\n}\n\nfunction Ractive$on(eventName, callback) {\n  var this$1 = this;\n\n  // eventName may already be a map\n  var map = isObjectType(eventName) ? eventName : {};\n  // or it may be a string along with a callback\n  if (isString(eventName)) { map[eventName] = callback; }\n\n  var silent = false;\n  var events = [];\n\n  var loop = function ( k ) {\n    var callback$1 = map[k];\n    var caller = function() {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      if (!silent) { return callback$1.apply(this, args); }\n    };\n    var entry = {\n      callback: callback$1,\n      handler: caller\n    };\n\n    if (hasOwn(map, k)) {\n      var names = k\n        .split(' ')\n        .map(trim)\n        .filter(notEmptyString);\n      names.forEach(function (n) {\n        (this$1._subs[n] || (this$1._subs[n] = [])).push(entry);\n        if (n.indexOf('.')) { this$1._nsSubs++; }\n        events.push([n, entry]);\n      });\n    }\n  };\n\n  for (var k in map) loop( k );\n\n  return {\n    cancel: function () { return events.forEach(function (e) { return this$1.off(e[0], e[1].callback); }); },\n    isSilenced: function () { return silent; },\n    silence: function () { return (silent = true); },\n    resume: function () { return (silent = false); }\n  };\n}\n\nfunction Ractive$once(eventName, handler) {\n  var listener = this.on(eventName, function() {\n    handler.apply(this, arguments);\n    listener.cancel();\n  });\n\n  // so we can still do listener.cancel() manually\n  return listener;\n}\n\nvar pop = makeArrayMethod('pop').path;\n\nvar push = makeArrayMethod('push').path;\n\nfunction readLink(keypath, options) {\n  if ( options === void 0 ) options = {};\n\n  var path = splitKeypath(keypath);\n\n  if (this.viewmodel.has(path[0])) {\n    var model = this.viewmodel.joinAll(path);\n\n    if (!model.isLink) { return; }\n\n    while ((model = model.target) && options.canonical !== false) {\n      if (!model.isLink) { break; }\n    }\n\n    if (model) { return { ractive: model.root.ractive, keypath: model.getKeypath() }; }\n  }\n}\n\nvar PREFIX = '/* Ractive.js component styles */';\n\n// Holds current definitions of styles.\nvar styleDefinitions = [];\n\n// Flag to tell if we need to update the CSS\nvar isDirty = false;\n\n// These only make sense on the browser. See additional setup below.\nvar styleElement = null;\nvar useCssText = null;\n\nfunction addCSS(styleDefinition) {\n  styleDefinitions.push(styleDefinition);\n  isDirty = true;\n}\n\nfunction applyCSS(force) {\n  var styleElement = style();\n\n  // Apply only seems to make sense when we're in the DOM. Server-side renders\n  // can call toCSS to get the updated CSS.\n  if (!styleElement || (!force && !isDirty)) { return; }\n\n  if (useCssText) {\n    styleElement.styleSheet.cssText = getCSS(null);\n  } else {\n    styleElement.innerHTML = getCSS(null);\n  }\n\n  isDirty = false;\n}\n\nfunction getCSS(cssIds) {\n  var filteredStyleDefinitions = cssIds\n    ? styleDefinitions.filter(function (style) { return ~cssIds.indexOf(style.id); })\n    : styleDefinitions;\n\n  filteredStyleDefinitions.forEach(function (d) { return (d.applied = true); });\n\n  return filteredStyleDefinitions.reduce(\n    function (styles, style) { return (\"\" + (styles ? (styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)) : '')); },\n    PREFIX\n  );\n}\n\nfunction style() {\n  // If we're on the browser, additional setup needed.\n  if (doc && !styleElement) {\n    styleElement = doc.createElement('style');\n    styleElement.type = 'text/css';\n    styleElement.setAttribute('data-ractive-css', '');\n\n    doc.getElementsByTagName('head')[0].appendChild(styleElement);\n\n    useCssText = !!styleElement.styleSheet;\n  }\n\n  return styleElement;\n}\n\nvar adaptConfigurator = {\n  extend: function (Parent, proto, options) {\n    proto.adapt = combine(proto.adapt, ensureArray(options.adapt));\n  },\n\n  init: function init() {}\n};\n\nvar remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\nvar escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\2).)*\\2/gi;\nvar value = /\\0(\\d+)/g;\n\n// Removes comments and strings from the given CSS to make it easier to parse.\n// Callback receives the cleaned CSS and a function which can be used to put\n// the removed strings back in place after parsing is done.\nfunction cleanCss(css, callback, additionalReplaceRules) {\n  if ( additionalReplaceRules === void 0 ) additionalReplaceRules = [];\n\n  var values = [];\n  var reconstruct = function (css) { return css.replace(value, function (match, n) { return values[n]; }); };\n  css = css.replace(escape, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); }).replace(remove, '');\n\n  additionalReplaceRules.forEach(function (pattern) {\n    css = css.replace(pattern, function (match) { return (\"\\u0000\" + (values.push(match) - 1)); });\n  });\n\n  return callback(css, reconstruct);\n}\n\nvar selectorsPattern = /(?:^|\\}|\\{|\\x01)\\s*([^\\{\\}\\0\\x01]+)\\s*(?=\\{)/g;\nvar importPattern = /@import\\s*\\([^)]*\\)\\s*;?/gi;\nvar importEndPattern = /\\x01/g;\nvar keyframesDeclarationPattern = /@keyframes\\s+[^\\{\\}]+\\s*\\{(?:[^{}]+|\\{[^{}]+})*}/gi;\nvar selectorUnitPattern = /((?:(?:\\[[^\\]]+\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\nvar excludePattern = /^(?:@|\\d+%)/;\nvar dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\nfunction trim$1(str) {\n  return str.trim();\n}\n\nfunction extractString(unit) {\n  return unit.str;\n}\n\nfunction transformSelector(selector, parent) {\n  var selectorUnits = [];\n  var match;\n\n  while ((match = selectorUnitPattern.exec(selector))) {\n    selectorUnits.push({\n      str: match[0],\n      base: match[1],\n      modifiers: match[2]\n    });\n  }\n\n  // For each simple selector within the selector, we need to create a version\n  // that a) combines with the id, and b) is inside the id\n  var base = selectorUnits.map(extractString);\n\n  var transformed = [];\n  var i = selectorUnits.length;\n\n  while (i--) {\n    var appended = base.slice();\n\n    // Pseudo-selectors should go after the attribute selector\n    var unit = selectorUnits[i];\n    appended[i] = unit.base + parent + unit.modifiers || '';\n\n    var prepended = base.slice();\n    prepended[i] = parent + ' ' + prepended[i];\n\n    transformed.push(appended.join(' '), prepended.join(' '));\n  }\n\n  return transformed.join(', ');\n}\n\nfunction transformCss(css, id) {\n  var dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  var transformed;\n\n  if (dataRvcGuidPattern.test(css)) {\n    transformed = css.replace(dataRvcGuidPattern, dataAttr);\n  } else {\n    transformed = cleanCss(\n      css,\n      function (css, reconstruct) {\n        css = css\n          .replace(importPattern, '$&\\x01')\n          .replace(selectorsPattern, function (match, $1) {\n            // don't transform at-rules and keyframe declarations\n            if (excludePattern.test($1)) { return match; }\n\n            var selectors = $1.split(',').map(trim$1);\n            var transformed =\n              selectors.map(function (selector) { return transformSelector(selector, dataAttr); }).join(', ') + ' ';\n\n            return match.replace($1, transformed);\n          })\n          .replace(importEndPattern, '');\n\n        return reconstruct(css);\n      },\n      [keyframesDeclarationPattern]\n    );\n  }\n\n  return transformed;\n}\n\nfunction s4() {\n  return Math.floor((1 + Math.random()) * 0x10000)\n    .toString(16)\n    .substring(1);\n}\n\nfunction uuid() {\n  return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n\nfunction setCSSData(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = this._cssModel;\n\n  model.locked = true;\n  var promise = set(build({ viewmodel: model }, keypath, value, true), opts);\n  model.locked = false;\n\n  var cascade = runloop.start();\n  this.extensions.forEach(function (e) {\n    var model = e._cssModel;\n    model.mark();\n    model.downstreamChanged('', 1);\n  });\n  runloop.end();\n\n  applyChanges(this, !opts || opts.apply !== false);\n\n  return promise.then(function () { return cascade; });\n}\n\nfunction applyChanges(component, apply) {\n  var local = recomputeCSS(component);\n  var child = component.extensions\n    .map(function (e) { return applyChanges(e, false); })\n    .reduce(function (a, c) { return c || a; }, false);\n\n  if (apply && (local || child)) {\n    var def = component._cssDef;\n    if (!def || (def && def.applied)) { applyCSS(true); }\n  }\n\n  return local || child;\n}\n\nfunction recomputeCSS(component) {\n  var css = component.css;\n\n  if (!isFunction(css)) { return; }\n\n  var def = component._cssDef;\n  var result = evalCSS(component, css);\n  var styles = def.transform ? transformCss(result, def.id) : result;\n\n  if (def.styles === styles) { return; }\n\n  def.styles = styles;\n\n  return true;\n}\n\nvar CSSModel = (function (SharedModel) {\n  function CSSModel(component) {\n    SharedModel.call(this, component.cssData, '@style');\n    this.component = component;\n  }\n\n  if ( SharedModel ) CSSModel.__proto__ = SharedModel;\n  var CSSModel__proto__ = CSSModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  CSSModel__proto__.constructor = CSSModel;\n\n  CSSModel__proto__.downstreamChanged = function downstreamChanged (path, depth) {\n    if (this.locked) { return; }\n\n    var component = this.component;\n\n    component.extensions.forEach(function (e) {\n      var model = e._cssModel;\n      model.mark();\n      model.downstreamChanged(path, depth || 1);\n    });\n\n    if (!depth) {\n      applyChanges(component, true);\n    }\n  };\n\n  return CSSModel;\n}(SharedModel));\n\nvar hasCurly = /\\{/;\nvar cssConfigurator = {\n  name: 'css',\n\n  // Called when creating a new component definition\n  extend: function (Parent, proto, options, Child) {\n    Child._cssIds = gatherIds(Parent);\n\n    defineProperty(Child, 'cssData', {\n      configurable: true,\n      value: assign(create(Parent.cssData), options.cssData || {})\n    });\n\n    defineProperty(Child, '_cssModel', {\n      configurable: true,\n      value: new CSSModel(Child)\n    });\n\n    if (options.css) { initCSS(options, Child, proto); }\n  },\n\n  // Called when creating a new component instance\n  init: function (Parent, target, options) {\n    if (!options.css) { return; }\n\n    warnIfDebug(\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\");\n  }\n};\n\nfunction gatherIds(start) {\n  var cmp = start;\n  var ids = [];\n\n  while (cmp) {\n    if (cmp.prototype.cssId) { ids.push(cmp.prototype.cssId); }\n    cmp = cmp.Parent;\n  }\n\n  return ids;\n}\n\nfunction evalCSS(component, css) {\n  if (isString(css)) { return css; }\n\n  var cssData = component.cssData;\n  var model = component._cssModel;\n  var data = function data(path) {\n    return model.joinAll(splitKeypath(path)).get();\n  };\n  data.__proto__ = cssData;\n\n  var result = css.call(component, data);\n  return isString(result) ? result : '';\n}\n\nfunction initCSS(options, target, proto) {\n  var css =\n    options.css === true\n      ? ''\n      : isString(options.css) && !hasCurly.test(options.css)\n      ? getElement(options.css) || options.css\n      : options.css;\n  var cssProp = css;\n\n  var id = options.cssId || uuid();\n\n  if (isObjectType(css)) {\n    css = 'textContent' in css ? css.textContent : css.innerHTML;\n    cssProp = css;\n  } else if (isFunction(css)) {\n    cssProp = css;\n    css = evalCSS(target, css);\n  }\n\n  var def = {\n    transform: 'noCSSTransform' in options ? !options.noCSSTransform : !options.noCssTransform\n  };\n\n  defineProperty(target, '_cssDef', { configurable: true, value: def });\n\n  defineProperty(target, 'css', {\n    get: function get() {\n      return cssProp;\n    },\n    set: function set(next) {\n      cssProp = next;\n      var css = evalCSS(target, cssProp);\n      var styles = def.styles;\n      def.styles = def.transform ? transformCss(css, id) : css;\n      if (def.applied && styles !== def.styles) { applyCSS(true); }\n    }\n  });\n\n  def.styles = def.transform ? transformCss(css, id) : css;\n  def.id = proto.cssId = id;\n  target._cssIds.push(id);\n\n  addCSS(target._cssDef);\n}\n\nfunction validate(data) {\n  // Warn if userOptions.data is a non-POJO\n  if (data && data.constructor !== Object) {\n    if (isFunction(data)) {\n      // TODO do we need to support this in the new Ractive() case?\n    } else if (!isObjectType(data)) {\n      fatal((\"data option must be an object or a function, `\" + data + \"` is not valid\"));\n    } else {\n      warnIfDebug(\n        'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged'\n      );\n    }\n  }\n}\n\nvar dataConfigurator = {\n  name: 'data',\n\n  extend: function (Parent, proto, options) {\n    var key;\n    var value;\n\n    // check for non-primitives, which could cause mutation-related bugs\n    if (options.data && isObject(options.data)) {\n      for (key in options.data) {\n        value = options.data[key];\n\n        if (value && isObjectType(value)) {\n          if (isObject(value) || isArray(value)) {\n            warnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n          }\n        }\n      }\n    }\n\n    proto.data = combine$1(proto.data, options.data);\n  },\n\n  init: function (Parent, ractive, options) {\n    var result = combine$1(Parent.prototype.data, options.data);\n\n    if (isFunction(result)) { result = result.call(ractive); }\n\n    // bind functions to the ractive instance at the top level,\n    // unless it's a non-POJO (in which case alarm bells should ring)\n    if (result && result.constructor === Object) {\n      for (var prop in result) {\n        if (isFunction(result[prop])) {\n          var value = result[prop];\n          result[prop] = bind(value, ractive);\n          result[prop]._r_unbound = value;\n        }\n      }\n    }\n\n    return result || {};\n  },\n\n  reset: function reset(ractive) {\n    var result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n    ractive.viewmodel.root.set(result);\n    return true;\n  }\n};\n\nfunction emptyData() {\n  return {};\n}\n\nfunction combine$1(parentValue, childValue) {\n  validate(childValue);\n\n  var parentIsFn = isFunction(parentValue);\n\n  // Very important, otherwise child instance can become\n  // the default data object on Ractive or a component.\n  // then ractive.set() ends up setting on the prototype!\n  if (!childValue && !parentIsFn) {\n    // this needs to be a function so that it can still inherit parent defaults\n    childValue = emptyData;\n  }\n\n  var childIsFn = isFunction(childValue);\n\n  // Fast path, where we just need to copy properties from\n  // parent to child\n  if (!parentIsFn && !childIsFn) {\n    return fromProperties(childValue, parentValue);\n  }\n\n  return function() {\n    var child = childIsFn ? callDataFunction(childValue, this) : childValue;\n    var parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n    return fromProperties(child, parent);\n  };\n}\n\nfunction callDataFunction(fn, context) {\n  var data = fn.call(context);\n\n  if (!data) { return; }\n\n  if (!isObjectType(data)) {\n    fatal('Data function must return an object');\n  }\n\n  if (data.constructor !== Object) {\n    warnOnceIfDebug(\n      'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged'\n    );\n  }\n\n  return data;\n}\n\nfunction fromProperties(primary, secondary) {\n  if (primary && secondary) {\n    for (var key in secondary) {\n      if (!(key in primary)) {\n        primary[key] = secondary[key];\n      }\n    }\n\n    return primary;\n  }\n\n  return primary || secondary;\n}\n\nvar templateConfigurator = {\n  name: 'template',\n\n  extend: function extend(Parent, proto, options) {\n    // only assign if exists\n    if ('template' in options) {\n      var template = options.template;\n\n      if (isFunction(template)) {\n        proto.template = template;\n      } else {\n        proto.template = parseTemplate(template, proto);\n      }\n    }\n  },\n\n  init: function init(Parent, ractive, options) {\n    // TODO because of prototypal inheritance, we might just be able to use\n    // ractive.template, and not bother passing through the Parent object.\n    // At present that breaks the test mocks' expectations\n    var template = 'template' in options ? options.template : Parent.prototype.template;\n    template = template || { v: TEMPLATE_VERSION, t: [] };\n\n    if (isFunction(template)) {\n      var fn = template;\n      template = getDynamicTemplate(ractive, fn);\n\n      ractive._config.template = {\n        fn: fn,\n        result: template\n      };\n    }\n\n    template = parseTemplate(template, ractive);\n\n    // TODO the naming of this is confusing - ractive.template refers to [...],\n    // but Component.prototype.template refers to {v:1,t:[],p:[]}...\n    // it's unnecessary, because the developer never needs to access\n    // ractive.template\n    ractive.template = template.t;\n\n    if (template.p) {\n      extendPartials(ractive.partials, template.p);\n    }\n  },\n\n  reset: function reset(ractive) {\n    var result = resetValue(ractive);\n\n    if (result) {\n      var parsed = parseTemplate(result, ractive);\n\n      ractive.template = parsed.t;\n      extendPartials(ractive.partials, parsed.p, true);\n\n      return true;\n    }\n  }\n};\n\nfunction resetValue(ractive) {\n  var initial = ractive._config.template;\n\n  // If this isn't a dynamic template, there's nothing to do\n  if (!initial || !initial.fn) {\n    return;\n  }\n\n  var result = getDynamicTemplate(ractive, initial.fn);\n\n  // TODO deep equality check to prevent unnecessary re-rendering\n  // in the case of already-parsed templates\n  if (result !== initial.result) {\n    initial.result = result;\n    return result;\n  }\n}\n\nfunction getDynamicTemplate(ractive, fn) {\n  return fn.call(ractive, {\n    fromId: parser.fromId,\n    isParsed: parser.isParsed,\n    parse: function parse(template, options) {\n      if ( options === void 0 ) options = parser.getParseOptions(ractive);\n\n      return parser.parse(template, options);\n    }\n  });\n}\n\nfunction parseTemplate(template, ractive) {\n  if (isString(template)) {\n    // parse will validate and add expression functions\n    template = parseAsString(template, ractive);\n  } else {\n    // need to validate and add exp for already parsed template\n    validate$1(template);\n    addFunctions(template);\n  }\n\n  return template;\n}\n\nfunction parseAsString(template, ractive) {\n  // ID of an element containing the template?\n  if (template[0] === '#') {\n    template = parser.fromId(template);\n  }\n\n  return parser.parseFor(template, ractive);\n}\n\nfunction validate$1(template) {\n  // Check that the template even exists\n  if (template == undefined) {\n    throw new Error((\"The template cannot be \" + template + \".\"));\n  } else if (!isNumber(template.v)) {\n    // Check the parsed template has a version at all\n    throw new Error(\n      \"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\"\n    );\n  } else if (template.v !== TEMPLATE_VERSION) {\n    // Check we're using the correct version\n    throw new Error(\n      (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\")\n    );\n  }\n}\n\nfunction extendPartials(existingPartials, newPartials, overwrite) {\n  if (!newPartials) { return; }\n\n  // TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  // case, but not initially...\n\n  for (var key in newPartials) {\n    if (overwrite || !hasOwn(existingPartials, key)) {\n      existingPartials[key] = newPartials[key];\n    }\n  }\n}\n\nvar registryNames = [\n  'adaptors',\n  'components',\n  'computed',\n  'decorators',\n  'easing',\n  'events',\n  'helpers',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar registriesOnDefaults = ['computed', 'helpers'];\n\nvar Registry = function Registry(name, useDefaults) {\n  this.name = name;\n  this.useDefaults = useDefaults;\n};\nvar Registry__proto__ = Registry.prototype;\n\nRegistry__proto__.extend = function extend (Parent, proto, options) {\n  var parent = this.useDefaults ? Parent.defaults : Parent;\n  var target = this.useDefaults ? proto : proto.constructor;\n  this.configure(parent, target, options);\n};\n\nRegistry__proto__.init = function init () {\n  // noop\n};\n\nRegistry__proto__.configure = function configure (Parent, target, options) {\n  var name = this.name;\n  var option = options[name];\n\n  var registry = create(Parent[name]);\n\n  assign(registry, option);\n\n  target[name] = registry;\n\n  if (name === 'partials' && target[name]) {\n    keys(target[name]).forEach(function (key) {\n      addFunctions(target[name][key]);\n    });\n  }\n};\n\nRegistry__proto__.reset = function reset (ractive) {\n  var registry = ractive[this.name];\n  var changed = false;\n\n  keys(registry).forEach(function (key) {\n    var item = registry[key];\n\n    if (item._fn) {\n      if (item._fn.isOwner) {\n        registry[key] = item._fn;\n      } else {\n        delete registry[key];\n      }\n      changed = true;\n    }\n  });\n\n  return changed;\n};\n\nvar registries = registryNames.map(function (name) {\n  var putInDefaults = registriesOnDefaults.indexOf(name) > -1;\n  return new Registry(name, putInDefaults);\n});\n\nfunction wrap(parent, name, method) {\n  if (!/_super/.test(method)) { return method; }\n\n  function wrapper() {\n    var superMethod = getSuperMethod(wrapper._parent, name);\n    var hasSuper = '_super' in this;\n    var oldSuper = this._super;\n\n    this._super = superMethod;\n\n    var result = method.apply(this, arguments);\n\n    if (hasSuper) {\n      this._super = oldSuper;\n    } else {\n      delete this._super;\n    }\n\n    return result;\n  }\n\n  wrapper._parent = parent;\n  wrapper._method = method;\n\n  return wrapper;\n}\n\nfunction getSuperMethod(parent, name) {\n  if (name in parent) {\n    var value = parent[name];\n\n    return isFunction(value) ? value : function () { return value; };\n  }\n\n  return noop;\n}\n\nfunction getMessage(deprecated, correct, isError) {\n  return (\n    \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" +\n    (isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '')\n  );\n}\n\nfunction deprecateOption(options, deprecatedOption, correct) {\n  if (deprecatedOption in options) {\n    if (!(correct in options)) {\n      warnIfDebug(getMessage(deprecatedOption, correct));\n      options[correct] = options[deprecatedOption];\n    } else {\n      throw new Error(getMessage(deprecatedOption, correct, true));\n    }\n  }\n}\n\nfunction deprecate(options) {\n  deprecateOption(options, 'beforeInit', 'onconstruct');\n  deprecateOption(options, 'init', 'onrender');\n  deprecateOption(options, 'complete', 'oncomplete');\n  deprecateOption(options, 'eventDefinitions', 'events');\n\n  // Using extend with Component instead of options,\n  // like Human.extend( Spider ) means adaptors as a registry\n  // gets copied to options. So we have to check if actually an array\n  if (isArray(options.adaptors)) {\n    deprecateOption(options, 'adaptors', 'adapt');\n  }\n}\n\nvar config = {\n  extend: function (Parent, proto, options, Child) { return configure('extend', Parent, proto, options, Child); },\n  init: function (Parent, ractive, options) { return configure('init', Parent, ractive, options); },\n  reset: function (ractive) { return order.filter(function (c) { return c.reset && c.reset(ractive); }).map(function (c) { return c.name; }); }\n};\n\nvar custom = {\n  adapt: adaptConfigurator,\n  computed: config,\n  css: cssConfigurator,\n  data: dataConfigurator,\n  helpers: config,\n  template: templateConfigurator\n};\n\nvar defaultKeys = keys(defaults);\n\nvar isStandardKey = makeObj(defaultKeys.filter(function (key) { return !custom[key]; }));\n\n// blacklisted keys that we don't double extend\nvar isBlacklisted = makeObj(\n  defaultKeys.concat(registries.map(function (r) { return r.name; }), ['on', 'observe', 'attributes', 'cssData', 'use'])\n);\n\nvar order = [].concat(\n  defaultKeys.filter(function (key) { return !registries[key] && !custom[key]; }),\n  registries,\n  //custom.data,\n  custom.template,\n  custom.css\n);\n\nfunction configure(method, Parent, target, options, Child) {\n  deprecate(options);\n\n  for (var key in options) {\n    if (hasOwn(isStandardKey, key)) {\n      var value = options[key];\n\n      // warn the developer if they passed a function and ignore its value\n\n      // NOTE: we allow some functions on \"el\" because we duck type element lists\n      // and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n      // function object as the result of querySelector methods\n      if (key !== 'el' && isFunction(value)) {\n        warnIfDebug(\n          (key + \" is a Ractive option that does not expect a function and will be ignored\"),\n          method === 'init' ? target : null\n        );\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n\n  // disallow combination of `append` and `enhance`\n  if (target.append && target.enhance) {\n    throw new Error('Cannot use append and enhance at the same time');\n  }\n\n  registries.forEach(function (registry) {\n    registry[method](Parent, target, options, Child);\n  });\n\n  adaptConfigurator[method](Parent, target, options, Child);\n  templateConfigurator[method](Parent, target, options, Child);\n  cssConfigurator[method](Parent, target, options, Child);\n\n  extendOtherMethods(Parent.prototype, target, options);\n}\n\nvar _super = /\\b_super\\b/;\nfunction extendOtherMethods(parent, target, options) {\n  for (var key in options) {\n    if (!isBlacklisted[key] && hasOwn(options, key)) {\n      var member = options[key];\n\n      // if this is a method that overwrites a method, wrap it:\n      if (isFunction(member)) {\n        if (\n          (key in proto$9 ||\n            (key.slice(0, 2) === 'on' && key.slice(2) in hooks && key in target)) &&\n          !_super.test(member.toString())\n        ) {\n          warnIfDebug(\n            (\"Overriding Ractive prototype function '\" + key + \"' without calling the '\" + _super + \"' method can be very dangerous.\")\n          );\n        }\n        member = wrap(parent, key, member);\n      }\n\n      target[key] = member;\n    }\n  }\n}\n\nfunction makeObj(array) {\n  var obj = {};\n  array.forEach(function (x) { return (obj[x] = true); });\n  return obj;\n}\n\nvar Item = function Item(options) {\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n\n  this.template = options.template;\n  this.index = options.index;\n  this.type = options.template.t;\n\n  this.dirty = false;\n};\nvar Item__proto__ = Item.prototype;\n\nItem__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    this.up.bubble();\n  }\n};\n\nItem__proto__.destroyed = function destroyed () {\n  if (this.fragment) { this.fragment.destroyed(); }\n};\n\nItem__proto__.find = function find () {\n  return null;\n};\n\nItem__proto__.findComponent = function findComponent () {\n  return null;\n};\n\nItem__proto__.findNextNode = function findNextNode () {\n  return this.up.findNextNode(this);\n};\n\nItem__proto__.rebound = function rebound (update) {\n  if (this.fragment) { this.fragment.rebound(update); }\n};\n\nItem__proto__.shuffled = function shuffled () {\n  if (this.fragment) { this.fragment.shuffled(); }\n};\n\nItem__proto__.valueOf = function valueOf () {\n  return this.toString();\n};\n\nItem.prototype.findAll = noop;\nItem.prototype.findAllComponents = noop;\n\nvar ContainerItem = (function (Item) {\n  function ContainerItem(options) {\n    Item.call(this, options);\n  }\n\n  if ( Item ) ContainerItem.__proto__ = Item;\n  var ContainerItem__proto__ = ContainerItem.prototype = Object.create( Item && Item.prototype );\n  ContainerItem__proto__.constructor = ContainerItem;\n\n  ContainerItem__proto__.detach = function detach () {\n    return this.fragment ? this.fragment.detach() : createDocumentFragment();\n  };\n\n  ContainerItem__proto__.find = function find (selector) {\n    if (this.fragment) {\n      return this.fragment.find(selector);\n    }\n  };\n\n  ContainerItem__proto__.findAll = function findAll (selector, options) {\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  ContainerItem__proto__.findComponent = function findComponent (name) {\n    if (this.fragment) {\n      return this.fragment.findComponent(name);\n    }\n  };\n\n  ContainerItem__proto__.findAllComponents = function findAllComponents (name, options) {\n    if (this.fragment) {\n      this.fragment.findAllComponents(name, options);\n    }\n  };\n\n  ContainerItem__proto__.firstNode = function firstNode (skipParent) {\n    return this.fragment && this.fragment.firstNode(skipParent);\n  };\n\n  ContainerItem__proto__.toString = function toString (escape) {\n    return this.fragment ? this.fragment.toString(escape) : '';\n  };\n\n  return ContainerItem;\n}(Item));\n\nvar space = /\\s+/;\n\nfunction readStyle(css) {\n  if (!isString(css)) { return {}; }\n\n  return cleanCss(css, function (css, reconstruct) {\n    return css\n      .split(';')\n      .filter(function (rule) { return !!rule.trim(); })\n      .map(reconstruct)\n      .reduce(function (rules, rule) {\n        var i = rule.indexOf(':');\n        var name = rule.substr(0, i).trim();\n        rules[name] = rule.substr(i + 1).trim();\n        return rules;\n      }, {});\n  });\n}\n\nfunction readClass(str) {\n  var list = str.split(space);\n\n  // remove any empty entries\n  var i = list.length;\n  while (i--) {\n    if (!list[i]) { list.splice(i, 1); }\n  }\n\n  return list;\n}\n\nvar textTypes = [\n  undefined,\n  'text',\n  'search',\n  'url',\n  'email',\n  'hidden',\n  'password',\n  'search',\n  'reset',\n  'submit'\n];\n\nfunction getUpdateDelegate(attribute) {\n  var element = attribute.element;\n  var name = attribute.name;\n\n  if (name === 'value') {\n    if (attribute.interpolator) { attribute.interpolator.bound = true; }\n\n    // special case - selects\n    if (element.name === 'select' && name === 'value') {\n      return element.getAttribute('multiple') ? updateMultipleSelectValue : updateSelectValue;\n    }\n\n    if (element.name === 'textarea') { return updateStringValue; }\n\n    // special case - contenteditable\n    if (element.getAttribute('contenteditable') != null) { return updateContentEditableValue; }\n\n    // special case - <input>\n    if (element.name === 'input') {\n      var type = element.getAttribute('type');\n\n      // type='file' value='{{fileList}}'>\n      if (type === 'file') { return noop; } // read-only\n\n      // type='radio' name='{{twoway}}'\n      if (type === 'radio' && element.binding && element.binding.attribute.name === 'name')\n        { return updateRadioValue; }\n\n      if (~textTypes.indexOf(type)) { return updateStringValue; }\n    }\n\n    return updateValue;\n  }\n\n  var node = element.node;\n\n  // special case - <input type='radio' name='{{twoway}}' value='foo'>\n  if (attribute.isTwoway && name === 'name') {\n    if (node.type === 'radio') { return updateRadioName; }\n    if (node.type === 'checkbox') { return updateCheckboxName; }\n  }\n\n  if (name === 'style') { return updateStyleAttribute; }\n\n  if (name.indexOf('style-') === 0) { return updateInlineStyle; }\n\n  // special case - class names. IE fucks things up, again\n  if (name === 'class' && (!node.namespaceURI || node.namespaceURI === html))\n    { return updateClassName; }\n\n  if (name.indexOf('class-') === 0) { return updateInlineClass; }\n\n  if (attribute.isBoolean) {\n    var type$1 = element.getAttribute('type');\n    if (attribute.interpolator && name === 'checked' && (type$1 === 'checkbox' || type$1 === 'radio'))\n      { attribute.interpolator.bound = true; }\n    return updateBoolean;\n  }\n\n  if (attribute.namespace && attribute.namespace !== attribute.node.namespaceURI)\n    { return updateNamespacedAttribute; }\n\n  return updateAttribute;\n}\n\nfunction updateMultipleSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!isArray(value)) { value = [value]; }\n\n  var options = this.node.options;\n  var i = options.length;\n\n  if (reset) {\n    while (i--) { options[i].selected = false; }\n  } else {\n    while (i--) {\n      var option = options[i];\n      var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n      option.selected = arrayContains(value, optionValue);\n    }\n  }\n}\n\nfunction updateSelectValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    // TODO is locked still a thing?\n    this.node._ractive.value = value;\n\n    var options = this.node.options;\n    var i = options.length;\n    var wasSelected = false;\n\n    if (reset) {\n      while (i--) { options[i].selected = false; }\n    } else {\n      while (i--) {\n        var option = options[i];\n        var optionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n        if (option.disabled && option.selected) { wasSelected = true; }\n\n        if (optionValue == value) {\n          // double equals as we may be comparing numbers with strings\n          option.selected = true;\n          return;\n        }\n      }\n    }\n\n    if (!wasSelected) { this.node.selectedIndex = -1; }\n  }\n}\n\nfunction updateContentEditableValue(reset) {\n  var value = this.getValue();\n\n  if (!this.locked) {\n    if (reset) { this.node.innerHTML = ''; }\n    else { this.node.innerHTML = isUndefined(value) ? '' : value; }\n  }\n}\n\nfunction updateRadioValue(reset) {\n  var node = this.node;\n  var wasChecked = node.checked;\n\n  var value = this.getValue();\n\n  if (reset) { return (node.checked = false); }\n\n  //node.value = this.element.getAttribute( 'value' );\n  node.value = this.node._ractive.value = value;\n  node.checked = this.element.compare(value, this.element.getAttribute('name'));\n\n  // This is a special case - if the input was checked, and the value\n  // changed so that it's no longer checked, the twoway binding is\n  // most likely out of date. To fix it we have to jump through some\n  // hoops... this is a little kludgy but it works\n  if (wasChecked && !node.checked && this.element.binding && this.element.binding.rendered) {\n    this.element.binding.group.model.set(this.element.binding.group.getValue());\n  }\n}\n\nfunction updateValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node.removeAttribute('value');\n      this.node.value = this.node._ractive.value = null;\n    } else {\n      var value = this.getValue();\n\n      this.node.value = this.node._ractive.value = value;\n      this.node.setAttribute('value', safeToStringValue(value));\n    }\n  }\n}\n\nfunction updateStringValue(reset) {\n  if (!this.locked) {\n    if (reset) {\n      this.node._ractive.value = '';\n      this.node.removeAttribute('value');\n    } else {\n      var value = this.getValue();\n\n      this.node._ractive.value = value;\n\n      var safeValue = safeToStringValue(value);\n\n      // fixes #3281  Safari moves caret position when setting an input value to the same value\n      if (this.node.value !== safeValue) {\n        this.node.value = safeValue;\n      }\n\n      this.node.setAttribute('value', safeValue);\n    }\n  }\n}\n\nfunction updateRadioName(reset) {\n  if (reset) { this.node.checked = false; }\n  else { this.node.checked = this.element.compare(this.getValue(), this.element.binding.getValue()); }\n}\n\nfunction updateCheckboxName(reset) {\n  var ref = this;\n  var element = ref.element;\n  var node = ref.node;\n  var binding = element.binding;\n\n  var value = this.getValue();\n  var valueAttribute = element.getAttribute('value');\n\n  if (!isArray(value)) {\n    binding.isChecked = node.checked = element.compare(value, valueAttribute);\n  } else {\n    var i = value.length;\n    while (i--) {\n      if (element.compare(valueAttribute, value[i])) {\n        binding.isChecked = node.checked = true;\n        return;\n      }\n    }\n    binding.isChecked = node.checked = false;\n  }\n}\n\nfunction updateStyleAttribute(reset) {\n  var props = reset ? {} : readStyle(this.getValue() || '');\n  var style = this.node.style;\n  var keys$$1 = keys(props);\n  var prev = this.previous || [];\n\n  var i = 0;\n  while (i < keys$$1.length) {\n    if (keys$$1[i] in style) {\n      var safe = props[keys$$1[i]].replace('!important', '');\n      style.setProperty(keys$$1[i], safe, safe.length !== props[keys$$1[i]].length ? 'important' : '');\n    }\n    i++;\n  }\n\n  // remove now-missing attrs\n  i = prev.length;\n  while (i--) {\n    if (!~keys$$1.indexOf(prev[i]) && prev[i] in style) { style.setProperty(prev[i], '', ''); }\n  }\n\n  this.previous = keys$$1;\n}\n\nfunction updateInlineStyle(reset) {\n  if (!this.style) {\n    this.style = hyphenateCamel(this.name.substr(6));\n  }\n\n  if (reset && this.node.style.getPropertyValue(this.style) !== this.last) { return; }\n\n  var value = reset ? '' : safeToStringValue(this.getValue());\n  var safe = value.replace('!important', '');\n  this.node.style.setProperty(this.style, safe, safe.length !== value.length ? 'important' : '');\n  this.last = this.node.style.getPropertyValue(this.style);\n}\n\nfunction updateClassName(reset) {\n  var value = reset ? [] : readClass(safeToStringValue(this.getValue()));\n\n  // watch out for werdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var prev = this.previous || [];\n\n  var className = value.concat(attr.filter(function (c) { return !~prev.indexOf(c); })).join(' ');\n\n  if (className !== cls) {\n    if (!isString(this.node.className)) {\n      this.node.className.baseVal = className;\n    } else {\n      this.node.className = className;\n    }\n  }\n\n  this.previous = value;\n}\n\nfunction updateInlineClass(reset) {\n  var name = this.name.substr(6);\n\n  // watch out for werdo svg elements\n  var cls = this.node.className;\n  cls = cls.baseVal !== undefined ? cls.baseVal : cls;\n\n  var attr = readClass(cls);\n  var value = reset ? false : this.getValue();\n\n  if (!this.inlineClass) { this.inlineClass = name; }\n\n  if (value && !~attr.indexOf(name)) { attr.push(name); }\n  else if (!value && ~attr.indexOf(name)) { attr.splice(attr.indexOf(name), 1); }\n\n  if (!isString(this.node.className)) {\n    this.node.className.baseVal = attr.join(' ');\n  } else {\n    this.node.className = attr.join(' ');\n  }\n}\n\nfunction updateBoolean(reset) {\n  // with two-way binding, only update if the change wasn't initiated by the user\n  // otherwise the cursor will often be sent to the wrong place\n  if (!this.locked) {\n    if (reset) {\n      if (this.useProperty) { this.node[this.propertyName] = false; }\n      this.node.removeAttribute(this.propertyName);\n    } else {\n      if (this.useProperty) {\n        this.node[this.propertyName] = this.getValue();\n      } else {\n        var val = this.getValue();\n        if (val) {\n          this.node.setAttribute(this.propertyName, isString(val) ? val : '');\n        } else {\n          this.node.removeAttribute(this.propertyName);\n        }\n      }\n    }\n  }\n}\n\nfunction updateAttribute(reset) {\n  if (reset) {\n    if (this.node.getAttribute(this.name) === this.value) {\n      this.node.removeAttribute(this.name);\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttribute(this.name, this.value);\n  }\n}\n\nfunction updateNamespacedAttribute(reset) {\n  if (reset) {\n    if (\n      this.value ===\n      this.node.getAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1))\n    ) {\n      this.node.removeAttributeNS(this.namespace, this.name.slice(this.name.indexOf(':') + 1));\n    }\n  } else {\n    this.value = safeToStringValue(this.getString());\n    this.node.setAttributeNS(\n      this.namespace,\n      this.name.slice(this.name.indexOf(':') + 1),\n      this.value\n    );\n  }\n}\n\nvar propertyNames = {\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  bgcolor: 'bgColor',\n  class: 'className',\n  codebase: 'codeBase',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  datetime: 'dateTime',\n  dirname: 'dirName',\n  for: 'htmlFor',\n  'http-equiv': 'httpEquiv',\n  ismap: 'isMap',\n  maxlength: 'maxLength',\n  novalidate: 'noValidate',\n  pubdate: 'pubDate',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  tabindex: 'tabIndex',\n  usemap: 'useMap'\n};\n\nvar div$1 = doc ? createElement('div') : null;\n\nvar attributes = false;\nfunction inAttributes() {\n  return attributes;\n}\n\nvar ConditionalAttribute = (function (Item) {\n  function ConditionalAttribute(options) {\n    Item.call(this, options);\n\n    this.attributes = [];\n\n    this.owner = options.owner;\n\n    this.fragment = new Fragment({\n      ractive: this.ractive,\n      owner: this,\n      template: this.template\n    });\n\n    // this fragment can't participate in node-y things\n    this.fragment.findNextNode = noop;\n\n    this.dirty = false;\n  }\n\n  if ( Item ) ConditionalAttribute.__proto__ = Item;\n  var ConditionalAttribute__proto__ = ConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n  ConditionalAttribute__proto__.constructor = ConditionalAttribute;\n\n  ConditionalAttribute__proto__.bind = function bind () {\n    this.fragment.bind();\n  };\n\n  ConditionalAttribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.owner.bubble();\n    }\n  };\n\n  ConditionalAttribute__proto__.destroyed = function destroyed () {\n    this.unrender();\n  };\n\n  ConditionalAttribute__proto__.render = function render () {\n    this.node = this.owner.node;\n    if (this.node) {\n      this.isSvg = this.node.namespaceURI === svg$1;\n    }\n\n    attributes = true;\n    if (!this.rendered) { this.fragment.render(); }\n\n    this.rendered = true;\n    this.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n    this.update();\n    attributes = false;\n  };\n\n  ConditionalAttribute__proto__.toString = function toString () {\n    return this.fragment.toString();\n  };\n\n  ConditionalAttribute__proto__.unbind = function unbind (view) {\n    this.fragment.unbind(view);\n  };\n\n  ConditionalAttribute__proto__.unrender = function unrender () {\n    this.rendered = false;\n    this.fragment.unrender();\n  };\n\n  ConditionalAttribute__proto__.update = function update () {\n    var this$1 = this;\n\n    var str;\n    var attrs;\n\n    if (this.dirty) {\n      this.dirty = false;\n\n      var current = attributes;\n      attributes = true;\n      this.fragment.update();\n\n      if (this.rendered && this.node) {\n        str = this.fragment.toString();\n\n        attrs = parseAttributes(str, this.isSvg);\n\n        // any attributes that previously existed but no longer do\n        // must be removed\n        this.attributes\n          .filter(function (a) { return notIn(attrs, a); })\n          .forEach(function (a) {\n            this$1.node.removeAttribute(a.name);\n          });\n\n        attrs.forEach(function (a) {\n          this$1.node.setAttribute(a.name, a.value);\n        });\n\n        this.attributes = attrs;\n      }\n\n      attributes = current || false;\n    }\n  };\n\n  return ConditionalAttribute;\n}(Item));\n\nvar onlyWhitespace = /^\\s*$/;\nfunction parseAttributes(str, isSvg) {\n  if (onlyWhitespace.test(str)) { return []; }\n  var tagName = isSvg ? 'svg' : 'div';\n  return str\n    ? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") && toArray(div$1.childNodes[0].attributes)\n    : [];\n}\n\nfunction notIn(haystack, needle) {\n  var i = haystack.length;\n\n  while (i--) {\n    if (haystack[i].name === needle.name) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lookupNamespace(node, prefix) {\n  var qualified = \"xmlns:\" + prefix;\n\n  while (node) {\n    if (node.hasAttribute && node.hasAttribute(qualified)) { return node.getAttribute(qualified); }\n    node = node.parentNode;\n  }\n\n  return namespaces[prefix];\n}\n\nvar attribute = false;\nfunction inAttribute() {\n  return attribute;\n}\n\nvar Attribute = (function (Item) {\n  function Attribute(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n    this.namespace = null;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = options.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.rendered = false;\n    this.updateDelegate = null;\n    this.fragment = null;\n\n    this.element.attributeByName[this.name] = this;\n\n    if (!isArray(options.template.f)) {\n      this.value = options.template.f;\n      if (this.value === 0) {\n        this.value = '';\n      } else if (isUndefined(this.value)) {\n        this.value = true;\n      }\n      return;\n    } else {\n      this.fragment = new Fragment({\n        owner: this,\n        template: options.template.f\n      });\n    }\n\n    this.interpolator =\n      this.fragment &&\n      this.fragment.items.length === 1 &&\n      this.fragment.items[0].type === INTERPOLATOR &&\n      this.fragment.items[0];\n\n    if (this.interpolator) { this.interpolator.owner = this; }\n  }\n\n  if ( Item ) Attribute.__proto__ = Item;\n  var Attribute__proto__ = Attribute.prototype = Object.create( Item && Item.prototype );\n  Attribute__proto__.constructor = Attribute;\n\n  Attribute__proto__.bind = function bind () {\n    if (this.fragment) {\n      this.fragment.bind();\n    }\n  };\n\n  Attribute__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.up.bubble();\n      this.element.bubble();\n      this.dirty = true;\n    }\n  };\n\n  Attribute__proto__.firstNode = function firstNode () {};\n\n  Attribute__proto__.getString = function getString () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.toString()\n      : this.value != null\n      ? '' + this.value\n      : '';\n    attribute = false;\n    return value;\n  };\n\n  // TODO could getValue ever be called for a static attribute,\n  // or can we assume that this.fragment exists?\n  Attribute__proto__.getValue = function getValue () {\n    attribute = true;\n    var value = this.fragment\n      ? this.fragment.valueOf()\n      : booleanAttributes[this.name.toLowerCase()]\n      ? true\n      : this.value;\n    attribute = false;\n    return value;\n  };\n\n  Attribute__proto__.render = function render () {\n    var node = this.element.node;\n    this.node = node;\n\n    // should we use direct property access, or setAttribute?\n    if (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n      this.propertyName = propertyNames[this.name] || this.name;\n\n      if (node[this.propertyName] !== undefined) {\n        this.useProperty = true;\n      }\n\n      // is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n      // node.selected = true rather than node.setAttribute( 'selected', '' )\n      if (booleanAttributes[this.name.toLowerCase()] || this.isTwoway) {\n        this.isBoolean = true;\n      }\n\n      if (this.propertyName === 'value') {\n        node._ractive.value = this.value;\n      }\n    }\n\n    if (node.namespaceURI) {\n      var index = this.name.indexOf(':');\n      if (index !== -1) {\n        this.namespace = lookupNamespace(node, this.name.slice(0, index));\n      } else {\n        this.namespace = node.namespaceURI;\n      }\n    }\n\n    this.rendered = true;\n    this.updateDelegate = getUpdateDelegate(this);\n    this.updateDelegate();\n  };\n\n  Attribute__proto__.toString = function toString () {\n    if (inAttributes()) { return ''; }\n    attribute = true;\n\n    var value = this.getValue();\n\n    // Special case - select and textarea values (should not be stringified)\n    if (\n      this.name === 'value' &&\n      (this.element.getAttribute('contenteditable') !== undefined ||\n        (this.element.name === 'select' || this.element.name === 'textarea'))\n    ) {\n      return;\n    }\n\n    // Special case  bound radio `name` attributes\n    if (\n      this.name === 'name' &&\n      this.element.name === 'input' &&\n      this.interpolator &&\n      this.element.getAttribute('type') === 'radio'\n    ) {\n      return (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n    }\n\n    // Special case - style and class attributes and directives\n    if (\n      this.owner === this.element &&\n      (this.name === 'style' || this.name === 'class' || this.style || this.inlineClass)\n    ) {\n      return;\n    }\n\n    if (\n      !this.rendered &&\n      this.owner === this.element &&\n      (!this.name.indexOf('style-') || !this.name.indexOf('class-'))\n    ) {\n      if (!this.name.indexOf('style-')) {\n        this.style = hyphenateCamel(this.name.substr(6));\n      } else {\n        this.inlineClass = this.name.substr(6);\n      }\n\n      return;\n    }\n\n    if (booleanAttributes[this.name.toLowerCase()])\n      { return value\n        ? isString(value)\n          ? ((this.name) + \"=\\\"\" + (safeAttributeString(value)) + \"\\\"\")\n          : this.name\n        : ''; }\n    if (value == null) { return ''; }\n\n    var str = safeAttributeString(this.getString());\n    attribute = false;\n\n    return str ? ((this.name) + \"=\\\"\" + str + \"\\\"\") : this.name;\n  };\n\n  Attribute__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Attribute__proto__.unrender = function unrender () {\n    this.updateDelegate(true);\n\n    this.rendered = false;\n  };\n\n  Attribute__proto__.update = function update () {\n    if (this.dirty) {\n      var binding;\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      if (this.rendered) { this.updateDelegate(); }\n      if (this.isTwoway && !this.locked) {\n        this.interpolator.twowayBinding.lastVal(true, this.interpolator.model.get());\n      } else if (this.name === 'value' && (binding = this.element.binding)) {\n        // special case: name bound element with dynamic value\n        var attr = binding.attribute;\n        if (attr && !attr.dirty && attr.rendered) {\n          this.element.binding.attribute.updateDelegate();\n        }\n      }\n    }\n  };\n\n  return Attribute;\n}(Item));\n\nvar BindingFlag = (function (Item) {\n  function BindingFlag(options) {\n    Item.call(this, options);\n\n    this.owner = options.owner || options.up.owner || findElement(options.up);\n    this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n    this.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n    this.bubbler = this.owner === this.element ? this.element : this.up;\n\n    if (this.element.type === ELEMENT) {\n      if (isArray(options.template.f)) {\n        this.fragment = new Fragment({\n          owner: this,\n          template: options.template.f\n        });\n      }\n\n      this.interpolator =\n        this.fragment &&\n        this.fragment.items.length === 1 &&\n        this.fragment.items[0].type === INTERPOLATOR &&\n        this.fragment.items[0];\n    }\n  }\n\n  if ( Item ) BindingFlag.__proto__ = Item;\n  var BindingFlag__proto__ = BindingFlag.prototype = Object.create( Item && Item.prototype );\n  BindingFlag__proto__.constructor = BindingFlag;\n\n  BindingFlag__proto__.bind = function bind () {\n    if (this.fragment) { this.fragment.bind(); }\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.bubbler.bubble();\n      this.dirty = true;\n    }\n  };\n\n  BindingFlag__proto__.getValue = function getValue () {\n    if (this.fragment) { return this.fragment.valueOf(); }\n    else if ('value' in this) { return this.value; }\n    else if ('f' in this.template) { return this.template.f; }\n    else { return true; }\n  };\n\n  BindingFlag__proto__.render = function render () {\n    set$1(this, this.getValue(), true);\n  };\n\n  BindingFlag__proto__.toString = function toString () {\n    return '';\n  };\n\n  BindingFlag__proto__.unbind = function unbind (view) {\n    if (this.fragment) { this.fragment.unbind(view); }\n\n    delete this.element[this.flag];\n  };\n\n  BindingFlag__proto__.unrender = function unrender () {\n    if (this.element.rendered) { this.element.recreateTwowayBinding(); }\n  };\n\n  BindingFlag__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.fragment) { this.fragment.update(); }\n      set$1(this, this.getValue(), true);\n    }\n  };\n\n  return BindingFlag;\n}(Item));\n\nfunction set$1(flag, value, update) {\n  if (value === 0) {\n    flag.value = true;\n  } else if (value === 'true') {\n    flag.value = true;\n  } else if (value === 'false' || value === '0') {\n    flag.value = false;\n  } else {\n    flag.value = value;\n  }\n\n  var current = flag.element[flag.flag];\n  flag.element[flag.flag] = flag.value;\n  if (update && !flag.element.attributes.binding && current !== flag.value) {\n    flag.element.recreateTwowayBinding();\n  }\n\n  return flag.value;\n}\n\nfunction Comment(options) {\n  Item.call(this, options);\n}\n\nvar proto$1 = create(Item.prototype);\n\nassign(proto$1, {\n  bind: noop,\n  unbind: noop,\n  update: noop,\n\n  detach: function detach() {\n    return detachNode(this.node);\n  },\n\n  firstNode: function firstNode() {\n    return this.node;\n  },\n\n  render: function render(target) {\n    this.rendered = true;\n\n    this.node = doc.createComment(this.template.c);\n    target.appendChild(this.node);\n  },\n\n  toString: function toString() {\n    return (\"<!-- \" + (this.template.c) + \" -->\");\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  }\n});\n\nComment.prototype = proto$1;\n\n// Teardown. This goes through the root fragment and all its children, removing observers\n// and generally cleaning up after itself\n\nfunction Ractive$teardown() {\n  var this$1 = this;\n\n  if (this.torndown) {\n    warnIfDebug('ractive.teardown() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  this.shouldDestroy = true;\n  return teardown$1(this, function () { return (this$1.fragment.rendered ? this$1.unrender() : Promise.resolve()); });\n}\n\nfunction teardown$1(instance, getPromise) {\n  instance.torndown = true;\n  instance.fragment.unbind();\n  instance._observers.slice().forEach(cancel);\n\n  if (instance.el && instance.el.__ractive_instances__) {\n    removeFromArray(instance.el.__ractive_instances__, instance);\n  }\n\n  var promise = getPromise();\n\n  hooks.teardown.fire(instance);\n\n  promise.then(function () {\n    hooks.destruct.fire(instance);\n    instance.viewmodel.teardown();\n  });\n\n  return promise;\n}\n\nvar RactiveModel = (function (SharedModel) {\n  function RactiveModel(ractive) {\n    SharedModel.call(this, ractive, '@this');\n    this.ractive = ractive;\n  }\n\n  if ( SharedModel ) RactiveModel.__proto__ = SharedModel;\n  var RactiveModel__proto__ = RactiveModel.prototype = Object.create( SharedModel && SharedModel.prototype );\n  RactiveModel__proto__.constructor = RactiveModel;\n\n  RactiveModel__proto__.joinKey = function joinKey (key) {\n    var model = SharedModel.prototype.joinKey.call(this, key);\n\n    if ((key === 'root' || key === 'parent') && !model.isLink) { return initLink(model, key); }\n    else if (key === 'data') { return this.ractive.viewmodel; }\n    else if (key === 'cssData') { return this.ractive.constructor._cssModel; }\n\n    return model;\n  };\n\n  return RactiveModel;\n}(SharedModel));\n\nfunction initLink(model, key) {\n  model.applyValue = function(value) {\n    this.parent.value[key] = value;\n    if (value && value.viewmodel) {\n      this.link(value.viewmodel.getRactiveModel(), key);\n      this._link.markedAll();\n    } else {\n      this.link(create(Missing), key);\n      this._link.markedAll();\n    }\n  };\n\n  if (key === 'root') {\n    var mark = model.mark;\n    model.mark = function(force) {\n      if (this._marking) { return; }\n      this._marking = true;\n      mark.apply(this, force);\n      this._marking = false;\n    };\n  }\n\n  model.applyValue(model.parent.ractive[key], key);\n  model._link.set = function (v) { return model.applyValue(v); };\n  model._link.applyValue = function (v) { return model.applyValue(v); };\n\n  return model._link;\n}\n\nvar specialModels = {\n  '@this': function _this(root) {\n    return root.getRactiveModel();\n  },\n  '@global': function _global() {\n    return GlobalModel;\n  },\n  '@shared': function _shared() {\n    return SharedModel$1;\n  },\n  '@style': function _style(root) {\n    return root.getRactiveModel().joinKey('cssData');\n  },\n  '@helpers': function _helpers(root) {\n    return root.getHelpers();\n  }\n};\nspecialModels['@'] = specialModels['@this'];\n\nvar RootModel = (function (Model) {\n  function RootModel(options) {\n    Model.call(this, null, null);\n\n    this.isRoot = true;\n    this.root = this;\n    this.ractive = options.ractive; // TODO sever this link\n\n    this.value = options.data;\n    this.adaptors = options.adapt;\n    this.adapt();\n  }\n\n  if ( Model ) RootModel.__proto__ = Model;\n  var RootModel__proto__ = RootModel.prototype = Object.create( Model && Model.prototype );\n  RootModel__proto__.constructor = RootModel;\n\n  RootModel__proto__.attached = function attached (fragment) {\n    attachImplicits(this, fragment);\n  };\n\n  RootModel__proto__.createLink = function createLink (keypath, target, targetPath, options) {\n    var keys = splitKeypath(keypath);\n\n    var model = this;\n    while (keys.length) {\n      var key = keys.shift();\n      model = model.childByKey[key] || model.joinKey(key);\n    }\n\n    return model.link(target, targetPath, options);\n  };\n\n  RootModel__proto__.detached = function detached () {\n    detachImplicits(this);\n  };\n\n  RootModel__proto__.get = function get (shouldCapture, options) {\n    if (shouldCapture) { capture(this); }\n\n    if (!options || options.virtual !== false) {\n      return this.getVirtual();\n    } else {\n      return this.value;\n    }\n  };\n\n  RootModel__proto__.getHelpers = function getHelpers () {\n    if (!this.helpers) { this.helpers = new SharedModel(this.ractive.helpers, 'helpers', this.ractive); }\n    return this.helpers;\n  };\n\n  RootModel__proto__.getKeypath = function getKeypath () {\n    return '';\n  };\n\n  RootModel__proto__.getRactiveModel = function getRactiveModel () {\n    return this.ractiveModel || (this.ractiveModel = new RactiveModel(this.ractive));\n  };\n\n  RootModel__proto__.getValueChildren = function getValueChildren () {\n    var children = Model.prototype.getValueChildren.call(this, this.value);\n\n    this.children.forEach(function (child) {\n      if (child._link) {\n        var idx = children.indexOf(child);\n        if (~idx) { children.splice(idx, 1, child._link); }\n        else { children.push(child._link); }\n      }\n    });\n\n    return children;\n  };\n\n  RootModel__proto__.has = function has (key) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n    if (specialModels[key] || key === '') { return true; }\n\n    if (Model.prototype.has.call(this, key)) {\n      return true;\n    } else {\n      var unescapedKey = unescapeKey(key);\n\n      // mappings/links and computations\n      if (this.childByKey[unescapedKey] && this.childByKey[unescapedKey]._link) { return true; }\n    }\n  };\n\n  RootModel__proto__.joinKey = function joinKey (key, opts) {\n    if (key[0] === '~' && key[1] === '/') { key = key.slice(2); }\n\n    if (key[0] === '@') {\n      var fn = specialModels[key];\n      if (fn) { return fn(this); }\n    } else {\n      return Model.prototype.joinKey.call(this, key, opts);\n    }\n  };\n\n  RootModel__proto__.set = function set (value) {\n    // TODO wrapping root node is a baaaad idea. We should prevent this\n    var wrapper = this.wrapper;\n    if (wrapper) {\n      var shouldTeardown = !wrapper.reset || wrapper.reset(value) === false;\n\n      if (shouldTeardown) {\n        wrapper.teardown();\n        this.wrapper = null;\n        this.value = value;\n        this.adapt();\n      }\n    } else {\n      this.value = value;\n      this.adapt();\n    }\n\n    this.deps.forEach(handleChange);\n    this.children.forEach(mark);\n  };\n\n  RootModel__proto__.retrieve = function retrieve () {\n    return this.wrapper ? this.wrapper.get() : this.value;\n  };\n\n  RootModel__proto__.teardown = function teardown () {\n    Model.prototype.teardown.call(this);\n    this.ractiveModel && this.ractiveModel.teardown();\n  };\n\n  return RootModel;\n}(Model));\nRootModel.prototype.update = noop;\n\nfunction attachImplicits(model, fragment) {\n  if (model._link && model._link.implicit && model._link.isDetached()) {\n    model.attach(fragment);\n  }\n\n  // look for virtual children to relink and cascade\n  for (var k in model.childByKey) {\n    if (model.value) {\n      if (k in model.value) {\n        attachImplicits(model.childByKey[k], fragment);\n      } else if (!model.childByKey[k]._link || model.childByKey[k]._link.isDetached()) {\n        var mdl = resolveReference(fragment, k);\n        if (mdl) {\n          model.childByKey[k].link(mdl, k, { implicit: true });\n        }\n      }\n    }\n  }\n}\n\nfunction detachImplicits(model) {\n  if (model._link && model._link.implicit) {\n    model.unlink();\n  }\n\n  for (var k in model.childByKey) {\n    detachImplicits(model.childByKey[k]);\n  }\n}\n\nfunction subscribe(instance, options, type) {\n  var subs = (instance.constructor[(\"_\" + type)] || []).concat(toPairs(options[type] || []));\n  var single = type === 'on' ? 'once' : (type + \"Once\");\n\n  subs.forEach(function (ref) {\n    var target = ref[0];\n    var config = ref[1];\n\n    if (isFunction(config)) {\n      instance[type](target, config);\n    } else if (isObjectType(config) && isFunction(config.handler)) {\n      instance[config.once ? single : type](target, config.handler, create(config));\n    }\n  });\n}\n\nvar registryNames$1 = [\n  'adaptors',\n  'components',\n  'decorators',\n  'easing',\n  'events',\n  'interpolators',\n  'partials',\n  'transitions'\n];\n\nvar protoRegistries = ['computed', 'helpers'];\n\nvar uid = 0;\n\nfunction construct(ractive, options) {\n  if (Ractive.DEBUG) { welcome(); }\n\n  initialiseProperties(ractive);\n  handleAttributes(ractive);\n\n  // set up event subscribers\n  subscribe(ractive, options, 'on');\n\n  // if there's not a delegation setting, inherit from parent if it's not default\n  if (\n    !hasOwn(options, 'delegate') &&\n    ractive.parent &&\n    ractive.parent.delegate !== ractive.delegate\n  ) {\n    ractive.delegate = false;\n  }\n\n  // plugins that need to run at construct\n  if (isArray(options.use)) {\n    ractive.use.apply(ractive, options.use.filter(function (p) { return p.construct; }));\n  }\n\n  hooks.construct.fire(ractive, options);\n  if (options.onconstruct) { options.onconstruct.call(ractive, getRactiveContext(ractive), options); }\n\n  // Add registries\n  var i = registryNames$1.length;\n  while (i--) {\n    var name = registryNames$1[i];\n    ractive[name] = assign(create(ractive.constructor[name] || null), options[name]);\n  }\n\n  i = protoRegistries.length;\n  while (i--) {\n    var name$1 = protoRegistries[i];\n    ractive[name$1] = assign(create(ractive.constructor.prototype[name$1]), options[name$1]);\n  }\n\n  if (ractive._attributePartial) {\n    ractive.partials['extra-attributes'] = ractive._attributePartial;\n    delete ractive._attributePartial;\n  }\n\n  // Create a viewmodel\n  var viewmodel = new RootModel({\n    adapt: getAdaptors(ractive, ractive.adapt, options),\n    data: dataConfigurator.init(ractive.constructor, ractive, options),\n    ractive: ractive\n  });\n\n  // once resolved, share the adaptors array between the root model and instance\n  ractive.adapt = viewmodel.adaptors;\n\n  ractive.viewmodel = viewmodel;\n\n  for (var k in ractive.computed) {\n    compute.call(ractive, k, ractive.computed[k]);\n  }\n}\n\nfunction getAdaptors(ractive, protoAdapt, options) {\n  protoAdapt = protoAdapt.map(lookup);\n  var adapt = ensureArray(options.adapt).map(lookup);\n\n  var srcs = [protoAdapt, adapt];\n  if (ractive.parent && !ractive.isolated) {\n    srcs.push(ractive.parent.viewmodel.adaptors);\n  }\n\n  return combine.apply(null, srcs);\n\n  function lookup(adaptor) {\n    if (isString(adaptor)) {\n      adaptor = findInViewHierarchy('adaptors', ractive, adaptor);\n\n      if (!adaptor) {\n        fatal(missingPlugin(adaptor, 'adaptor'));\n      }\n    }\n\n    return adaptor;\n  }\n}\n\nfunction initialiseProperties(ractive) {\n  // Generate a unique identifier, for places where you'd use a weak map if it\n  // existed\n  ractive._guid = 'r-' + uid++;\n\n  // events\n  ractive._subs = create(null);\n  ractive._nsSubs = 0;\n\n  // storage for item configuration from instantiation to reset,\n  // like dynamic functions or original values\n  ractive._config = {};\n\n  // events\n  ractive.event = null;\n  ractive._eventQueue = [];\n\n  // observers\n  ractive._observers = [];\n\n  // external children\n  ractive._children = [];\n  ractive._children.byName = {};\n  ractive.children = ractive._children;\n\n  if (!ractive.component) {\n    ractive.root = ractive;\n    ractive.parent = ractive.container = null; // TODO container still applicable?\n  }\n}\n\nfunction handleAttributes(ractive) {\n  var component = ractive.component;\n  var attributes = ractive.constructor.attributes;\n\n  if (attributes && component) {\n    var tpl = component.template;\n    var attrs = tpl.m ? tpl.m.slice() : [];\n\n    // grab all of the passed attribute names\n    var props = attrs.filter(function (a) { return a.t === ATTRIBUTE; }).map(function (a) { return a.n; });\n\n    // warn about missing requireds\n    attributes.required.forEach(function (p) {\n      if (!~props.indexOf(p)) {\n        warnIfDebug((\"Component '\" + (component.name) + \"' requires attribute '\" + p + \"' to be provided\"));\n      }\n    });\n\n    // set up a partial containing non-property attributes\n    var all = attributes.optional.concat(attributes.required);\n    var partial = [];\n    var i = attrs.length;\n    while (i--) {\n      var a = attrs[i];\n      if (a.t === ATTRIBUTE && !~all.indexOf(a.n)) {\n        if (attributes.mapAll) {\n          // map the attribute if requested and make the extra attribute in the partial refer to the mapping\n          partial.unshift({\n            t: ATTRIBUTE,\n            n: a.n,\n            f: [{ t: INTERPOLATOR, r: (\"~/\" + (a.n)) }]\n          });\n        } else {\n          // transfer the attribute to the extra attributes partal\n          partial.unshift(attrs.splice(i, 1)[0]);\n        }\n      } else if (\n        !attributes.mapAll &&\n        (a.t === DECORATOR || a.t === TRANSITION || a.t === BINDING_FLAG)\n      ) {\n        partial.unshift(attrs.splice(i, 1)[0]);\n      }\n    }\n\n    if (partial.length) { component.template = { t: tpl.t, e: tpl.e, f: tpl.f, m: attrs, p: tpl.p }; }\n    ractive._attributePartial = partial;\n  }\n}\n\nvar Component = (function (Item) {\n  function Component(options, ComponentConstructor) {\n    var this$1 = this;\n\n    Item.call(this, options);\n    var template = options.template;\n    this.isAnchor = template.t === ANCHOR;\n    this.type = this.isAnchor ? ANCHOR : COMPONENT; // override ELEMENT from super\n    var attrs = template.m;\n\n    var partials = template.p || {};\n    if (!('content' in partials)) { partials.content = template.f || []; }\n    this._partials = partials; // TEMP\n\n    if (this.isAnchor) {\n      this.name = template.n;\n\n      this.addChild = addChild;\n      this.removeChild = removeChild;\n    } else {\n      var instance = create(ComponentConstructor.prototype);\n\n      this.instance = instance;\n      this.name = template.e;\n\n      if (instance.el || instance.target) {\n        warnIfDebug(\n          (\"The <\" + (this.name) + \"> component has a default '\" + (instance.el ? 'el' : 'target') + \"' property; it has been disregarded\")\n        );\n        instance.el = instance.target = null;\n      }\n\n      // find container\n      var fragment = options.up;\n      var container;\n      while (fragment) {\n        if (fragment.owner.type === YIELDER) {\n          container = fragment.owner.container;\n          break;\n        }\n\n        fragment = fragment.parent;\n      }\n\n      // add component-instance-specific properties\n      instance.parent = this.up.ractive;\n      instance.container = container || null;\n      instance.root = instance.parent.root;\n      instance.component = this;\n\n      construct(this.instance, { partials: partials });\n\n      // these can be modified during construction\n      template = this.template;\n      attrs = template.m;\n\n      // allow components that are so inclined to add programmatic mappings\n      if (isArray(this.mappings)) {\n        attrs = (attrs || []).concat(this.mappings);\n      } else if (isString(this.mappings)) {\n        attrs = (attrs || []).concat(parser.parse(this.mappings, { attributes: true }).t);\n      }\n\n      // for hackability, this could be an open option\n      // for any ractive instance, but for now, just\n      // for components and just for ractive...\n      instance._inlinePartials = partials;\n    }\n\n    this.attributeByName = {};\n    this.attributes = [];\n\n    if (attrs) {\n      var leftovers = [];\n      attrs.forEach(function (template) {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case EVENT:\n            this$1.attributes.push(\n              createItem({\n                owner: this$1,\n                up: this$1.up,\n                template: template\n              })\n            );\n            break;\n\n          case TRANSITION:\n          case BINDING_FLAG:\n          case DECORATOR:\n            break;\n\n          default:\n            leftovers.push(template);\n            break;\n        }\n      });\n\n      if (leftovers.length) {\n        this.attributes.push(\n          new ConditionalAttribute({\n            owner: this,\n            up: this.up,\n            template: leftovers\n          })\n        );\n      }\n    }\n\n    this.eventHandlers = [];\n  }\n\n  if ( Item ) Component.__proto__ = Item;\n  var Component__proto__ = Component.prototype = Object.create( Item && Item.prototype );\n  Component__proto__.constructor = Component;\n\n  Component__proto__.bind = function bind () {\n    if (!this.isAnchor) {\n      this.attributes.forEach(bind$1);\n      this.eventHandlers.forEach(bind$1);\n\n      initialise(\n        this.instance,\n        {\n          partials: this._partials\n        },\n        {\n          cssIds: this.up.cssIds\n        }\n      );\n\n      if (this.instance.target || this.instance.el) { this.extern = true; }\n\n      this.bound = true;\n    }\n  };\n\n  Component__proto__.bubble = function bubble () {\n    if (!this.dirty) {\n      this.dirty = true;\n      this.up.bubble();\n    }\n  };\n\n  Component__proto__.destroyed = function destroyed () {\n    if (!this.isAnchor && this.instance.fragment) { this.instance.fragment.destroyed(); }\n  };\n\n  Component__proto__.detach = function detach () {\n    if (this.isAnchor) {\n      if (this.instance) { return this.instance.fragment.detach(); }\n      return createDocumentFragment();\n    }\n\n    return this.instance.fragment.detach();\n  };\n\n  Component__proto__.find = function find (selector, options) {\n    if (this.instance) { return this.instance.fragment.find(selector, options); }\n  };\n\n  Component__proto__.findAll = function findAll (selector, options) {\n    if (this.instance) { this.instance.fragment.findAll(selector, options); }\n  };\n\n  Component__proto__.findComponent = function findComponent (name, options) {\n    if (!name || this.name === name) { return this.instance; }\n\n    if (this.instance.fragment) {\n      return this.instance.fragment.findComponent(name, options);\n    }\n  };\n\n  Component__proto__.findAllComponents = function findAllComponents (name, options) {\n    var result = options.result;\n\n    if (this.instance && (!name || this.name === name)) {\n      result.push(this.instance);\n    }\n\n    if (this.instance) { this.instance.findAllComponents(name, options); }\n  };\n\n  Component__proto__.firstNode = function firstNode (skipParent) {\n    if (this.instance) { return this.instance.fragment.firstNode(skipParent); }\n  };\n\n  Component__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    assigns.unshift(this.instance);\n    return getRactiveContext.apply(null, assigns);\n  };\n\n  Component__proto__.rebound = function rebound (update$$1) {\n    this.attributes.forEach(function (x) { return x.rebound(update$$1); });\n  };\n\n  Component__proto__.render = function render$2 (target, occupants) {\n    if (this.isAnchor) {\n      this.rendered = true;\n      this.target = target;\n\n      if (!checking.length) {\n        checking.push(this.ractive);\n        if (occupants) {\n          this.occupants = occupants;\n          checkAnchors();\n          this.occupants = null;\n        } else {\n          runloop.scheduleTask(checkAnchors, true);\n        }\n      }\n    } else {\n      this.attributes.forEach(render);\n      this.eventHandlers.forEach(render);\n\n      if (this.extern) {\n        this.instance.delegate = false;\n        this.instance.render();\n      } else {\n        render$1(this.instance, target, null, occupants);\n      }\n\n      this.rendered = true;\n    }\n  };\n\n  Component__proto__.shuffled = function shuffled () {\n    Item.prototype.shuffled.call(this);\n    this.instance &&\n      !this.instance.isolated &&\n      this.instance.fragment &&\n      this.instance.fragment.shuffled();\n  };\n\n  Component__proto__.toString = function toString () {\n    if (this.instance) { return this.instance.toHTML(); }\n  };\n\n  Component__proto__.unbind = function unbind$1 (view) {\n    if (!this.isAnchor) {\n      this.bound = false;\n\n      this.attributes.forEach(unbind);\n\n      if (view) { this.instance.fragment.unbind(); }\n      else { teardown$1(this.instance, function () { return runloop.promise(); }); }\n    }\n  };\n\n  Component__proto__.unrender = function unrender$1 (shouldDestroy) {\n    this.shouldDestroy = shouldDestroy;\n\n    if (this.isAnchor) {\n      if (this.item) { unrenderItem(this, this.item); }\n      this.target = null;\n      if (!checking.length) {\n        checking.push(this.ractive);\n        runloop.scheduleTask(checkAnchors, true);\n      }\n    } else {\n      this.instance.unrender();\n      this.instance.el = this.instance.target = null;\n      this.attributes.forEach(unrender);\n      this.eventHandlers.forEach(unrender);\n    }\n\n    this.rendered = false;\n  };\n\n  Component__proto__.update = function update$2 () {\n    this.dirty = false;\n    if (this.instance) {\n      this.instance.fragment.update();\n      this.attributes.forEach(update);\n      this.eventHandlers.forEach(update);\n    }\n  };\n\n  return Component;\n}(Item));\n\nfunction addChild(meta) {\n  if (this.item) { this.removeChild(this.item); }\n\n  var child = meta.instance;\n  meta.anchor = this;\n\n  meta.up = this.up;\n  meta.name = meta.nameOption || this.name;\n  this.name = meta.name;\n\n  if (!child.isolated) { child.viewmodel.attached(this.up); }\n\n  // render as necessary\n  if (this.rendered) {\n    renderItem(this, meta);\n  }\n}\n\nfunction removeChild(meta) {\n  // unrender as necessary\n  if (this.item === meta) {\n    unrenderItem(this, meta);\n    this.name = this.template.n;\n  }\n}\n\nfunction renderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = false;\n  meta.up = anchor.up;\n\n  anchor.item = meta;\n  anchor.instance = meta.instance;\n  var nextNode = anchor.up.findNextNode(anchor);\n\n  if (meta.instance.fragment.rendered) {\n    meta.instance.unrender();\n  }\n\n  meta.partials = meta.instance.partials;\n  meta.instance.partials = assign(create(meta.partials), meta.partials, anchor._partials);\n\n  meta.instance.fragment.unbind(true);\n  meta.instance.fragment.componentParent = anchor.up;\n  meta.instance.fragment.bind(meta.instance.viewmodel);\n\n  anchor.attributes.forEach(bind$1);\n  anchor.eventHandlers.forEach(bind$1);\n  anchor.attributes.forEach(render);\n  anchor.eventHandlers.forEach(render);\n\n  var target = anchor.up.findParentNode();\n  render$1(meta.instance, target, target.contains(nextNode) ? nextNode : null, anchor.occupants);\n\n  if (meta.lastBound !== anchor) {\n    meta.lastBound = anchor;\n  }\n}\n\nfunction unrenderItem(anchor, meta) {\n  if (!anchor.rendered) { return; }\n\n  meta.shouldDestroy = true;\n  meta.instance.unrender();\n\n  anchor.eventHandlers.forEach(unrender);\n  anchor.attributes.forEach(unrender);\n  anchor.eventHandlers.forEach(unbind);\n  anchor.attributes.forEach(unbind);\n\n  meta.instance.el = meta.instance.anchor = null;\n  meta.instance.fragment.componentParent = null;\n  meta.up = null;\n  meta.anchor = null;\n  anchor.item = null;\n  anchor.instance = null;\n}\n\nvar checking = [];\nfunction checkAnchors() {\n  var list = checking;\n  checking = [];\n\n  list.forEach(updateAnchors);\n}\n\nfunction setupArgsFn(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  if (template && template.f && template.f.s) {\n    item.fn = getFunction(template.f.s, template.f.r.length);\n    if (opts.register === true) {\n      item.models = resolveArgs(item, template, fragment, opts);\n    }\n  }\n}\n\nfunction resolveArgs(item, template, fragment, opts) {\n  if ( opts === void 0 ) opts = {};\n\n  return template.f.r.map(function (ref, i) {\n    var model;\n\n    if (opts.specialRef && (model = opts.specialRef(ref, i))) { return model; }\n\n    model = resolveReference(fragment, ref);\n    if (opts.register === true) {\n      model.register(item);\n    }\n\n    return model;\n  });\n}\n\nfunction teardownArgsFn(item, template) {\n  if (template && template.f && template.f.s) {\n    if (item.models)\n      { item.models.forEach(function (m) {\n        if (m && m.unregister) { m.unregister(item); }\n      }); }\n    item.models = null;\n  }\n}\n\nvar missingDecorator = {\n  update: noop,\n  teardown: noop\n};\n\nvar Decorator = function Decorator(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.up = options.up || this.owner.up;\n  this.ractive = this.owner.ractive;\n  var template = (this.template = options.template);\n\n  this.name = template.n;\n\n  this.node = null;\n  this.handle = null;\n\n  this.element.decorators.push(this);\n};\nvar Decorator__proto__ = Decorator.prototype;\n\nDecorator__proto__.bind = function bind () {\n  // if the owner is the elment, make sure the context includes the element\n  var frag = this.element === this.owner ? new Fragment({ owner: this.owner }) : this.up;\n  setupArgsFn(this, this.template, frag, { register: true });\n};\n\nDecorator__proto__.bubble = function bubble () {\n  if (!this.dirty) {\n    this.dirty = true;\n    // decorators may be owned directly by an element or by a fragment if conditional\n    this.owner.bubble();\n    this.up.bubble();\n  }\n};\n\nDecorator__proto__.destroyed = function destroyed () {\n  if (this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n  this.shouldDestroy = true;\n};\n\nDecorator__proto__.handleChange = function handleChange () {\n  this.bubble();\n};\n\nDecorator__proto__.rebind = function rebind (next, previous, safe) {\n  var idx = this.models.indexOf(previous);\n  if (!~idx) { return; }\n\n  next = rebindMatch(this.template.f.r[idx], next, previous);\n  if (next === previous) { return; }\n\n  previous.unregister(this);\n  this.models.splice(idx, 1, next);\n  if (next) { next.addShuffleRegister(this, 'mark'); }\n\n  if (!safe) { this.bubble(); }\n};\n\nDecorator__proto__.rebound = function rebound (update) {\n  teardownArgsFn(this, this.template);\n  setupArgsFn(this, this.template, this.up, { register: true });\n  if (update) { this.bubble(); }\n};\n\nDecorator__proto__.render = function render () {\n    var this$1 = this;\n\n  this.shouldDestroy = false;\n  if (this.handle) { this.unrender(); }\n  runloop.scheduleTask(function () {\n    // bail if the host element has managed to become unrendered\n    if (!this$1.element.rendered) { return; }\n\n    var fn = findInViewHierarchy('decorators', this$1.ractive, this$1.name);\n\n    if (!fn) {\n      warnOnce(missingPlugin(this$1.name, 'decorator'));\n      this$1.handle = missingDecorator;\n      return;\n    }\n\n    this$1.node = this$1.element.node;\n\n    var args;\n    if (this$1.fn) {\n      args = this$1.models.map(function (model) {\n        if (!model) { return undefined; }\n\n        return model.get();\n      });\n      args = this$1.fn.apply(this$1.ractive, args);\n    }\n\n    this$1.handle = fn.apply(this$1.ractive, [this$1.node].concat(args));\n\n    if (!this$1.handle || !this$1.handle.teardown) {\n      throw new Error(\n        (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\")\n      );\n    }\n\n    // watch out for decorators that cause their host element to be unrendered\n    if (this$1.shouldDestroy) { this$1.destroyed(); }\n  }, true);\n};\n\nDecorator__proto__.toString = function toString () {\n  return '';\n};\n\nDecorator__proto__.unbind = function unbind () {\n  teardownArgsFn(this, this.template);\n};\n\nDecorator__proto__.unrender = function unrender (shouldDestroy) {\n  if ((!shouldDestroy || this.element.rendered) && this.handle) {\n    this.handle.teardown();\n    this.handle = null;\n  }\n};\n\nDecorator__proto__.update = function update () {\n  var instance = this.handle;\n\n  if (!this.dirty) {\n    if (instance && instance.invalidate) {\n      runloop.scheduleTask(function () { return instance.invalidate(); }, true);\n    }\n    return;\n  }\n\n  this.dirty = false;\n\n  if (instance) {\n    if (!instance.update) {\n      this.unrender();\n      this.render();\n    } else {\n      var args = this.models.map(function (model) { return model && model.get(); });\n      instance.update.apply(this.ractive, this.fn.apply(this.ractive, args));\n    }\n  }\n};\n\nDecorator.prototype.firstNode = noop;\n\nvar Doctype = (function (Item) {\n  function Doctype () {\n    Item.apply(this, arguments);\n  }\n\n  if ( Item ) Doctype.__proto__ = Item;\n  var Doctype__proto__ = Doctype.prototype = Object.create( Item && Item.prototype );\n  Doctype__proto__.constructor = Doctype;\n\n  Doctype__proto__.toString = function toString () {\n    return '<!DOCTYPE' + this.template.a + '>';\n  };\n\n  return Doctype;\n}(Item));\n\nvar proto$2 = Doctype.prototype;\nproto$2.bind = proto$2.render = proto$2.teardown = proto$2.unbind = proto$2.unrender = proto$2.update = noop;\n\nvar Binding = function Binding(element, name) {\n  if ( name === void 0 ) name = 'value';\n\n  this.element = element;\n  this.ractive = element.ractive;\n  this.attribute = element.attributeByName[name];\n\n  var interpolator = this.attribute.interpolator;\n  interpolator.twowayBinding = this;\n\n  var model = interpolator.model;\n\n  if (model.isReadonly && !model.setRoot) {\n    var keypath = model.getKeypath().replace(/^@/, '');\n    warnOnceIfDebug(\n      (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"),\n      { ractive: this.ractive }\n    );\n    return false;\n  }\n\n  this.attribute.isTwoway = true;\n  this.model = model;\n\n  // initialise value, if it's undefined\n  var value = model.get();\n  this.wasUndefined = isUndefined(value);\n\n  if (isUndefined(value) && this.getInitialValue) {\n    value = this.getInitialValue();\n    model.set(value);\n  }\n  this.lastVal(true, value);\n\n  var parentForm = findElement(this.element, false, 'form');\n  if (parentForm) {\n    this.resetValue = value;\n    parentForm.formBindings.push(this);\n  }\n};\nvar Binding__proto__ = Binding.prototype;\n\nBinding__proto__.bind = function bind () {\n  this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.handleChange = function handleChange () {\n    var this$1 = this;\n\n  var value = this.getValue();\n  if (this.lastVal() === value) { return; }\n\n  runloop.start();\n  this.attribute.locked = true;\n  this.model.set(value);\n  this.lastVal(true, value);\n\n  // if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n  if (this.model.get() !== value) { this.attribute.locked = false; }\n  else { runloop.scheduleTask(function () { return (this$1.attribute.locked = false); }); }\n\n  runloop.end();\n};\n\nBinding__proto__.lastVal = function lastVal (setting, value) {\n  if (setting) { this.lastValue = value; }\n  else { return this.lastValue; }\n};\n\nBinding__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  if (this.model && this.model === previous) { previous.unregisterTwowayBinding(this); }\n  if (next) {\n    this.model = next;\n    runloop.scheduleTask(function () { return next.registerTwowayBinding(this$1); });\n  }\n};\n\nBinding__proto__.rebound = function rebound () {\n  if (this.model) { this.model.unregisterTwowayBinding(this); }\n  this.model = this.attribute.interpolator.model;\n  this.model && this.model.registerTwowayBinding(this);\n};\n\nBinding__proto__.render = function render () {\n  this.node = this.element.node;\n  this.node._ractive.binding = this;\n  this.rendered = true; // TODO is this used anywhere?\n};\n\nBinding__proto__.setFromNode = function setFromNode (node) {\n  this.model.set(node.value);\n};\n\nBinding__proto__.unbind = function unbind () {\n  this.model && this.model.unregisterTwowayBinding(this);\n};\n\nBinding.prototype.unrender = noop;\n\n// This is the handler for DOM events that would lead to a change in the model\n// (i.e. change, sometimes, input, and occasionally click and keyup)\nfunction handleDomEvent() {\n  this._ractive.binding.handleChange();\n}\n\nvar CheckboxBinding = (function (Binding) {\n  function CheckboxBinding(element) {\n    Binding.call(this, element, 'checked');\n  }\n\n  if ( Binding ) CheckboxBinding.__proto__ = Binding;\n  var CheckboxBinding__proto__ = CheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxBinding__proto__.constructor = CheckboxBinding;\n\n  CheckboxBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxBinding__proto__.getInitialValue = function getInitialValue () {\n    return !!this.element.getAttribute('checked');\n  };\n\n  CheckboxBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  CheckboxBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  return CheckboxBinding;\n}(Binding));\n\nfunction getBindingGroup(group, model, getValue) {\n  var hash = group + \"-bindingGroup\";\n  return model[hash] || (model[hash] = new BindingGroup(hash, model, getValue));\n}\n\nvar BindingGroup = function BindingGroup(hash, model, getValue) {\n  var this$1 = this;\n\n  this.model = model;\n  this.hash = hash;\n  this.getValue = function () {\n    this$1.value = getValue.call(this$1);\n    return this$1.value;\n  };\n\n  this.bindings = [];\n};\nvar BindingGroup__proto__ = BindingGroup.prototype;\n\nBindingGroup__proto__.add = function add (binding) {\n  this.bindings.push(binding);\n};\n\nBindingGroup__proto__.bind = function bind () {\n    var this$1 = this;\n\n  this.value = this.model.get();\n  this.bindings.forEach(function (b) { return b.lastVal(true, this$1.value); });\n  this.model.registerTwowayBinding(this);\n  this.bound = true;\n};\n\nBindingGroup__proto__.remove = function remove (binding) {\n  removeFromArray(this.bindings, binding);\n  if (!this.bindings.length) {\n    this.unbind();\n  }\n};\n\nBindingGroup__proto__.unbind = function unbind () {\n  this.model.unregisterTwowayBinding(this);\n  this.bound = false;\n  delete this.model[this.hash];\n};\n\nBindingGroup.prototype.rebind = Binding.prototype.rebind;\n\nvar push$1 = [].push;\n\nfunction getValue() {\n  var this$1 = this;\n\n  var all = this.bindings\n    .filter(function (b) { return b.node && b.node.checked; })\n    .map(function (b) { return b.element.getAttribute('value'); });\n  var res = [];\n  all.forEach(function (v) {\n    if (!this$1.bindings[0].arrayContains(res, v)) { res.push(v); }\n  });\n  return res;\n}\n\nvar CheckboxNameBinding = (function (Binding) {\n  function CheckboxNameBinding(element) {\n    Binding.call(this, element, 'name');\n\n    this.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n    // Each input has a reference to an array containing it and its\n    // group, as two-way binding depends on being able to ascertain\n    // the status of all inputs within the group\n    this.group = getBindingGroup('checkboxes', this.model, getValue);\n    this.group.add(this);\n\n    if (this.noInitialValue) {\n      this.group.noInitialValue = true;\n    }\n\n    // If no initial value was set, and this input is checked, we\n    // update the model\n    if (this.group.noInitialValue && this.element.getAttribute('checked')) {\n      var existingValue = this.model.get();\n      var bindingValue = this.element.getAttribute('value');\n\n      if (!this.arrayContains(existingValue, bindingValue)) {\n        push$1.call(existingValue, bindingValue); // to avoid triggering runloop with array adaptor\n      }\n    }\n  }\n\n  if ( Binding ) CheckboxNameBinding.__proto__ = Binding;\n  var CheckboxNameBinding__proto__ = CheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  CheckboxNameBinding__proto__.constructor = CheckboxNameBinding;\n\n  CheckboxNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  CheckboxNameBinding__proto__.getInitialValue = function getInitialValue () {\n    // This only gets called once per group (of inputs that\n    // share a name), because it only gets called if there\n    // isn't an initial value. By the same token, we can make\n    // a note of that fact that there was no initial value,\n    // and populate it using any `checked` attributes that\n    // exist (which users should avoid, but which we should\n    // support anyway to avoid breaking expectations)\n    this.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n    return [];\n  };\n\n  CheckboxNameBinding__proto__.getValue = function getValue () {\n    return this.group.value;\n  };\n\n  CheckboxNameBinding__proto__.handleChange = function handleChange () {\n    this.isChecked = this.element.node.checked;\n    this.group.value = this.model.get().slice();\n    var value = this.element.getAttribute('value');\n    if (this.isChecked && !this.arrayContains(this.group.value, value)) {\n      this.group.value.push(value);\n    } else if (!this.isChecked && this.arrayContains(this.group.value, value)) {\n      this.removeFromArray(this.group.value, value);\n    }\n    // make sure super knows there's a change\n    this.lastValue = null;\n    Binding.prototype.handleChange.call(this);\n  };\n\n  CheckboxNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    var existingValue = this.model.get();\n    var bindingValue = this.element.getAttribute('value');\n\n    if (isArray(existingValue)) {\n      this.isChecked = this.arrayContains(existingValue, bindingValue);\n    } else {\n      this.isChecked = this.element.compare(existingValue, bindingValue);\n    }\n    node.name = '{{' + this.model.getKeypath() + '}}';\n    node.checked = this.isChecked;\n\n    this.element.on('change', handleDomEvent);\n\n    // in case of IE emergency, bind to click event as well\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.setFromNode = function setFromNode (node) {\n    this.group.bindings.forEach(function (binding) { return (binding.wasUndefined = true); });\n\n    if (node.checked) {\n      var valueSoFar = this.group.getValue();\n      valueSoFar.push(this.element.getAttribute('value'));\n\n      this.group.model.set(valueSoFar);\n    }\n  };\n\n  CheckboxNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  CheckboxNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  CheckboxNameBinding__proto__.arrayContains = function arrayContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.element.compare(optionValue, selectValue[i])) { return true; }\n    }\n    return false;\n  };\n\n  CheckboxNameBinding__proto__.removeFromArray = function removeFromArray (array, item) {\n    var this$1 = this;\n\n    if (!array) { return; }\n    var i = array.length;\n    while (i--) {\n      if (this$1.element.compare(item, array[i])) {\n        array.splice(i, 1);\n      }\n    }\n  };\n\n  return CheckboxNameBinding;\n}(Binding));\n\nvar ContentEditableBinding = (function (Binding) {\n  function ContentEditableBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) ContentEditableBinding.__proto__ = Binding;\n  var ContentEditableBinding__proto__ = ContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n  ContentEditableBinding__proto__.constructor = ContentEditableBinding;\n\n  ContentEditableBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.fragment ? this.element.fragment.toString() : '';\n  };\n\n  ContentEditableBinding__proto__.getValue = function getValue () {\n    return this.element.node.innerHTML;\n  };\n\n  ContentEditableBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var el = this.element;\n\n    el.on('change', handleDomEvent);\n    el.on('blur', handleDomEvent);\n\n    if (!this.ractive.lazy) {\n      el.on('input', handleDomEvent);\n\n      if (this.node.attachEvent) {\n        el.on('keyup', handleDomEvent);\n      }\n    }\n  };\n\n  ContentEditableBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.innerHTML);\n  };\n\n  ContentEditableBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('blur', handleDomEvent);\n    el.off('change', handleDomEvent);\n    el.off('input', handleDomEvent);\n    el.off('keyup', handleDomEvent);\n  };\n\n  return ContentEditableBinding;\n}(Binding));\n\nfunction handleBlur() {\n  handleDomEvent.call(this);\n\n  var value = this._ractive.binding.model.get();\n  this.value = value == undefined ? '' : value;\n}\n\nfunction handleDelay(delay) {\n  var timeout;\n\n  return function() {\n    var this$1 = this;\n\n    if (timeout) { clearTimeout(timeout); }\n\n    timeout = setTimeout(function () {\n      var binding = this$1._ractive.binding;\n      if (binding.rendered) { handleDomEvent.call(this$1); }\n      timeout = null;\n    }, delay);\n  };\n}\n\nvar GenericBinding = (function (Binding) {\n  function GenericBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) GenericBinding.__proto__ = Binding;\n  var GenericBinding__proto__ = GenericBinding.prototype = Object.create( Binding && Binding.prototype );\n  GenericBinding__proto__.constructor = GenericBinding;\n\n  GenericBinding__proto__.getInitialValue = function getInitialValue () {\n    return '';\n  };\n\n  GenericBinding__proto__.getValue = function getValue () {\n    return this.node.value;\n  };\n\n  GenericBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    // any lazy setting for this element overrides the root\n    // if the value is a number, it's a timeout\n    var lazy = this.ractive.lazy;\n    var timeout = false;\n    var el = this.element;\n\n    if ('lazy' in this.element) {\n      lazy = this.element.lazy;\n    }\n\n    if (isNumeric(lazy)) {\n      timeout = +lazy;\n      lazy = false;\n    }\n\n    this.handler = timeout ? handleDelay(timeout) : handleDomEvent;\n\n    var node = this.node;\n\n    el.on('change', handleDomEvent);\n\n    if (node.type !== 'file') {\n      if (!lazy) {\n        el.on('input', this.handler);\n\n        // IE is a special snowflake\n        if (node.attachEvent) {\n          el.on('keyup', this.handler);\n        }\n      }\n\n      el.on('blur', handleBlur);\n    }\n  };\n\n  GenericBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n    this.rendered = false;\n\n    el.off('change', handleDomEvent);\n    el.off('input', this.handler);\n    el.off('keyup', this.handler);\n    el.off('blur', handleBlur);\n  };\n\n  return GenericBinding;\n}(Binding));\n\nvar FileBinding = (function (GenericBinding) {\n  function FileBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) FileBinding.__proto__ = GenericBinding;\n  var FileBinding__proto__ = FileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  FileBinding__proto__.constructor = FileBinding;\n\n  FileBinding__proto__.getInitialValue = function getInitialValue () {\n    /* istanbul ignore next */\n    return undefined;\n  };\n\n  FileBinding__proto__.getValue = function getValue () {\n    /* istanbul ignore next */\n    return this.node.files;\n  };\n\n  FileBinding__proto__.render = function render () {\n    /* istanbul ignore next */\n    this.element.lazy = false;\n    /* istanbul ignore next */\n    GenericBinding.prototype.render.call(this);\n  };\n\n  FileBinding__proto__.setFromNode = function setFromNode (node) {\n    /* istanbul ignore next */\n    this.model.set(node.files);\n  };\n\n  return FileBinding;\n}(GenericBinding));\n\nfunction getSelectedOptions(select) {\n  /* istanbul ignore next */\n  return select.selectedOptions\n    ? toArray(select.selectedOptions)\n    : select.options\n    ? toArray(select.options).filter(function (option) { return option.selected; })\n    : [];\n}\n\nvar MultipleSelectBinding = (function (Binding) {\n  function MultipleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) MultipleSelectBinding.__proto__ = Binding;\n  var MultipleSelectBinding__proto__ = MultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  MultipleSelectBinding__proto__.constructor = MultipleSelectBinding;\n\n  MultipleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    return this.element.options\n      .filter(function (option) { return option.getAttribute('selected'); })\n      .map(function (option) { return option.getAttribute('value'); });\n  };\n\n  MultipleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.element.node.options;\n    var len = options.length;\n\n    var selectedValues = [];\n\n    for (var i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (option.selected) {\n        var optionValue = option._ractive ? option._ractive.value : option.value;\n        selectedValues.push(optionValue);\n      }\n    }\n\n    return selectedValues;\n  };\n\n  MultipleSelectBinding__proto__.handleChange = function handleChange () {\n    var attribute = this.attribute;\n    var previousValue = attribute.getValue();\n\n    var value = this.getValue();\n\n    if (isUndefined(previousValue) || !arrayContentsMatch(value, previousValue)) {\n      Binding.prototype.handleChange.call(this);\n    }\n\n    return this;\n  };\n\n  MultipleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (isUndefined(this.model.get())) {\n      // get value from DOM, if possible\n      this.handleChange();\n    }\n  };\n\n  MultipleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var selectedOptions = getSelectedOptions(node);\n    var i = selectedOptions.length;\n    var result = new Array(i);\n\n    while (i--) {\n      var option = selectedOptions[i];\n      result[i] = option._ractive ? option._ractive.value : option.value;\n    }\n\n    this.model.set(result);\n  };\n\n  MultipleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return MultipleSelectBinding;\n}(Binding));\n\nvar NumericBinding = (function (GenericBinding) {\n  function NumericBinding () {\n    GenericBinding.apply(this, arguments);\n  }\n\n  if ( GenericBinding ) NumericBinding.__proto__ = GenericBinding;\n  var NumericBinding__proto__ = NumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  NumericBinding__proto__.constructor = NumericBinding;\n\n  NumericBinding__proto__.getInitialValue = function getInitialValue () {\n    return undefined;\n  };\n\n  NumericBinding__proto__.getValue = function getValue () {\n    var value = parseFloat(this.node.value);\n    return isNaN(value) ? undefined : value;\n  };\n\n  NumericBinding__proto__.setFromNode = function setFromNode (node) {\n    var value = parseFloat(node.value);\n    if (!isNaN(value)) { this.model.set(value); }\n  };\n\n  return NumericBinding;\n}(GenericBinding));\n\nvar siblings = {};\n\nfunction getSiblings(hash) {\n  return siblings[hash] || (siblings[hash] = []);\n}\n\nvar RadioBinding = (function (Binding) {\n  function RadioBinding(element) {\n    Binding.call(this, element, 'checked');\n\n    this.siblings = getSiblings(this.ractive._guid + this.element.getAttribute('name'));\n    this.siblings.push(this);\n  }\n\n  if ( Binding ) RadioBinding.__proto__ = Binding;\n  var RadioBinding__proto__ = RadioBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioBinding__proto__.constructor = RadioBinding;\n\n  RadioBinding__proto__.getValue = function getValue () {\n    return this.node.checked;\n  };\n\n  RadioBinding__proto__.handleChange = function handleChange () {\n    runloop.start();\n\n    this.siblings.forEach(function (binding) {\n      binding.model.set(binding.getValue());\n    });\n\n    runloop.end();\n  };\n\n  RadioBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    this.element.on('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioBinding__proto__.setFromNode = function setFromNode (node) {\n    this.model.set(node.checked);\n  };\n\n  RadioBinding__proto__.unbind = function unbind () {\n    removeFromArray(this.siblings, this);\n  };\n\n  RadioBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      this.element.off('click', handleDomEvent);\n    }\n  };\n\n  return RadioBinding;\n}(Binding));\n\nfunction getValue$1() {\n  var checked = this.bindings.filter(function (b) { return b.node.checked; });\n  if (checked.length > 0) {\n    return checked[0].element.getAttribute('value');\n  }\n}\n\nvar RadioNameBinding = (function (Binding) {\n  function RadioNameBinding(element) {\n    var this$1 = this;\n\n    Binding.call(this, element, 'name');\n\n    this.group = getBindingGroup('radioname', this.model, getValue$1);\n    this.group.add(this);\n\n    if (element.checked) {\n      this.group.value = this.getValue();\n    }\n\n    this.attribute.interpolator.pathChanged = function () { return this$1.updateName(); };\n  }\n\n  if ( Binding ) RadioNameBinding.__proto__ = Binding;\n  var RadioNameBinding__proto__ = RadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  RadioNameBinding__proto__.constructor = RadioNameBinding;\n\n  RadioNameBinding__proto__.bind = function bind () {\n    if (!this.group.bound) {\n      this.group.bind();\n    }\n  };\n\n  RadioNameBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('checked')) {\n      return this.element.getAttribute('value');\n    }\n  };\n\n  RadioNameBinding__proto__.getValue = function getValue () {\n    return this.element.getAttribute('value');\n  };\n\n  RadioNameBinding__proto__.handleChange = function handleChange () {\n    // If this <input> is the one that's checked, then the value of its\n    // `name` model gets set to its value\n    if (this.node.checked) {\n      this.group.value = this.getValue();\n      Binding.prototype.handleChange.call(this);\n    }\n\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.lastVal = function lastVal (setting, value) {\n    if (!this.group) { return; }\n    if (setting) { this.group.lastValue = value; }\n    else { return this.group.lastValue; }\n  };\n\n  RadioNameBinding__proto__.rebind = function rebind (next, previous) {\n    Binding.prototype.rebind.call(this, next, previous);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.rebound = function rebound (update) {\n    Binding.prototype.rebound.call(this, update);\n    this.updateName();\n  };\n\n  RadioNameBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n\n    var node = this.node;\n\n    this.updateName();\n    node.checked = this.element.compare(this.model.get(), this.element.getAttribute('value'));\n\n    this.element.on('change', handleDomEvent);\n\n    if (node.attachEvent) {\n      this.element.on('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.setFromNode = function setFromNode (node) {\n    if (node.checked) {\n      this.group.model.set(this.element.getAttribute('value'));\n    }\n  };\n\n  RadioNameBinding__proto__.unbind = function unbind () {\n    this.group.remove(this);\n  };\n\n  RadioNameBinding__proto__.unrender = function unrender () {\n    var el = this.element;\n\n    el.off('change', handleDomEvent);\n\n    if (this.node.attachEvent) {\n      el.off('click', handleDomEvent);\n    }\n  };\n\n  RadioNameBinding__proto__.updateName = function updateName () {\n    if (this.node) { this.node.name = \"{{\" + (this.model.getKeypath()) + \"}}\"; }\n  };\n\n  return RadioNameBinding;\n}(Binding));\n\nvar SingleSelectBinding = (function (Binding) {\n  function SingleSelectBinding () {\n    Binding.apply(this, arguments);\n  }\n\n  if ( Binding ) SingleSelectBinding.__proto__ = Binding;\n  var SingleSelectBinding__proto__ = SingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  SingleSelectBinding__proto__.constructor = SingleSelectBinding;\n\n  SingleSelectBinding__proto__.forceUpdate = function forceUpdate () {\n    var this$1 = this;\n\n    var value = this.getValue();\n\n    if (value !== undefined) {\n      this.attribute.locked = true;\n      runloop.scheduleTask(function () { return (this$1.attribute.locked = false); });\n      this.model.set(value);\n    }\n  };\n\n  SingleSelectBinding__proto__.getInitialValue = function getInitialValue () {\n    if (this.element.getAttribute('value') !== undefined) {\n      return;\n    }\n\n    var options = this.element.options;\n    var len = options.length;\n\n    if (!len) { return; }\n\n    var value;\n    var optionWasSelected;\n    var i = len;\n\n    // take the final selected option...\n    while (i--) {\n      var option = options[i];\n\n      if (option.getAttribute('selected')) {\n        if (!option.getAttribute('disabled')) {\n          value = option.getAttribute('value');\n        }\n\n        optionWasSelected = true;\n        break;\n      }\n    }\n\n    // or the first non-disabled option, if none are selected\n    if (!optionWasSelected) {\n      while (++i < len) {\n        if (!options[i].getAttribute('disabled')) {\n          value = options[i].getAttribute('value');\n          break;\n        }\n      }\n    }\n\n    // This is an optimisation (aka hack) that allows us to forgo some\n    // other more expensive work\n    // TODO does it still work? seems at odds with new architecture\n    if (value !== undefined) {\n      this.element.attributeByName.value.value = value;\n    }\n\n    return value;\n  };\n\n  SingleSelectBinding__proto__.getValue = function getValue () {\n    var options = this.node.options;\n    var len = options.length;\n\n    var i;\n    for (i = 0; i < len; i += 1) {\n      var option = options[i];\n\n      if (options[i].selected && !options[i].disabled) {\n        return option._ractive ? option._ractive.value : option.value;\n      }\n    }\n  };\n\n  SingleSelectBinding__proto__.render = function render () {\n    Binding.prototype.render.call(this);\n    this.element.on('change', handleDomEvent);\n  };\n\n  SingleSelectBinding__proto__.setFromNode = function setFromNode (node) {\n    var option = getSelectedOptions(node)[0];\n    this.model.set(option._ractive ? option._ractive.value : option.value);\n  };\n\n  SingleSelectBinding__proto__.unrender = function unrender () {\n    this.element.off('change', handleDomEvent);\n  };\n\n  return SingleSelectBinding;\n}(Binding));\n\nfunction isBindable(attribute) {\n  // The fragment must be a single non-string fragment\n  if (\n    !attribute ||\n    !attribute.template.f ||\n    attribute.template.f.length !== 1 ||\n    attribute.template.f[0].s\n  )\n    { return false; }\n\n  // A binding is an interpolator `{{ }}`, yey.\n  if (attribute.template.f[0].t === INTERPOLATOR) { return true; }\n\n  // The above is probably the only true case. For the rest, show an appropriate\n  // warning before returning false.\n\n  // You can't bind a triple curly. HTML values on an attribute makes no sense.\n  if (attribute.template.f[0].t === TRIPLE)\n    { warnIfDebug('It is not possible create a binding using a triple mustache.'); }\n\n  return false;\n}\n\nfunction selectBinding(element) {\n  var name = element.name;\n  var attributes = element.attributeByName;\n  if (name !== 'input' && name !== 'textarea' && name !== 'select' && !attributes.contenteditable)\n    { return; }\n  var isBindableByValue = isBindable(attributes.value);\n  var isBindableByContentEditable = isBindable(attributes.contenteditable);\n  var isContentEditable = element.getAttribute('contenteditable');\n\n  // contenteditable\n  // Bind if the contenteditable is true or a binding that may become true.\n  if ((isContentEditable || isBindableByContentEditable) && isBindableByValue)\n    { return ContentEditableBinding; }\n\n  // <input>\n  if (name === 'input') {\n    var type = element.getAttribute('type');\n\n    if (type === 'radio') {\n      var isBindableByName = isBindable(attributes.name);\n      var isBindableByChecked = isBindable(attributes.checked);\n\n      // For radios we can either bind the name or checked, but not both.\n      // Name binding is handed instead.\n      if (isBindableByName && isBindableByChecked) {\n        warnIfDebug(\n          'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',\n          { ractive: element.root }\n        );\n        return RadioNameBinding;\n      }\n\n      if (isBindableByName) { return RadioNameBinding; }\n\n      if (isBindableByChecked) { return RadioBinding; }\n\n      // Dead end. Unknown binding on radio input.\n      return null;\n    }\n\n    if (type === 'checkbox') {\n      var isBindableByName$1 = isBindable(attributes.name);\n      var isBindableByChecked$1 = isBindable(attributes.checked);\n\n      // A checkbox with bindings for both name and checked. Checked treated as\n      // the checkbox value, name is treated as a regular binding.\n      //\n      // See https://github.com/ractivejs/ractive/issues/1749\n      if (isBindableByName$1 && isBindableByChecked$1) { return CheckboxBinding; }\n\n      if (isBindableByName$1) { return CheckboxNameBinding; }\n\n      if (isBindableByChecked$1) { return CheckboxBinding; }\n\n      // Dead end. Unknown binding on checkbox input.\n      return null;\n    }\n\n    if (type === 'file' && isBindableByValue) { return FileBinding; }\n\n    if (type === 'number' && isBindableByValue) { return NumericBinding; }\n\n    if (type === 'range' && isBindableByValue) { return NumericBinding; }\n\n    // Some input of unknown type (browser usually falls back to text).\n    if (isBindableByValue) { return GenericBinding; }\n\n    // Dead end. Some unknown input and an unbindable.\n    return null;\n  }\n\n  // <select>\n  if (name === 'select' && isBindableByValue) {\n    return element.getAttribute('multiple') ? MultipleSelectBinding : SingleSelectBinding;\n  }\n\n  // <textarea>\n  if (name === 'textarea' && isBindableByValue) { return GenericBinding; }\n\n  // Dead end. Some unbindable element.\n  return null;\n}\n\nvar endsWithSemi = /;\\s*$/;\n\nvar Element = (function (ContainerItem) {\n  function Element(options) {\n    var this$1 = this;\n\n    ContainerItem.call(this, options);\n\n    this.name = options.template.e.toLowerCase();\n\n    // find parent element\n    this.parent = findElement(this.up, false);\n\n    if (this.parent && this.parent.name === 'option') {\n      throw new Error(\n        (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\")\n      );\n    }\n\n    this.decorators = [];\n\n    // create attributes\n    this.attributeByName = {};\n\n    var attrs;\n    var n, attr, val, cls, name, template, leftovers;\n\n    var m = this.template.m;\n    var len = (m && m.length) || 0;\n\n    for (var i = 0; i < len; i++) {\n      template = m[i];\n      if (template.g) {\n        (this$1.statics || (this$1.statics = {}))[template.n] = isString(template.f)\n          ? template.f\n          : template.n;\n      } else {\n        switch (template.t) {\n          case ATTRIBUTE:\n          case BINDING_FLAG:\n          case DECORATOR:\n          case EVENT:\n          case TRANSITION:\n            attr = createItem({\n              owner: this$1,\n              up: this$1.up,\n              template: template\n            });\n\n            n = template.n;\n\n            attrs = attrs || (attrs = this$1.attributes = []);\n\n            if (n === 'value') { val = attr; }\n            else if (n === 'name') { name = attr; }\n            else if (n === 'class') { cls = attr; }\n            else { attrs.push(attr); }\n\n            break;\n\n          case DELEGATE_FLAG:\n            this$1.delegate = false;\n            break;\n\n          default:\n            (leftovers || (leftovers = [])).push(template);\n            break;\n        }\n      }\n    }\n\n    if (val) { attrs.push(val); }\n    if (name) { attrs.push(name); }\n    if (cls) { attrs.unshift(cls); }\n\n    if (leftovers) {\n      (attrs || (this.attributes = [])).push(\n        new ConditionalAttribute({\n          owner: this,\n          up: this.up,\n          template: leftovers\n        })\n      );\n\n      // empty leftovers array\n      leftovers = [];\n    }\n\n    // create children\n    if (options.template.f && !options.deferContent) {\n      this.fragment = new Fragment({\n        template: options.template.f,\n        owner: this,\n        cssIds: null\n      });\n    }\n\n    this.binding = null; // filled in later\n  }\n\n  if ( ContainerItem ) Element.__proto__ = ContainerItem;\n  var Element__proto__ = Element.prototype = Object.create( ContainerItem && ContainerItem.prototype );\n  Element__proto__.constructor = Element;\n\n  Element__proto__.bind = function bind () {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.binding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].bind(); }\n      attrs.binding = false;\n    }\n\n    if (this.fragment) { this.fragment.bind(); }\n\n    // create two-way binding if necessary\n    if (!this.binding) { this.recreateTwowayBinding(); }\n    else { this.binding.bind(); }\n  };\n\n  Element__proto__.createTwowayBinding = function createTwowayBinding () {\n    if ('twoway' in this ? this.twoway : this.ractive.twoway) {\n      var Binding = selectBinding(this);\n      if (Binding) {\n        var binding = new Binding(this);\n        if (binding && binding.model) { return binding; }\n      }\n    }\n  };\n\n  Element__proto__.destroyed = function destroyed$1 () {\n    if (this.attributes) { this.attributes.forEach(destroyed); }\n    if (this.fragment) { this.fragment.destroyed(); }\n  };\n\n  Element__proto__.detach = function detach () {\n    // if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n    if (!this.rendered) { this.destroyed(); }\n\n    return detachNode(this.node);\n  };\n\n  Element__proto__.find = function find (selector, options) {\n    if (this.node && matches(this.node, selector)) { return this.node; }\n    if (this.fragment) {\n      return this.fragment.find(selector, options);\n    }\n  };\n\n  Element__proto__.findAll = function findAll (selector, options) {\n    var result = options.result;\n\n    if (matches(this.node, selector)) {\n      result.push(this.node);\n    }\n\n    if (this.fragment) {\n      this.fragment.findAll(selector, options);\n    }\n  };\n\n  Element__proto__.findNextNode = function findNextNode () {\n    return null;\n  };\n\n  Element__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Element__proto__.getAttribute = function getAttribute (name) {\n    if (this.statics && name in this.statics) { return this.statics[name]; }\n    var attribute = this.attributeByName[name];\n    return attribute ? attribute.getValue() : undefined;\n  };\n\n  Element__proto__.getContext = function getContext () {\n    var assigns = [], len = arguments.length;\n    while ( len-- ) assigns[ len ] = arguments[ len ];\n\n    if (this.fragment) { return (ref = this.fragment).getContext.apply(ref, assigns); }\n\n    if (!this.ctx) { this.ctx = new Context(this.up, this); }\n    assigns.unshift(create(this.ctx));\n    return assign.apply(null, assigns);\n    var ref;\n  };\n\n  Element__proto__.off = function off (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = this.listeners && this.listeners[event];\n\n    if (!ref) { return; }\n    removeFromArray(ref, callback);\n\n    if (delegate) {\n      var listeners =\n        (delegate.listeners || (delegate.listeners = [])) &&\n        (delegate.listeners[event] || (delegate.listeners[event] = []));\n      if (listeners.refs && !--listeners.refs) { delegate.off(event, delegateHandler, true); }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        rem.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, true);\n        add.call(n, event, handler, false);\n      }\n    }\n  };\n\n  Element__proto__.on = function on (event, callback, capture) {\n    if ( capture === void 0 ) capture = false;\n\n    var delegate = this.up.delegate;\n    var ref = (this.listeners || (this.listeners = {}))[event] || (this.listeners[event] = []);\n\n    if (delegate) {\n      var listeners =\n        ((delegate.listeners || (delegate.listeners = [])) && delegate.listeners[event]) ||\n        (delegate.listeners[event] = []);\n      if (!listeners.refs) {\n        listeners.refs = 0;\n        delegate.on(event, delegateHandler, true);\n        listeners.refs++;\n      } else {\n        listeners.refs++;\n      }\n    } else if (this.rendered) {\n      var n = this.node;\n      var add = n.addEventListener;\n      var rem = n.removeEventListener;\n\n      if (!ref.length) {\n        add.call(n, event, handler, capture);\n      } else if (ref.length && !ref.refs && capture) {\n        rem.call(n, event, handler, false);\n        add.call(n, event, handler, true);\n      }\n    }\n\n    addToArray(this.listeners[event], callback);\n  };\n\n  Element__proto__.recreateTwowayBinding = function recreateTwowayBinding () {\n    if (this.binding) {\n      this.binding.unbind();\n      this.binding.unrender();\n    }\n\n    if ((this.binding = this.createTwowayBinding())) {\n      this.binding.bind();\n      if (this.rendered) { this.binding.render(); }\n    }\n  };\n\n  Element__proto__.rebound = function rebound (update$$1) {\n    ContainerItem.prototype.rebound.call(this, update$$1);\n    if (this.attributes) { this.attributes.forEach(function (x) { return x.rebound(update$$1); }); }\n    if (this.binding) { this.binding.rebound(update$$1); }\n  };\n\n  Element__proto__.render = function render (target, occupants) {\n    var this$1 = this;\n\n    // TODO determine correct namespace\n    this.namespace = getNamespace(this);\n\n    var node;\n    var existing = false;\n\n    if (occupants) {\n      var n;\n      while ((n = occupants.shift())) {\n        if (\n          n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() &&\n          n.namespaceURI === this$1.namespace\n        ) {\n          this$1.node = node = n;\n          existing = true;\n          break;\n        } else {\n          detachNode(n);\n        }\n      }\n    }\n\n    if (!existing && this.node) {\n      node = this.node;\n      target.appendChild(node);\n      existing = true;\n    }\n\n    if (!node) {\n      var name = this.template.e;\n      node = createElement(\n        this.namespace === html ? name.toLowerCase() : name,\n        this.namespace,\n        this.getAttribute('is')\n      );\n      this.node = node;\n    }\n\n    // tie the node to this vdom element\n    defineProperty(node, '_ractive', {\n      value: {\n        proxy: this\n      },\n      configurable: true\n    });\n\n    if (this.statics) {\n      keys(this.statics).forEach(function (k) {\n        node.setAttribute(k, this$1.statics[k]);\n      });\n    }\n\n    if (existing && this.foundNode) { this.foundNode(node); }\n\n    // register intro before rendering content so children can find the intro\n    var intro = this.intro;\n    if (intro && intro.shouldFire('intro')) {\n      intro.isIntro = true;\n      intro.isOutro = false;\n      runloop.registerTransition(intro);\n    }\n\n    if (this.fragment) {\n      var children = existing ? toArray(node.childNodes) : undefined;\n\n      this.fragment.render(node, children);\n\n      // clean up leftover children\n      if (children) {\n        children.forEach(detachNode);\n      }\n    }\n\n    if (existing) {\n      // store initial values for two-way binding\n      if (this.binding && this.binding.wasUndefined) { this.binding.setFromNode(node); }\n      // remove unused attributes\n      var i = node.attributes.length;\n      while (i--) {\n        var name$1 = node.attributes[i].name;\n        if (!(name$1 in this$1.attributeByName) && (!this$1.statics || !(name$1 in this$1.statics)))\n          { node.removeAttribute(name$1); }\n      }\n    }\n\n    // Is this a top-level node of a component? If so, we may need to add\n    // a data-ractive-css attribute, for CSS encapsulation\n    if (this.up.cssIds) {\n      node.setAttribute('data-ractive-css', this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' '));\n    }\n\n    if (this.attributes) {\n      var len = this.attributes.length;\n      for (var i$1 = 0; i$1 < len; i$1++) { this$1.attributes[i$1].render(); }\n    }\n    if (this.binding) { this.binding.render(); }\n\n    if (!this.up.delegate && this.listeners) {\n      var ls = this.listeners;\n      for (var k in ls) {\n        if (ls[k] && ls[k].length) { this$1.node.addEventListener(k, handler, !!ls[k].refs); }\n      }\n    }\n\n    if (!existing) {\n      target.appendChild(node);\n    }\n\n    this.rendered = true;\n  };\n\n  Element__proto__.toString = function toString () {\n    var this$1 = this;\n\n    var tagName = this.template.e;\n\n    var attrs = (this.attributes && this.attributes.map(stringifyAttribute).join('')) || '';\n\n    if (this.statics)\n      { keys(this.statics).forEach(\n        function (k) { return k !== 'class' &&\n          k !== 'style' &&\n          (attrs = \" \" + k + \"=\\\"\" + (safeAttributeString(this$1.statics[k])) + \"\\\"\" + attrs); }\n      ); }\n\n    // Special case - selected options\n    if (this.name === 'option' && this.isSelected()) {\n      attrs += ' selected';\n    }\n\n    // Special case - two-way radio name bindings\n    if (this.name === 'input' && inputIsCheckedRadio(this)) {\n      attrs += ' checked';\n    }\n\n    // Special case style and class attributes and directives\n    var style = this.statics ? this.statics.style : undefined;\n    var cls = this.statics ? this.statics.class : undefined;\n    this.attributes &&\n      this.attributes.forEach(function (attr) {\n        if (attr.name === 'class') {\n          cls = (cls || '') + (cls ? ' ' : '') + safeAttributeString(attr.getString());\n        } else if (attr.name === 'style') {\n          style = (style || '') + (style ? ' ' : '') + safeAttributeString(attr.getString());\n          if (style && !endsWithSemi.test(style)) { style += ';'; }\n        } else if (attr.style) {\n          style =\n            (style || '') +\n            (style ? ' ' : '') +\n            (attr.style) + \": \" + (safeAttributeString(attr.getString())) + \";\";\n        } else if (attr.inlineClass && attr.getValue()) {\n          cls = (cls || '') + (cls ? ' ' : '') + attr.inlineClass;\n        }\n      });\n    // put classes first, then inline style\n    if (style !== undefined) { attrs = ' style' + (style ? (\"=\\\"\" + style + \"\\\"\") : '') + attrs; }\n    if (cls !== undefined) { attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs; }\n\n    if (this.up.cssIds) {\n      attrs += \" data-ractive-css=\\\"\" + (this.up.cssIds.map(function (x) { return (\"{\" + x + \"}\"); }).join(' ')) + \"\\\"\";\n    }\n\n    var str = \"<\" + tagName + attrs + \">\";\n\n    if (voidElements[this.name.toLowerCase()]) { return str; }\n\n    // Special case - textarea\n    if (this.name === 'textarea' && this.getAttribute('value') !== undefined) {\n      str += escapeHtml(this.getAttribute('value'));\n    } else if (this.getAttribute('contenteditable') !== undefined) {\n      // Special case - contenteditable\n      str += this.getAttribute('value') || '';\n    }\n\n    if (this.fragment) {\n      str += this.fragment.toString(!/^(?:script|style)$/i.test(this.template.e)); // escape text unless script/style\n    }\n\n    str += \"</\" + tagName + \">\";\n    return str;\n  };\n\n  Element__proto__.unbind = function unbind (view) {\n    var attrs = this.attributes;\n    if (attrs) {\n      attrs.unbinding = true;\n      var len = attrs.length;\n      for (var i = 0; i < len; i++) { attrs[i].unbind(view); }\n      attrs.unbinding = false;\n    }\n\n    if (this.binding) { this.binding.unbind(view); }\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Element__proto__.unrender = function unrender (shouldDestroy) {\n    if (!this.rendered) { return; }\n    this.rendered = false;\n\n    // unrendering before intro completed? complete it now\n    // TODO should be an API for aborting transitions\n    var transition = this.intro;\n    if (transition && transition.complete) { transition.complete(); }\n\n    // Detach as soon as we can\n    if (this.name === 'option') {\n      // <option> elements detach immediately, so that\n      // their parent <select> element syncs correctly, and\n      // since option elements can't have transitions anyway\n      this.detach();\n    } else if (shouldDestroy) {\n      runloop.detachWhenReady(this);\n    }\n\n    // outro transition\n    var outro = this.outro;\n    if (outro && outro.shouldFire('outro')) {\n      outro.isIntro = false;\n      outro.isOutro = true;\n      runloop.registerTransition(outro);\n    }\n\n    if (this.fragment) { this.fragment.unrender(); }\n\n    if (this.binding) { this.binding.unrender(); }\n  };\n\n  Element__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n\n      var attrs = this.attributes;\n      if (attrs) {\n        var len = attrs.length;\n        for (var i = 0; i < len; i++) { attrs[i].update(); }\n      }\n\n      if (this.fragment) { this.fragment.update(); }\n    }\n  };\n\n  return Element;\n}(ContainerItem));\n\nfunction inputIsCheckedRadio(element) {\n  var nameAttr = element.attributeByName.name;\n  return (\n    element.getAttribute('type') === 'radio' &&\n    (nameAttr || {}).interpolator &&\n    element.getAttribute('value') === nameAttr.interpolator.model.get()\n  );\n}\n\nfunction stringifyAttribute(attribute) {\n  var str = attribute.toString();\n  return str ? ' ' + str : '';\n}\n\nfunction getNamespace(element) {\n  // Use specified namespace...\n  var xmlns$$1 = element.getAttribute('xmlns');\n  if (xmlns$$1) { return xmlns$$1; }\n\n  // ...or SVG namespace, if this is an <svg> element\n  if (element.name === 'svg') { return svg$1; }\n\n  var parent = element.parent;\n\n  if (parent) {\n    // ...or HTML, if the parent is a <foreignObject>\n    if (parent.name === 'foreignobject') { return html; }\n\n    // ...or inherit from the parent node\n    return parent.node.namespaceURI;\n  }\n\n  return element.ractive.el.namespaceURI;\n}\n\nfunction delegateHandler(ev) {\n  var name = ev.type;\n  var end = ev.currentTarget;\n  var endEl = end._ractive && end._ractive.proxy;\n  var node = ev.target;\n  var bubble = true;\n  var listeners;\n\n  // starting with the origin node, walk up the DOM looking for ractive nodes with a matching event listener\n  while (bubble && node && node !== end) {\n    var proxy = node._ractive && node._ractive.proxy;\n    if (proxy && proxy.up.delegate === endEl && shouldFire(ev, node, end)) {\n      listeners = proxy.listeners && proxy.listeners[name];\n\n      if (listeners) {\n        var len = listeners.length;\n        for (var i = 0; i < len; i++) { bubble = listeners[i].call(node, ev) !== false && bubble; }\n      }\n    }\n\n    node = node.parentNode || node.correspondingUseElement; // SVG with a <use> element in certain environments\n  }\n\n  return bubble;\n}\n\nvar UIEvent = win !== null ? win.UIEvent : null;\nfunction shouldFire(event, start, end) {\n  if (UIEvent && event instanceof UIEvent) {\n    var node = start;\n    while (node && node !== end) {\n      if (node.disabled) { return false; }\n      node = node.parentNode || node.correspondingUseElement;\n    }\n  }\n\n  return true;\n}\n\nfunction handler(ev) {\n  var this$1 = this;\n\n  var el = this._ractive.proxy;\n  var listeners;\n  if (el.listeners && (listeners = el.listeners[ev.type])) {\n    var len = listeners.length;\n    for (var i = 0; i < len; i++) { listeners[i].call(this$1, ev); }\n  }\n}\n\nvar Form = (function (Element) {\n  function Form(options) {\n    Element.call(this, options);\n    this.formBindings = [];\n  }\n\n  if ( Element ) Form.__proto__ = Element;\n  var Form__proto__ = Form.prototype = Object.create( Element && Element.prototype );\n  Form__proto__.constructor = Form;\n\n  Form__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.on('reset', handleReset);\n  };\n\n  Form__proto__.unrender = function unrender (shouldDestroy) {\n    this.off('reset', handleReset);\n    Element.prototype.unrender.call(this, shouldDestroy);\n  };\n\n  return Form;\n}(Element));\n\nfunction handleReset() {\n  var element = this._ractive.proxy;\n\n  runloop.start();\n  element.formBindings.forEach(updateModel);\n  runloop.end();\n}\n\nfunction updateModel(binding) {\n  binding.model.set(binding.resetValue);\n}\n\nvar DOMEvent = function DOMEvent(name, owner) {\n  if (name.indexOf('*') !== -1) {\n    fatal(\n      (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\")\n    );\n  }\n\n  this.name = name;\n  this.owner = owner;\n  this.handler = null;\n};\nvar DOMEvent__proto__ = DOMEvent.prototype;\n\nDOMEvent__proto__.bind = function bind () {};\n\nDOMEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  var name = this.name;\n\n  var register = function () {\n    var node = this$1.owner.node;\n\n    this$1.owner.on(\n      name,\n      (this$1.handler = function (event) {\n        return directive.fire({\n          node: node,\n          original: event,\n          event: event,\n          name: name\n        });\n      })\n    );\n  };\n\n  if (name !== 'load') {\n    // schedule events so that they take place after twoway binding\n    runloop.scheduleTask(register, true);\n  } else {\n    // unless its a load event\n    register();\n  }\n};\n\nDOMEvent__proto__.unbind = function unbind () {};\n\nDOMEvent__proto__.unrender = function unrender () {\n  if (this.handler) { this.owner.off(this.name, this.handler); }\n};\n\nvar CustomEvent = function CustomEvent(eventPlugin, owner, name, args) {\n  this.eventPlugin = eventPlugin;\n  this.owner = owner;\n  this.name = name;\n  this.handler = null;\n  this.args = args;\n};\nvar CustomEvent__proto__ = CustomEvent.prototype;\n\nCustomEvent__proto__.bind = function bind () {};\n\nCustomEvent__proto__.render = function render (directive) {\n    var this$1 = this;\n\n  runloop.scheduleTask(function () {\n    var node = this$1.owner.node;\n\n    this$1.handler = this$1.eventPlugin.apply(\n      this$1.owner.ractive,\n      [\n        node,\n        function (event) {\n            if ( event === void 0 ) event = {};\n\n          if (event.original) { event.event = event.original; }\n          else { event.original = event.event; }\n\n          event.name = this$1.name;\n          event.node = event.node || node;\n          return directive.fire(event);\n        }\n      ].concat(this$1.args || [])\n    );\n  });\n};\n\nCustomEvent__proto__.unbind = function unbind () {};\n\nCustomEvent__proto__.unrender = function unrender () {\n  this.handler.teardown();\n};\n\nvar RactiveEvent = function RactiveEvent(component, name) {\n  this.component = component;\n  this.name = name;\n  this.handler = null;\n};\nvar RactiveEvent__proto__ = RactiveEvent.prototype;\n\nRactiveEvent__proto__.bind = function bind (directive) {\n  var ractive = this.component.instance;\n\n  this.handler = ractive.on(this.name, function () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n    // watch for reproxy\n    if (args[0] instanceof Context) {\n      var ctx = args.shift();\n      ctx.component = ractive;\n      directive.fire(ctx, args);\n    } else {\n      directive.fire({}, args);\n    }\n\n    // cancel bubbling\n    return false;\n  });\n};\n\nRactiveEvent__proto__.render = function render () {};\n\nRactiveEvent__proto__.unbind = function unbind () {\n  this.handler.cancel();\n};\n\nRactiveEvent__proto__.unrender = function unrender () {};\n\nvar specialPattern = /^(event|arguments|@node|@event|@context)(\\..+)?$/;\nvar dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\nvar EventDirective = function EventDirective(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up, true);\n  this.template = options.template;\n  this.up = options.up;\n  this.ractive = options.up.ractive;\n  this.events = [];\n};\nvar EventDirective__proto__ = EventDirective.prototype;\n\nEventDirective__proto__.bind = function bind () {\n    var this$1 = this;\n\n  // sometimes anchors will cause an unbind without unrender\n  if (this.events.length) {\n    this.events.forEach(function (e) { return e.unrender(); });\n    this.events = [];\n  }\n\n  if (this.element.type === COMPONENT || this.element.type === ANCHOR) {\n    this.template.n.forEach(function (n) {\n      this$1.events.push(new RactiveEvent(this$1.element, n));\n    });\n  } else {\n    var args;\n    if ((args = this.template.a)) {\n      var rs = args.r.map(function (r) {\n        var model = resolveReference(this$1.up, r);\n        return model ? model.get() : undefined;\n      });\n      try {\n        args = getFunction(args.s, rs.length).apply(null, rs);\n      } catch (err) {\n        args = null;\n        warnIfDebug(\n          (\"Failed to compute args for event on-\" + (this.template.n.join('- ')) + \": \" + (err.message ||\n            err))\n        );\n      }\n    }\n\n    this.template.n.forEach(function (n) {\n      var fn = findInViewHierarchy('events', this$1.ractive, n);\n      if (fn) {\n        this$1.events.push(new CustomEvent(fn, this$1.element, n, args));\n      } else {\n        this$1.events.push(new DOMEvent(n, this$1.element));\n      }\n    });\n  }\n\n  // method calls\n  this.models = null;\n\n  addToArray(this.element.events || (this.element.events = []), this);\n\n  setupArgsFn(this, this.template);\n  if (!this.fn) { this.action = this.template.f; }\n\n  this.events.forEach(function (e) { return e.bind(this$1); });\n};\n\nEventDirective__proto__.destroyed = function destroyed () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nEventDirective__proto__.fire = function fire (event, args) {\n    var this$1 = this;\n    if ( args === void 0 ) args = [];\n\n  var context =\n    event instanceof Context && event.refire ? event : this.element.getContext(event);\n\n  if (this.fn) {\n    var values = [];\n\n    var models = resolveArgs(this, this.template, this.up, {\n      specialRef: function specialRef(ref) {\n        var specialMatch = specialPattern.exec(ref);\n        if (specialMatch) {\n          // on-click=\"foo(event.node)\"\n          return {\n            special: specialMatch[1],\n            keys: specialMatch[2] ? splitKeypath(specialMatch[2].substr(1)) : []\n          };\n        }\n\n        var dollarMatch = dollarArgsPattern.exec(ref);\n        if (dollarMatch) {\n          // on-click=\"foo($1)\"\n          return {\n            special: 'arguments',\n            keys: [dollarMatch[1] - 1].concat(\n              dollarMatch[2] ? splitKeypath(dollarMatch[2].substr(1)) : []\n            )\n          };\n        }\n      }\n    });\n\n    if (models) {\n      models.forEach(function (model) {\n        if (!model) { return values.push(undefined); }\n\n        if (model.special) {\n          var which = model.special;\n          var obj;\n\n          if (which === '@node') {\n            obj = this$1.element.node;\n          } else if (which === '@event') {\n            obj = event && event.event;\n          } else if (which === 'event') {\n            warnOnceIfDebug(\n              \"The event reference available to event directives is deprecated and should be replaced with @context and @event\"\n            );\n            obj = context;\n          } else if (which === '@context') {\n            obj = context;\n          } else {\n            obj = args;\n          }\n\n          var keys = model.keys.slice();\n\n          while (obj && keys.length) { obj = obj[keys.shift()]; }\n          return values.push(obj);\n        }\n\n        if (model.wrapper) {\n          return values.push(model.wrapperValue);\n        }\n\n        values.push(model.get());\n      });\n    }\n\n    // make event available as `this.event`\n    var ractive = this.ractive;\n    var oldEvent = ractive.event;\n\n    ractive.event = context;\n    var returned = this.fn.apply(ractive, values);\n    var result = returned.pop();\n\n    // Auto prevent and stop if return is explicitly false\n    if (result === false) {\n      var original = event ? event.original : undefined;\n      if (original) {\n        original.preventDefault && original.preventDefault();\n        original.stopPropagation && original.stopPropagation();\n      } else {\n        warnOnceIfDebug(\n          (\"handler '\" + (this.template.n.join(\n            ' '\n          )) + \"' returned false, but there is no event available to cancel\")\n        );\n      }\n    } else if (!returned.length && isArray(result) && isString(result[0])) {\n      // watch for proxy events\n      result = fireEvent(this.ractive, result.shift(), context, result);\n    }\n\n    ractive.event = oldEvent;\n\n    return result;\n  } else {\n    return fireEvent(this.ractive, this.action, context, args);\n  }\n};\n\nEventDirective__proto__.handleChange = function handleChange () {};\n\nEventDirective__proto__.render = function render () {\n    var this$1 = this;\n\n  this.events.forEach(function (e) { return e.render(this$1); });\n};\n\nEventDirective__proto__.toString = function toString () {\n  return '';\n};\n\nEventDirective__proto__.unbind = function unbind (view) {\n  removeFromArray(this.element.events, this);\n  this.events.forEach(function (e) { return e.unbind(view); });\n};\n\nEventDirective__proto__.unrender = function unrender () {\n  this.events.forEach(function (e) { return e.unrender(); });\n};\n\nvar proto$3 = EventDirective.prototype;\nproto$3.firstNode = proto$3.rebound = proto$3.update = noop;\n\nfunction progressiveText(item, target, occupants, text) {\n  if (occupants) {\n    var n = occupants[0];\n    if (n && n.nodeType === 3) {\n      var idx = n.nodeValue.indexOf(text);\n      occupants.shift();\n\n      if (idx === 0) {\n        if (n.nodeValue.length !== text.length) {\n          occupants.unshift(n.splitText(text.length));\n        }\n      } else {\n        n.nodeValue = text;\n      }\n    } else {\n      n = item.node = doc.createTextNode(text);\n      if (occupants[0]) {\n        target.insertBefore(n, occupants[0]);\n      } else {\n        target.appendChild(n);\n      }\n    }\n\n    item.node = n;\n  } else {\n    if (!item.node) { item.node = doc.createTextNode(text); }\n    target.appendChild(item.node);\n  }\n}\n\nvar ComputationChild = (function (Model) {\n  function ComputationChild(parent, key) {\n    Model.call(this, parent, key);\n\n    this.isReadonly = !this.root.ractive.syncComputedChildren;\n    this.dirty = true;\n    this.isComputed = true;\n  }\n\n  if ( Model ) ComputationChild.__proto__ = Model;\n  var ComputationChild__proto__ = ComputationChild.prototype = Object.create( Model && Model.prototype );\n  ComputationChild__proto__.constructor = ComputationChild;\n\n  var prototypeAccessors$1 = { setRoot: {} };\n\n  prototypeAccessors$1.setRoot.get = function () {\n    return this.parent.setRoot;\n  };\n\n  ComputationChild__proto__.applyValue = function applyValue (value) {\n    Model.prototype.applyValue.call(this, value);\n\n    if (!this.isReadonly) {\n      var source = this.parent;\n      // computed models don't have a shuffle method\n      while (source && source.shuffle) {\n        source = source.parent;\n      }\n\n      if (source) {\n        source.dependencies.forEach(mark);\n      }\n    }\n\n    if (this.setRoot) {\n      this.setRoot.set(this.setRoot.value);\n    }\n  };\n\n  ComputationChild__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      this.dirty = false;\n      var parentValue = this.parent.get();\n      this.value = parentValue ? parentValue[this.key] : undefined;\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    }\n\n    return (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture) && this.wrapper\n      ? this.wrapperValue\n      : this.value;\n  };\n\n  ComputationChild__proto__.handleChange = function handleChange$2 () {\n    if (this.dirty) { return; }\n    this.dirty = true;\n\n    if (this.boundValue) { this.boundValue = null; }\n\n    this.links.forEach(marked);\n    this.deps.forEach(handleChange);\n    this.children.forEach(handleChange);\n  };\n\n  ComputationChild__proto__.joinKey = function joinKey (key) {\n    if (isUndefined(key) || key === '') { return this; }\n\n    if (!hasOwn(this.childByKey, key)) {\n      var child = new ComputationChild(this, key);\n      this.children.push(child);\n      this.childByKey[key] = child;\n    }\n\n    return this.childByKey[key];\n  };\n\n  Object.defineProperties( ComputationChild__proto__, prototypeAccessors$1 );\n\n  return ComputationChild;\n}(Model));\n\n/* global console */\n/* eslint no-console:\"off\" */\n\nvar Computation = (function (Model) {\n  function Computation(parent, signature, key) {\n    Model.call(this, parent, key);\n\n    this.signature = signature;\n\n    this.isReadonly = !this.signature.setter;\n    this.isComputed = true;\n\n    this.dependencies = [];\n\n    this.children = [];\n    this.childByKey = {};\n\n    this.deps = [];\n\n    this.dirty = true;\n\n    // TODO: is there a less hackish way to do this?\n    this.shuffle = undefined;\n  }\n\n  if ( Model ) Computation.__proto__ = Model;\n  var Computation__proto__ = Computation.prototype = Object.create( Model && Model.prototype );\n  Computation__proto__.constructor = Computation;\n\n  var prototypeAccessors$2 = { setRoot: {} };\n\n  prototypeAccessors$2.setRoot.get = function () {\n    if (this.signature.setter) { return this; }\n  };\n\n  Computation__proto__.get = function get (shouldCapture, opts) {\n    if (shouldCapture) { capture(this); }\n\n    if (this.dirty) {\n      this.dirty = false;\n      var old = this.value;\n      this.value = this.getValue();\n      // this may cause a view somewhere to update, so it must be in a runloop\n      if (!runloop.active()) {\n        runloop.start();\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n        runloop.end();\n      } else {\n        if (!isEqual(old, this.value)) { this.notifyUpstream(); }\n      }\n      if (this.wrapper) { this.newWrapperValue = this.value; }\n      this.adapt();\n    }\n\n    // if capturing, this value needs to be unwrapped because it's for external use\n    return maybeBind(\n      this,\n      // if unwrap is supplied, it overrides capture\n      this.wrapper && (opts && 'unwrap' in opts ? opts.unwrap !== false : shouldCapture)\n        ? this.wrapperValue\n        : this.value,\n      !opts || opts.shouldBind !== false\n    );\n  };\n\n  Computation__proto__.getContext = function getContext () {\n    return this.parent.isRoot ? this.root.ractive : this.parent.get(false, noVirtual);\n  };\n\n  Computation__proto__.getValue = function getValue () {\n    startCapturing();\n    var result;\n\n    try {\n      result = this.signature.getter.call(this.root.ractive, this.getContext());\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n\n      // TODO this is all well and good in Chrome, but...\n      // ...also, should encapsulate this stuff better, and only\n      // show it if Ractive.DEBUG\n      if (hasConsole) {\n        if (console.groupCollapsed)\n          { console.groupCollapsed(\n            '%cshow details',\n            'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n          ); }\n        var sig = this.signature;\n        console.error(\n          ((err.name) + \": \" + (err.message) + \"\\n\\n\" + (sig.getterString) + (sig.getterUseStack ? '\\n\\n' + err.stack : ''))\n        );\n        if (console.groupCollapsed) { console.groupEnd(); }\n      }\n    }\n\n    var dependencies = stopCapturing();\n    this.setDependencies(dependencies);\n\n    return result;\n  };\n\n  Computation__proto__.mark = function mark () {\n    this.handleChange();\n  };\n\n  Computation__proto__.rebind = function rebind (next, previous) {\n    // computations will grab all of their deps again automagically\n    if (next !== previous) { this.handleChange(); }\n  };\n\n  Computation__proto__.set = function set (value) {\n    if (this.isReadonly) {\n      throw new Error((\"Cannot set read-only computed value '\" + (this.key) + \"'\"));\n    }\n\n    this.signature.setter(value);\n    this.mark();\n  };\n\n  Computation__proto__.setDependencies = function setDependencies (dependencies) {\n    var this$1 = this;\n\n    // unregister any soft dependencies we no longer have\n    var i = this.dependencies.length;\n    while (i--) {\n      var model = this$1.dependencies[i];\n      if (!~dependencies.indexOf(model)) { model.unregister(this$1); }\n    }\n\n    // and add any new ones\n    i = dependencies.length;\n    while (i--) {\n      var model$1 = dependencies[i];\n      if (!~this$1.dependencies.indexOf(model$1)) { model$1.register(this$1); }\n    }\n\n    this.dependencies = dependencies;\n  };\n\n  Computation__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    var i = this.dependencies.length;\n    while (i--) {\n      if (this$1.dependencies[i]) { this$1.dependencies[i].unregister(this$1); }\n    }\n    if (this.parent.computed[this.key] === this) { delete this.parent.computed[this.key]; }\n    Model.prototype.teardown.call(this);\n  };\n\n  Object.defineProperties( Computation__proto__, prototypeAccessors$2 );\n\n  return Computation;\n}(Model));\n\nvar prototype = Computation.prototype;\nvar child = ComputationChild.prototype;\nprototype.handleChange = child.handleChange;\nprototype.joinKey = child.joinKey;\n\nshared$1.Computation = Computation;\n\nvar ExpressionProxy = (function (Model) {\n  function ExpressionProxy(fragment, template) {\n    var this$1 = this;\n\n    Model.call(this, fragment.ractive.viewmodel, null);\n\n    this.fragment = fragment;\n    this.template = template;\n\n    this.isReadonly = true;\n    this.isComputed = true;\n    this.dirty = true;\n\n    this.fn =\n      fragment.ractive.allowExpressions === false\n        ? noop\n        : getFunction(template.s, template.r.length);\n\n    this.models = this.template.r.map(function (ref) {\n      return resolveReference(this$1.fragment, ref);\n    });\n    this.dependencies = [];\n\n    this.shuffle = undefined;\n\n    this.bubble();\n  }\n\n  if ( Model ) ExpressionProxy.__proto__ = Model;\n  var ExpressionProxy__proto__ = ExpressionProxy.prototype = Object.create( Model && Model.prototype );\n  ExpressionProxy__proto__.constructor = ExpressionProxy;\n\n  ExpressionProxy__proto__.bubble = function bubble (actuallyChanged) {\n    if ( actuallyChanged === void 0 ) actuallyChanged = true;\n\n    // refresh the keypath\n    this.keypath = undefined;\n\n    if (actuallyChanged) {\n      this.handleChange();\n    }\n  };\n\n  ExpressionProxy__proto__.getKeypath = function getKeypath () {\n    var this$1 = this;\n\n    if (!this.template) { return '@undefined'; }\n    if (!this.keypath) {\n      this.keypath =\n        '@' +\n        this.template.s.replace(/_(\\d+)/g, function (match, i) {\n          if (i >= this$1.models.length) { return match; }\n\n          var model = this$1.models[i];\n          return model ? model.getKeypath() : '@undefined';\n        });\n    }\n\n    return this.keypath;\n  };\n\n  ExpressionProxy__proto__.getValue = function getValue () {\n    var this$1 = this;\n\n    startCapturing();\n    var result;\n\n    try {\n      var params = this.models.map(function (m) { return (m ? m.get(true) : undefined); });\n      result = this.fn.apply(this.fragment.ractive, params);\n    } catch (err) {\n      warnIfDebug((\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)));\n    }\n\n    var dependencies = stopCapturing();\n    // remove missing deps\n    this.dependencies\n      .filter(function (d) { return !~dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.unregister(this$1);\n        removeFromArray(this$1.dependencies, d);\n      });\n    // register new deps\n    dependencies\n      .filter(function (d) { return !~this$1.dependencies.indexOf(d); })\n      .forEach(function (d) {\n        d.register(this$1);\n        this$1.dependencies.push(d);\n      });\n\n    return result;\n  };\n\n  ExpressionProxy__proto__.notifyUpstream = function notifyUpstream () {};\n\n  ExpressionProxy__proto__.rebind = function rebind (next, previous, safe) {\n    var idx = this.models.indexOf(previous);\n\n    if (~idx) {\n      next = rebindMatch(this.template.r[idx], next, previous);\n      if (next !== previous) {\n        previous.unregister(this);\n        this.models.splice(idx, 1, next);\n        if (next) { next.addShuffleRegister(this, 'mark'); }\n      }\n    }\n    this.bubble(!safe);\n  };\n\n  ExpressionProxy__proto__.rebound = function rebound (update) {\n    var this$1 = this;\n\n    this.models = this.template.r.map(function (ref) { return resolveReference(this$1.fragment, ref); });\n    if (update) { this.bubble(true); }\n  };\n\n  ExpressionProxy__proto__.retrieve = function retrieve () {\n    return this.get();\n  };\n\n  ExpressionProxy__proto__.teardown = function teardown () {\n    var this$1 = this;\n\n    this.fragment = undefined;\n    if (this.dependencies) { this.dependencies.forEach(function (d) { return d.unregister(this$1); }); }\n    Model.prototype.teardown.call(this);\n  };\n\n  ExpressionProxy__proto__.unreference = function unreference () {\n    Model.prototype.unreference.call(this);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregister = function unregister (dep) {\n    Model.prototype.unregister.call(this, dep);\n    collect(this);\n  };\n\n  ExpressionProxy__proto__.unregisterLink = function unregisterLink (link) {\n    Model.prototype.unregisterLink.call(this, link);\n    collect(this);\n  };\n\n  return ExpressionProxy;\n}(Model));\n\nvar prototype$1 = ExpressionProxy.prototype;\nvar computation = Computation.prototype;\nprototype$1.get = computation.get;\nprototype$1.handleChange = computation.handleChange;\nprototype$1.joinKey = computation.joinKey;\nprototype$1.mark = computation.mark;\nprototype$1.unbind = noop;\n\nfunction collect(model) {\n  if (!model.deps.length && !model.refs && !model.links.length) { model.teardown(); }\n}\n\nvar ReferenceExpressionProxy = (function (LinkModel) {\n  function ReferenceExpressionProxy(fragment, template) {\n    LinkModel.call(this, null, null, null, '@undefined');\n    this.root = fragment.ractive.viewmodel;\n    this.template = template;\n    this.rootLink = true;\n    this.template = template;\n    this.fragment = fragment;\n\n    this.rebound();\n  }\n\n  if ( LinkModel ) ReferenceExpressionProxy.__proto__ = LinkModel;\n  var ReferenceExpressionProxy__proto__ = ReferenceExpressionProxy.prototype = Object.create( LinkModel && LinkModel.prototype );\n  ReferenceExpressionProxy__proto__.constructor = ReferenceExpressionProxy;\n\n  ReferenceExpressionProxy__proto__.getKeypath = function getKeypath () {\n    return this.model ? this.model.getKeypath() : '@undefined';\n  };\n\n  ReferenceExpressionProxy__proto__.rebound = function rebound () {\n    var this$1 = this;\n\n    var fragment = this.fragment;\n    var template = this.template;\n\n    var base = (this.base = resolve(fragment, template));\n    var idx;\n\n    if (this.proxy) {\n      teardown$2(this);\n    }\n\n    var proxy = (this.proxy = {\n      rebind: function (next, previous) {\n        if (previous === base) {\n          next = rebindMatch(template, next, previous);\n          if (next !== base) {\n            this$1.base = base = next;\n          }\n        } else if (~(idx = members.indexOf(previous))) {\n          next = rebindMatch(template.m[idx].n, next, previous);\n          if (next !== members[idx]) {\n            members.splice(idx, 1, next || Missing);\n          }\n        }\n\n        if (next !== previous) {\n          previous.unregister(proxy);\n          if (next) { next.addShuffleTask(function () { return next.register(proxy); }); }\n        }\n      },\n      handleChange: function () {\n        pathChanged();\n      }\n    });\n\n    base.register(proxy);\n\n    var members = (this.members = template.m.map(function (tpl) {\n      if (isString(tpl)) {\n        return { get: function () { return tpl; } };\n      }\n\n      var model;\n\n      if (tpl.t === REFERENCE) {\n        model = resolveReference(fragment, tpl.n);\n        model.register(proxy);\n\n        return model;\n      }\n\n      model = new ExpressionProxy(fragment, tpl);\n      model.register(proxy);\n      return model;\n    }));\n\n    var pathChanged = function () {\n      var model =\n        base &&\n        base.joinAll(\n          members.reduce(function (list, m) {\n            var k = m.get();\n            if (isArray(k)) { return list.concat(k); }\n            else { list.push(escapeKey(String(k))); }\n            return list;\n          }, [])\n        );\n\n      if (model !== this$1.model) {\n        this$1.model = model;\n        this$1.relinking(model);\n        fireShuffleTasks();\n        refreshPathDeps(this$1);\n      }\n    };\n\n    pathChanged();\n  };\n\n  ReferenceExpressionProxy__proto__.teardown = function teardown () {\n    teardown$2(this);\n    LinkModel.prototype.teardown.call(this);\n  };\n\n  ReferenceExpressionProxy__proto__.unreference = function unreference () {\n    LinkModel.prototype.unreference.call(this);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  ReferenceExpressionProxy__proto__.unregister = function unregister (dep) {\n    LinkModel.prototype.unregister.call(this, dep);\n    if (!this.deps.length && !this.refs) { this.teardown(); }\n  };\n\n  return ReferenceExpressionProxy;\n}(LinkModel));\n\nfunction teardown$2(proxy) {\n  if (proxy.base) { proxy.base.unregister(proxy.proxy); }\n  if (proxy.models) {\n    proxy.models.forEach(function (m) {\n      if (m.unregister) { m.unregister(proxy); }\n    });\n  }\n}\n\nfunction refreshPathDeps(proxy) {\n  var len = proxy.deps.length;\n  var i, v;\n\n  for (i = 0; i < len; i++) {\n    v = proxy.deps[i];\n    if (v.pathChanged) { v.pathChanged(); }\n    if (v.fragment && v.fragment.pathModel) { v.fragment.pathModel.applyValue(proxy.getKeypath()); }\n  }\n\n  len = proxy.children.length;\n  for (i = 0; i < len; i++) {\n    refreshPathDeps(proxy.children[i]);\n  }\n}\n\nvar eproto = ExpressionProxy.prototype;\nvar proto$4 = ReferenceExpressionProxy.prototype;\n\nproto$4.unreference = eproto.unreference;\nproto$4.unregister = eproto.unregister;\nproto$4.unregisterLink = eproto.unregisterLink;\n\nfunction resolve(fragment, template) {\n  if (template.r) {\n    return resolveReference(fragment, template.r);\n  } else if (template.x) {\n    return new ExpressionProxy(fragment, template.x);\n  } else if (template.rx) {\n    return new ReferenceExpressionProxy(fragment, template.rx);\n  }\n}\n\nvar Mustache = (function (Item) {\n  function Mustache(options) {\n    Item.call(this, options);\n\n    if (options.owner) { this.parent = options.owner; }\n\n    this.isStatic = !!options.template.s;\n\n    this.model = null;\n    this.dirty = false;\n  }\n\n  if ( Item ) Mustache.__proto__ = Item;\n  var Mustache__proto__ = Mustache.prototype = Object.create( Item && Item.prototype );\n  Mustache__proto__.constructor = Mustache;\n\n  Mustache__proto__.bind = function bind (pre) {\n    // yield mustaches and inner contexts should resolve in container context\n    var start = this.template.y\n      ? this.template.y.containerFragment\n      : this.containerFragment || this.up;\n    // try to find a model for this view\n    var model = pre || resolve(start, this.template);\n\n    if (model) {\n      var value = model.get();\n\n      if (this.isStatic) {\n        this.model = { get: function () { return value; } };\n        model.unreference();\n        return;\n      }\n\n      model.register(this);\n      this.model = model;\n    }\n  };\n\n  Mustache__proto__.handleChange = function handleChange () {\n    this.bubble();\n  };\n\n  Mustache__proto__.rebind = function rebind (next, previous, safe) {\n    if (this.isStatic) { return; }\n\n    next = rebindMatch(this.template, next, previous, this.up);\n    if (next === this.model) { return false; }\n\n    if (this.model) {\n      this.model.unregister(this);\n    }\n    if (next) { next.addShuffleRegister(this, 'mark'); }\n    this.model = next;\n    if (!safe) { this.handleChange(); }\n    return true;\n  };\n\n  Mustache__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        // check to see if the model actually changed...\n        // yield mustaches and inner contexts should resolve in container context\n        var start = this.template.y\n          ? this.template.y.containerFragment\n          : this.containerFragment || this.up;\n        // try to find a model for this view\n        var model = resolve(start, this.template);\n        if (model !== this.model) {\n          this.model.unregister(this);\n          this.bind(model);\n        }\n      }\n\n      if (update) { this.bubble(); }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Mustache__proto__.unbind = function unbind () {\n    if (!this.isStatic) {\n      this.model && this.model.unregister(this);\n      this.model = undefined;\n    }\n  };\n\n  return Mustache;\n}(Item));\n\nfunction MustacheContainer(options) {\n  Mustache.call(this, options);\n}\n\nvar proto$5 = (MustacheContainer.prototype = Object.create(ContainerItem.prototype));\n\nassign(proto$5, Mustache.prototype, { constructor: MustacheContainer });\n\nvar Interpolator = (function (Mustache) {\n  function Interpolator () {\n    Mustache.apply(this, arguments);\n  }\n\n  if ( Mustache ) Interpolator.__proto__ = Mustache;\n  var Interpolator__proto__ = Interpolator.prototype = Object.create( Mustache && Mustache.prototype );\n  Interpolator__proto__.constructor = Interpolator;\n\n  Interpolator__proto__.bubble = function bubble () {\n    if (this.owner) { this.owner.bubble(); }\n    Mustache.prototype.bubble.call(this);\n  };\n\n  Interpolator__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Interpolator__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Interpolator__proto__.getString = function getString () {\n    return this.model ? safeToStringValue(this.model.get()) : '';\n  };\n\n  Interpolator__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    var value = (this.value = this.getString());\n\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, value);\n  };\n\n  Interpolator__proto__.toString = function toString (escape) {\n    var string = this.getString();\n    return escape ? escapeHtml(string) : string;\n  };\n\n  Interpolator__proto__.unrender = function unrender (shouldDestroy) {\n    if (shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Interpolator__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.rendered) {\n        var value = this.getString();\n        if (value !== this.value) { this.node.data = this.value = value; }\n      }\n    }\n  };\n\n  Interpolator__proto__.valueOf = function valueOf () {\n    return this.model ? this.model.get() : undefined;\n  };\n\n  return Interpolator;\n}(Mustache));\n\nvar Input = (function (Element) {\n  function Input () {\n    Element.apply(this, arguments);\n  }\n\n  if ( Element ) Input.__proto__ = Element;\n  var Input__proto__ = Input.prototype = Object.create( Element && Element.prototype );\n  Input__proto__.constructor = Input;\n\n  Input__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.node.defaultValue = this.node.value;\n  };\n  Input__proto__.compare = function compare (value, attrValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(value, attrValue);\n      }\n      if (value && attrValue) {\n        return value[comparator] == attrValue[comparator];\n      }\n    }\n    return value == attrValue;\n  };\n\n  return Input;\n}(Element));\n\n// simple JSON parser, without the restrictions of JSON parse\n// (i.e. having to double-quote keys).\n//\n// If passed a hash of values as the second argument, ${placeholders}\n// will be replaced with those values\n\nvar specials$1 = {\n  true: true,\n  false: false,\n  null: null,\n  undefined: undefined\n};\n\nvar specialsPattern = new RegExp('^(?:' + keys(specials$1).join('|') + ')');\nvar numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\nvar placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\nvar placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\nvar onlyWhitespace$1 = /^\\s*$/;\n\nvar JsonParser = Parser.extend({\n  init: function init(str, options) {\n    this.values = options.values;\n    this.sp();\n  },\n\n  postProcess: function postProcess(result) {\n    if (result.length !== 1 || !onlyWhitespace$1.test(this.leftover)) {\n      return null;\n    }\n\n    return { value: result[0].v };\n  },\n\n  converters: [\n    function getPlaceholder(parser) {\n      if (!parser.values) { return null; }\n\n      var placeholder = parser.matchPattern(placeholderAtStartPattern);\n\n      if (placeholder && hasOwn(parser.values, placeholder)) {\n        return { v: parser.values[placeholder] };\n      }\n    },\n\n    function getSpecial(parser) {\n      var special = parser.matchPattern(specialsPattern);\n      if (special) { return { v: specials$1[special] }; }\n    },\n\n    function getNumber(parser) {\n      var number = parser.matchPattern(numberPattern$1);\n      if (number) { return { v: +number }; }\n    },\n\n    function getString(parser) {\n      var stringLiteral = readStringLiteral(parser);\n      var values = parser.values;\n\n      if (stringLiteral && values) {\n        return {\n          v: stringLiteral.v.replace(placeholderPattern, function (match, $1) { return $1 in values ? values[$1] : $1; }\n          )\n        };\n      }\n\n      return stringLiteral;\n    },\n\n    function getObject(parser) {\n      if (!parser.matchString('{')) { return null; }\n\n      var result = {};\n\n      parser.sp();\n\n      if (parser.matchString('}')) {\n        return { v: result };\n      }\n\n      var pair;\n      while ((pair = getKeyValuePair(parser))) {\n        result[pair.key] = pair.value;\n\n        parser.sp();\n\n        if (parser.matchString('}')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n      }\n\n      return null;\n    },\n\n    function getArray(parser) {\n      if (!parser.matchString('[')) { return null; }\n\n      var result = [];\n\n      parser.sp();\n\n      if (parser.matchString(']')) {\n        return { v: result };\n      }\n\n      var valueToken;\n      while ((valueToken = parser.read())) {\n        result.push(valueToken.v);\n\n        parser.sp();\n\n        if (parser.matchString(']')) {\n          return { v: result };\n        }\n\n        if (!parser.matchString(',')) {\n          return null;\n        }\n\n        parser.sp();\n      }\n\n      return null;\n    }\n  ]\n});\n\nfunction getKeyValuePair(parser) {\n  parser.sp();\n\n  var key = readKey(parser);\n\n  if (!key) { return null; }\n\n  var pair = { key: key };\n\n  parser.sp();\n  if (!parser.matchString(':')) {\n    return null;\n  }\n  parser.sp();\n\n  var valueToken = parser.read();\n\n  if (!valueToken) { return null; }\n\n  pair.value = valueToken.v;\n  return pair;\n}\n\nfunction parseJSON(str, values) {\n  var parser = new JsonParser(str, { values: values });\n  return parser.result;\n}\n\nvar Mapping = (function (Item) {\n  function Mapping(options) {\n    Item.call(this, options);\n\n    this.name = options.template.n;\n\n    this.owner = options.owner || options.up.owner || options.element || findElement(options.up);\n    this.element =\n      options.element || (this.owner.attributeByName ? this.owner : findElement(options.up));\n    this.up = this.element.up; // shared\n    this.ractive = this.up.ractive;\n\n    this.element.attributeByName[this.name] = this;\n\n    this.value = options.template.f;\n  }\n\n  if ( Item ) Mapping.__proto__ = Item;\n  var Mapping__proto__ = Mapping.prototype = Object.create( Item && Item.prototype );\n  Mapping__proto__.constructor = Mapping;\n\n  Mapping__proto__.bind = function bind () {\n    var template = this.template.f;\n    var viewmodel = this.element.instance.viewmodel;\n\n    if (template === 0) {\n      // empty attributes are `true`\n      viewmodel.joinKey(this.name).set(true);\n    } else if (isString(template)) {\n      var parsed = parseJSON(template);\n      viewmodel.joinKey(this.name).set(parsed ? parsed.value : template);\n    } else if (isArray(template)) {\n      createMapping(this, true);\n    }\n  };\n\n  Mapping__proto__.rebound = function rebound (update) {\n    if (this.boundFragment) { this.boundFragment.rebound(update); }\n    if (this.link) {\n      this.model = resolve(this.up, this.template.f[0]);\n      var model = this.element.instance.viewmodel.joinAll(splitKeypath(this.name));\n      model.link(this.model, this.name, { mapping: true });\n    }\n  };\n\n  Mapping__proto__.render = function render () {};\n\n  Mapping__proto__.unbind = function unbind (view) {\n    if (this.model) { this.model.unregister(this); }\n    if (this.boundFragment) { this.boundFragment.unbind(view); }\n\n    if (this.element.bound) {\n      if (this.link.target === this.model) { this.link.owner.unlink(); }\n    }\n  };\n\n  Mapping__proto__.unrender = function unrender () {};\n\n  Mapping__proto__.update = function update () {\n    if (this.dirty) {\n      this.dirty = false;\n      if (this.boundFragment) { this.boundFragment.update(); }\n    }\n  };\n\n  return Mapping;\n}(Item));\n\nfunction createMapping(item) {\n  var template = item.template.f;\n  var viewmodel = item.element.instance.viewmodel;\n  var childData = viewmodel.value;\n\n  if (template.length === 1 && template[0].t === INTERPOLATOR) {\n    var model = resolve(item.up, template[0]);\n    var val = model.get(false);\n\n    // if the interpolator is not static\n    if (!template[0].s) {\n      item.model = model;\n      item.link = viewmodel.createLink(item.name, model, template[0].r, {\n        mapping: true\n      });\n\n      // initialize parent side of the mapping from child data\n      if (isUndefined(val) && !model.isReadonly && item.name in childData) {\n        model.set(childData[item.name]);\n      }\n    } else if (!isObjectType(val) || template[0].x) {\n      // copy non-object, non-computed vals through\n      viewmodel.joinKey(splitKeypath(item.name)).set(val);\n    } else {\n      // warn about trying to copy an object\n      warnIfDebug((\"Cannot copy non-computed object value from static mapping '\" + (item.name) + \"'\"));\n    }\n\n    // if the item isn't going to manage the model, give it a change to tear down if it's computed\n    if (model !== item.model) { model.unregister(); }\n  } else {\n    item.boundFragment = new Fragment({\n      owner: item,\n      template: template\n    }).bind();\n\n    item.model = viewmodel.joinKey(splitKeypath(item.name));\n    item.model.set(item.boundFragment.valueOf());\n\n    // item is a *bit* of a hack\n    item.boundFragment.bubble = function () {\n      Fragment.prototype.bubble.call(item.boundFragment);\n      // defer this to avoid mucking around model deps if there happens to be an expression involved\n      runloop.scheduleTask(function () {\n        item.boundFragment.update();\n        item.model.set(item.boundFragment.valueOf());\n      });\n    };\n  }\n}\n\nvar Option = (function (Element) {\n  function Option(options) {\n    var template = options.template;\n    if (!template.a) { template.a = {}; }\n\n    // If the value attribute is missing, use the element's content,\n    // as long as it isn't disabled\n    if (isUndefined(template.a.value) && !('disabled' in template.a)) {\n      template.a.value = template.f || '';\n    }\n\n    Element.call(this, options);\n\n    this.select = findElement(this.parent || this.up, false, 'select');\n  }\n\n  if ( Element ) Option.__proto__ = Element;\n  var Option__proto__ = Option.prototype = Object.create( Element && Element.prototype );\n  Option__proto__.constructor = Option;\n\n  Option__proto__.bind = function bind () {\n    if (!this.select) {\n      Element.prototype.bind.call(this);\n      return;\n    }\n\n    // If the select has a value, it overrides the `selected` attribute on\n    // this option - so we delete the attribute\n    var selectedAttribute = this.attributeByName.selected;\n    if (selectedAttribute && this.select.getAttribute('value') !== undefined) {\n      var index = this.attributes.indexOf(selectedAttribute);\n      this.attributes.splice(index, 1);\n      delete this.attributeByName.selected;\n    }\n\n    Element.prototype.bind.call(this);\n    this.select.options.push(this);\n  };\n\n  Option__proto__.bubble = function bubble () {\n    // if we're using content as value, may need to update here\n    var value = this.getAttribute('value');\n    if (this.node && this.node.value !== value) {\n      this.node._ractive.value = value;\n    }\n    Element.prototype.bubble.call(this);\n  };\n\n  Option__proto__.getAttribute = function getAttribute (name) {\n    var attribute = this.attributeByName[name];\n    return attribute\n      ? attribute.getValue()\n      : name === 'value' && this.fragment\n      ? this.fragment.valueOf()\n      : undefined;\n  };\n\n  Option__proto__.isSelected = function isSelected () {\n    var this$1 = this;\n\n    var optionValue = this.getAttribute('value');\n\n    if (isUndefined(optionValue) || !this.select) {\n      return false;\n    }\n\n    var selectValue = this.select.getAttribute('value');\n\n    if (this.select.compare(selectValue, optionValue)) {\n      return true;\n    }\n\n    if (this.select.getAttribute('multiple') && isArray(selectValue)) {\n      var i = selectValue.length;\n      while (i--) {\n        if (this$1.select.compare(selectValue[i], optionValue)) {\n          return true;\n        }\n      }\n    }\n  };\n\n  Option__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n\n    if (!this.attributeByName.value) {\n      this.node._ractive.value = this.getAttribute('value');\n    }\n  };\n\n  Option__proto__.unbind = function unbind (view) {\n    Element.prototype.unbind.call(this, view);\n\n    if (this.select) {\n      removeFromArray(this.select.options, this);\n    }\n  };\n\n  return Option;\n}(Element));\n\nfunction getPartialTemplate(ractive, name, up) {\n  // If the partial in instance or view heirarchy instances, great\n  var partial = getPartialFromRegistry(ractive, name, up || {});\n  if (partial) { return partial; }\n\n  // Does it exist on the page as a script tag?\n  partial = parser.fromId(name, { noThrow: true });\n  if (partial) {\n    // parse and register to this ractive instance\n    var parsed = parser.parseFor(partial, ractive);\n\n    // register extra partials on the ractive instance if they don't already exist\n    if (parsed.p) { fillGaps(ractive.partials, parsed.p); }\n\n    // register (and return main partial if there are others in the template)\n    return (ractive.partials[name] = parsed.t);\n  }\n}\n\nfunction getPartialFromRegistry(ractive, name, up) {\n  // if there was an instance up-hierarchy, cool\n  var partial = findParentPartial(name, up.owner);\n  if (partial) { return partial; }\n\n  // find first instance in the ractive or view hierarchy that has this partial\n  var instance = findInstance('partials', ractive, name);\n\n  if (!instance) {\n    return;\n  }\n\n  partial = instance.partials[name];\n\n  // partial is a function?\n  var fn;\n  if (isFunction(partial)) {\n    fn = partial;\n    // super partial\n    if (fn.styleSet) { return fn; }\n\n    fn = partial.bind(instance);\n    fn.isOwner = hasOwn(instance.partials, name);\n    partial = fn.call(ractive, parser);\n  }\n\n  if (!partial && partial !== '') {\n    warnIfDebug(noRegistryFunctionReturn, name, 'partial', 'partial', {\n      ractive: ractive\n    });\n    return;\n  }\n\n  // If this was added manually to the registry,\n  // but hasn't been parsed, parse it now\n  if (!parser.isParsed(partial)) {\n    // use the parseOptions of the ractive instance on which it was found\n    var parsed = parser.parseFor(partial, instance);\n\n    // Partials cannot contain nested partials!\n    // TODO add a test for this\n    if (parsed.p) {\n      warnIfDebug('Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n    }\n\n    // if fn, use instance to store result, otherwise needs to go\n    // in the correct point in prototype chain on instance or constructor\n    var target = fn ? instance : findOwner(instance, name);\n\n    // may be a template with partials, which need to be registered and main template extracted\n    target.partials[name] = partial = parsed.t;\n  }\n\n  // store for reset\n  if (fn) { partial._fn = fn; }\n\n  // if the partial is a pre-parsed template object, import any expressions and update the registry\n  if (partial.v) {\n    addFunctions(partial);\n    return (instance.partials[name] = partial.t);\n  } else {\n    return partial;\n  }\n}\n\nfunction findOwner(ractive, key) {\n  return hasOwn(ractive.partials, key) ? ractive : findConstructor(ractive.constructor, key);\n}\n\nfunction findConstructor(constructor, key) {\n  if (!constructor) {\n    return;\n  }\n  return hasOwn(constructor.partials, key) ? constructor : findConstructor(constructor.Parent, key);\n}\n\nfunction findParentPartial(name, parent) {\n  if (parent) {\n    if (\n      parent.template &&\n      parent.template.p &&\n      !isArray(parent.template.p) &&\n      hasOwn(parent.template.p, name)\n    ) {\n      return parent.template.p[name];\n    } else if (parent.up && parent.up.owner) {\n      return findParentPartial(name, parent.up.owner);\n    }\n  }\n}\n\nfunction Partial(options) {\n  MustacheContainer.call(this, options);\n\n  var tpl = options.template;\n\n  // yielder is a special form of partial that will later require special handling\n  if (tpl.t === YIELDER) {\n    this.yielder = 1;\n  } else if (tpl.t === ELEMENT) {\n    // this is a macro partial, complete with macro constructor\n    // leaving this as an element will confuse up-template searches\n    this.type = PARTIAL;\n    this.macro = options.macro;\n  }\n}\n\nvar proto$6 = (Partial.prototype = create(MustacheContainer.prototype));\n\nassign(proto$6, {\n  constructor: Partial,\n\n  bind: function bind() {\n    var template = this.template;\n\n    if (this.yielder) {\n      // the container is the instance that owns this node\n      this.container = this.up.ractive;\n      this.component = this.container.component;\n      this.containerFragment = this.up;\n\n      // normal component\n      if (this.component) {\n        // yields skip the owning instance and go straight to the surrounding context\n        this.up = this.component.up;\n\n        // {{yield}} is equivalent to {{yield content}}\n        if (!template.r && !template.x && !template.rx) { this.refName = 'content'; }\n      } else {\n        // plain-ish instance that may be attached to a parent later\n        this.fragment = new Fragment({\n          owner: this,\n          template: []\n        });\n        this.fragment.bind();\n        return;\n      }\n    }\n\n    // this is a macro/super partial\n    if (this.macro) {\n      this.fn = this.macro;\n    } else {\n      // this is a plain partial or yielder\n      if (!this.refName) { this.refName = template.r; }\n\n      // if the refName exists as a partial, this is a plain old partial reference where no model binding will happen\n      if (this.refName) {\n        partialFromValue(this, this.refName);\n      }\n\n      // this is a dynamic/inline partial\n      if (!this.partial && !this.fn) {\n        MustacheContainer.prototype.bind.call(this);\n        if (this.model) { partialFromValue(this, this.model.get()); }\n      }\n    }\n\n    if (!this.partial && !this.fn) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    createFragment(this, this.partial || []);\n\n    // macro/super partial\n    if (this.fn) { initMacro(this); }\n\n    this.fragment.bind();\n  },\n\n  bubble: function bubble() {\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.yielder) {\n        this.containerFragment.bubble();\n      } else {\n        this.up.bubble();\n      }\n    }\n  },\n\n  findNextNode: function findNextNode() {\n    return (this.containerFragment || this.up).findNextNode(this);\n  },\n\n  handleChange: function handleChange() {\n    this.dirtyTemplate = true;\n    this.externalChange = true;\n    this.bubble();\n  },\n\n  rebound: function rebound(update) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].rebound(update); });\n    }\n    MustacheContainer.prototype.rebound.call(this, update);\n  },\n\n  refreshAttrs: function refreshAttrs() {\n    var this$1 = this;\n\n    keys(this._attrs).forEach(function (k) {\n      this$1.handle.attributes[k] = !this$1._attrs[k].items.length || this$1._attrs[k].valueOf();\n    });\n  },\n\n  resetTemplate: function resetTemplate() {\n    var this$1 = this;\n\n    if (this.fn && this.proxy) {\n      this.last = 0;\n      if (this.externalChange) {\n        if (isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n        this.fn = this.proxy = null;\n      } else {\n        this.partial = this.fnTemplate;\n        return true;\n      }\n    }\n\n    this.partial = null;\n\n    if (this.refName) {\n      this.partial = getPartialTemplate(this.ractive, this.refName, this.up);\n    }\n\n    if (!this.partial && this.model) {\n      partialFromValue(this, this.model.get());\n    }\n\n    if (!this.fn) {\n      if (this.last && this.partial === this.last) { return false; }\n      else if (this.partial) {\n        this.last = this.partial;\n        contextifyTemplate(this);\n      }\n    }\n\n    this.unbindAttrs();\n\n    if (this.fn) {\n      initMacro(this);\n      if (isFunction(this.proxy.render)) { runloop.scheduleTask(function () { return this$1.proxy.render(); }); }\n    } else if (!this.partial) {\n      warnOnceIfDebug((\"Could not find template for partial '\" + (this.name) + \"'\"));\n    }\n\n    return true;\n  },\n\n  render: function render(target, occupants) {\n    if (this.fn && this.fn._cssDef && !this.fn._cssDef.applied) { applyCSS(); }\n\n    this.fragment.render(target, occupants);\n\n    if (this.proxy && isFunction(this.proxy.render)) { this.proxy.render(); }\n  },\n\n  unbind: function unbind(view) {\n    this.fragment.unbind(view);\n\n    this.unbindAttrs(view);\n\n    MustacheContainer.prototype.unbind.call(this, view);\n  },\n\n  unbindAttrs: function unbindAttrs(view) {\n    var this$1 = this;\n\n    if (this._attrs) {\n      keys(this._attrs).forEach(function (k) {\n        this$1._attrs[k].unbind(view);\n      });\n    }\n  },\n\n  unrender: function unrender(shouldDestroy) {\n    if (this.proxy && isFunction(this.proxy.teardown)) { this.proxy.teardown(); }\n\n    this.fragment.unrender(shouldDestroy);\n  },\n\n  update: function update() {\n    var this$1 = this;\n\n    var proxy = this.proxy;\n    this.updating = 1;\n\n    if (this.dirtyAttrs) {\n      this.dirtyAttrs = false;\n      keys(this._attrs).forEach(function (k) { return this$1._attrs[k].update(); });\n      this.refreshAttrs();\n      if (isFunction(proxy.update)) { proxy.update(this.handle.attributes); }\n    }\n\n    if (this.dirtyTemplate) {\n      this.dirtyTemplate = false;\n      this.resetTemplate() && this.fragment.resetTemplate(this.partial || []);\n    }\n\n    if (this.dirty) {\n      this.dirty = false;\n      if (proxy && isFunction(proxy.invalidate)) { proxy.invalidate(); }\n      this.fragment.update();\n    }\n\n    this.externalChange = false;\n    this.updating = 0;\n  }\n});\n\nfunction createFragment(self, partial) {\n  self.partial = self.last = partial;\n  contextifyTemplate(self);\n\n  var options = {\n    owner: self,\n    template: self.partial\n  };\n\n  if (self.yielder) { options.ractive = self.container.parent; }\n\n  if (self.fn) { options.cssIds = self.fn._cssIds; }\n\n  self.fragment = new Fragment(options);\n}\n\nfunction contextifyTemplate(self) {\n  if (self.template.c) {\n    self.partial = [{ t: SECTION, n: SECTION_WITH, f: self.partial }];\n    assign(self.partial[0], self.template.c);\n    if (self.yielder) { self.partial[0].y = self; }\n    else { self.partial[0].z = self.template.z; }\n  }\n}\n\nfunction partialFromValue(self, value, okToParse) {\n  var tpl = value;\n\n  if (isArray(tpl)) {\n    self.partial = tpl;\n  } else if (tpl && isObjectType(tpl)) {\n    if (isArray(tpl.t)) { self.partial = tpl.t; }\n    else if (isString(tpl.template))\n      { self.partial = parsePartial(tpl.template, tpl.template, self.ractive).t; }\n  } else if (isFunction(tpl) && tpl.styleSet) {\n    self.fn = tpl;\n    if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n  } else if (tpl != null) {\n    tpl = getPartialTemplate(self.ractive, '' + tpl, self.containerFragment || self.up);\n    if (tpl) {\n      self.name = value;\n      if (tpl.styleSet) {\n        self.fn = tpl;\n        if (self.fragment) { self.fragment.cssIds = tpl._cssIds; }\n      } else { self.partial = tpl; }\n    } else if (okToParse) {\n      self.partial = parsePartial('' + value, '' + value, self.ractive).t;\n    } else {\n      self.name = value;\n    }\n  }\n\n  return self.partial;\n}\n\nfunction setTemplate(template) {\n  partialFromValue(this, template, true);\n\n  if (!this.initing) {\n    this.dirtyTemplate = true;\n    this.fnTemplate = this.partial;\n\n    if (this.updating) {\n      this.bubble();\n      runloop.promise();\n    } else {\n      var promise = runloop.start();\n\n      this.bubble();\n      runloop.end();\n\n      return promise;\n    }\n  }\n}\n\nfunction aliasLocal(ref, name) {\n  var aliases = this.fragment.aliases || (this.fragment.aliases = {});\n  if (!name) {\n    aliases[ref] = this._data;\n  } else {\n    aliases[name] = this._data.joinAll(splitKeypath(ref));\n  }\n}\n\nvar extras = 'extra-attributes';\n\nfunction initMacro(self) {\n  var fn = self.fn;\n  var fragment = self.fragment;\n\n  // defensively copy the template in case it changes\n  var template = (self.template = assign({}, self.template));\n  var handle = (self.handle = fragment.getContext({\n    proxy: self,\n    aliasLocal: aliasLocal,\n    name: self.template.e || self.name,\n    attributes: {},\n    setTemplate: setTemplate.bind(self),\n    template: template,\n    macro: fn\n  }));\n\n  if (!template.p) { template.p = {}; }\n  template.p = handle.partials = assign({}, template.p);\n  if (!hasOwn(template.p, 'content')) { template.p.content = template.f || []; }\n\n  if (isArray(fn.attributes)) {\n    self._attrs = {};\n\n    var invalidate = function() {\n      this.dirty = true;\n      self.dirtyAttrs = true;\n      self.bubble();\n    };\n\n    if (isArray(template.m)) {\n      var attrs = template.m;\n      template.p[extras] = template.m = attrs.filter(function (a) { return !~fn.attributes.indexOf(a.n); });\n      attrs\n        .filter(function (a) { return ~fn.attributes.indexOf(a.n); })\n        .forEach(function (a) {\n          var fragment = new Fragment({\n            template: a.f,\n            owner: self\n          });\n          fragment.bubble = invalidate;\n          fragment.findFirstNode = noop;\n          self._attrs[a.n] = fragment;\n        });\n    } else {\n      template.p[extras] = [];\n    }\n  } else {\n    template.p[extras] = template.m;\n  }\n\n  if (self._attrs) {\n    keys(self._attrs).forEach(function (k) {\n      self._attrs[k].bind();\n    });\n    self.refreshAttrs();\n  }\n\n  self.initing = 1;\n  self.proxy = fn.call(self.ractive, handle, handle.attributes) || {};\n  if (!self.partial) { self.partial = []; }\n  self.fnTemplate = self.partial;\n  self.initing = 0;\n\n  contextifyTemplate(self);\n  fragment.resetTemplate(self.partial);\n}\n\nfunction parsePartial(name, partial, ractive) {\n  var parsed;\n\n  try {\n    parsed = parser.parse(partial, parser.getParseOptions(ractive));\n  } catch (e) {\n    warnIfDebug((\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)));\n  }\n\n  return parsed || { t: [] };\n}\n\nvar KeyModel = function KeyModel(value, context, instance) {\n  this.value = this.key = value;\n  this.context = context;\n  this.isReadonly = this.isKey = true;\n  this.deps = [];\n  this.links = [];\n  this.children = [];\n  this.instance = instance;\n};\nvar KeyModel__proto__ = KeyModel.prototype;\n\nKeyModel__proto__.applyValue = function applyValue (value) {\n  if (value !== this.value) {\n    this.value = this.key = value;\n    this.deps.forEach(handleChange);\n    this.links.forEach(handleChange);\n    this.children.forEach(function (c) {\n      c.applyValue(c.context.getKeypath(c.instance));\n    });\n  }\n};\n\nKeyModel__proto__.destroyed = function destroyed () {\n  if (this.upstream) { this.upstream.unregisterChild(this); }\n};\n\nKeyModel__proto__.get = function get (shouldCapture) {\n  if (shouldCapture) { capture(this); }\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.getKeypath = function getKeypath () {\n  return unescapeKey(this.value);\n};\n\nKeyModel__proto__.has = function has () {\n  return false;\n};\n\nKeyModel__proto__.rebind = function rebind (next, previous) {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) { this$1.deps[i].rebind(next, previous, false); }\n\n  i = this.links.length;\n  while (i--) { this$1.links[i].relinking(next, false); }\n};\n\nKeyModel__proto__.register = function register (dependant) {\n  this.deps.push(dependant);\n};\n\nKeyModel__proto__.registerChild = function registerChild (child) {\n  addToArray(this.children, child);\n  child.upstream = this;\n};\n\nKeyModel__proto__.registerLink = function registerLink (link) {\n  addToArray(this.links, link);\n};\n\nKeyModel__proto__.unregister = function unregister (dependant) {\n  removeFromArray(this.deps, dependant);\n};\n\nKeyModel__proto__.unregisterChild = function unregisterChild (child) {\n  removeFromArray(this.children, child);\n};\n\nKeyModel__proto__.unregisterLink = function unregisterLink (link) {\n  removeFromArray(this.links, link);\n};\n\nKeyModel.prototype.reference = noop;\nKeyModel.prototype.unreference = noop;\n\nvar keypathString = /^\"(\\\\\"|[^\"])+\"$/;\n\nvar RepeatedFragment = function RepeatedFragment(options) {\n  this.parent = options.owner.up;\n\n  // bit of a hack, so reference resolution works without another\n  // layer of indirection\n  this.up = this;\n  this.owner = options.owner;\n  this.ractive = this.parent.ractive;\n  this.delegate =\n    this.ractive.delegate !== false && (this.parent.delegate || findDelegate(this.parent));\n  // delegation disabled by directive\n  if (this.delegate && this.delegate.delegate === false) { this.delegate = false; }\n  // let the element know it's a delegate handler\n  if (this.delegate) { this.delegate.delegate = this.delegate; }\n\n  // encapsulated styles should be inherited until they get applied by an element\n  this.cssIds = 'cssIds' in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  this.context = null;\n  this.rendered = false;\n  this.iterations = [];\n\n  this.template = options.template;\n\n  this.indexRef = options.indexRef;\n  this.keyRef = options.keyRef;\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n\n  // track array versus object so updates of type rest\n  this.isArray = false;\n};\nvar RepeatedFragment__proto__ = RepeatedFragment.prototype;\n\nRepeatedFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n  this.bound = true;\n  var value = context.get();\n\n  var aliases = (this.aliases = this.owner.template.z && this.owner.template.z.slice());\n\n  var shuffler = aliases && aliases.find(function (a) { return a.n === 'shuffle'; });\n  if (shuffler && shuffler.x && shuffler.x.x) {\n    if (shuffler.x.x.s === 'true') { this.shuffler = true; }\n    else if (keypathString.test(shuffler.x.x.s))\n      { this.shuffler = splitKeypath(shuffler.x.x.s.slice(1, -1)); }\n  }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  if (this.source) { this.source.model.unbind(this.source); }\n  var source = context.isComputed && aliases && aliases.find(function (a) { return a.n === 'source'; });\n  if (source && source.x && source.x.r) {\n    var model = resolve(this, source.x);\n    this.source = {\n      handleChange: function handleChange() {},\n      rebind: function rebind(next) {\n        this.model.unregister(this);\n        this.model = next;\n        next.register(this);\n      }\n    };\n    this.source.model = model;\n    model.register(this.source);\n  }\n\n  // {{#each array}}...\n  if ((this.isArray = isArray(value))) {\n    // we can't use map, because of sparse arrays\n    this.iterations = [];\n    var max = (this.length = value.length);\n    for (var i = 0; i < max; i += 1) {\n      this$1.iterations[i] = this$1.createIteration(i, i);\n    }\n  } else if (isObject(value)) {\n    // {{#each object}}...\n    this.isArray = false;\n\n    // TODO this is a dreadful hack. There must be a neater way\n    if (this.indexRef) {\n      var refs = this.indexRef.split(',');\n      this.keyRef = refs[0];\n      this.indexRef = refs[1];\n    }\n\n    var ks = keys(value);\n    this.length = ks.length;\n\n    this.iterations = ks.map(function (key, index) {\n      return this$1.createIteration(key, index);\n    });\n  }\n\n  return this;\n};\n\nRepeatedFragment__proto__.bubble = function bubble (index) {\n  if (!this.bubbled) { this.bubbled = []; }\n  this.bubbled.push(index);\n\n  if (!this.rebounding) { this.owner.bubble(); }\n};\n\nRepeatedFragment__proto__.createIteration = function createIteration (key, index) {\n  var fragment = new Fragment({\n    owner: this,\n    template: this.template\n  });\n\n  fragment.isIteration = true;\n  fragment.delegate = this.delegate;\n\n  if (this.aliases) { fragment.aliases = {}; }\n  swizzleFragment(this, fragment, key, index);\n\n  return fragment.bind(fragment.context);\n};\n\nRepeatedFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nRepeatedFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  this.iterations.forEach(function (fragment) { return docFrag.appendChild(fragment.detach()); });\n  return docFrag;\n};\n\nRepeatedFragment__proto__.find = function find (selector, options) {\n  return findMap(this.iterations, function (i) { return i.find(selector, options); });\n};\n\nRepeatedFragment__proto__.findAll = function findAll (selector, options) {\n  return this.iterations.forEach(function (i) { return i.findAll(selector, options); });\n};\n\nRepeatedFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  return this.iterations.forEach(function (i) { return i.findAllComponents(name, options); });\n};\n\nRepeatedFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.iterations, function (i) { return i.findComponent(name, options); });\n};\n\nRepeatedFragment__proto__.findContext = function findContext () {\n  return this.context;\n};\n\nRepeatedFragment__proto__.findNextNode = function findNextNode (iteration) {\n    var this$1 = this;\n\n  if (iteration.index < this.iterations.length - 1) {\n    for (var i = iteration.index + 1; i < this.iterations.length; i++) {\n      var node = this$1.iterations[i].firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  return this.owner.findNextNode();\n};\n\nRepeatedFragment__proto__.firstNode = function firstNode (skipParent) {\n  return this.iterations[0] ? this.iterations[0].firstNode(skipParent) : null;\n};\n\nRepeatedFragment__proto__.getLast = function getLast () {\n  return this.lastModel || (this.lastModel = new KeyModel(this.length - 1));\n};\n\nRepeatedFragment__proto__.rebind = function rebind (next) {\n    var this$1 = this;\n\n  this.context = next;\n  if (this.source) { return; }\n  this.iterations.forEach(function (fragment) {\n    swizzleFragment(this$1, fragment, fragment.key, fragment.index);\n  });\n};\n\nRepeatedFragment__proto__.rebound = function rebound (update$$1) {\n    var this$1 = this;\n\n  this.context = this.owner.model;\n  this.iterations.forEach(function (f, i) {\n    f.context = contextFor(this$1, f, i);\n    f.rebound(update$$1);\n  });\n};\n\nRepeatedFragment__proto__.render = function render (target, occupants) {\n  var xs = this.iterations;\n  if (xs) {\n    var len = xs.length;\n    for (var i = 0; i < len; i++) {\n      xs[i].render(target, occupants);\n    }\n  }\n\n  this.rendered = true;\n};\n\nRepeatedFragment__proto__.shuffle = function shuffle (newIndices, merge) {\n    var this$1 = this;\n\n  if (!this.pendingNewIndices) { this.previousIterations = this.iterations.slice(); }\n\n  if (!this.pendingNewIndices) { this.pendingNewIndices = []; }\n\n  this.pendingNewIndices.push(newIndices);\n\n  var iterations = [];\n\n  newIndices.forEach(function (newIndex, oldIndex) {\n    if (newIndex === -1) { return; }\n\n    var fragment = this$1.iterations[oldIndex];\n    iterations[newIndex] = fragment;\n\n    if (newIndex !== oldIndex && fragment) {\n      fragment.dirty = true;\n      if (merge) { fragment.shouldRebind = 1; }\n    }\n  });\n\n  this.iterations = iterations;\n\n  // if merging, we're in the midst of an update already\n  if (!merge) { this.bubble(); }\n};\n\nRepeatedFragment__proto__.shuffled = function shuffled$1 () {\n  this.iterations.forEach(shuffled);\n};\n\nRepeatedFragment__proto__.toString = function toString (escape) {\n  return this.iterations ? this.iterations.map(escape ? toEscapedString : toString$1).join('') : '';\n};\n\nRepeatedFragment__proto__.unbind = function unbind (view) {\n  this.bound = false;\n  if (this.source) { this.source.model.unregister(this.source); }\n  var iterations = this.pendingNewIndices ? this.previousIterations : this.iterations;\n  var len = iterations.length;\n  for (var i = 0; i < len; i++) { iterations[i].unbind(view); }\n  return this;\n};\n\nRepeatedFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.iterations.length;\n  for (var i = 0; i < len; i++) { this$1.iterations[i].unrender(shouldDestroy); }\n  if (this.pendingNewIndices && this.previousIterations) {\n    len = this.previousIterations.length;\n    for (var i$1 = 0; i$1 < len; i$1++) { this$1.previousIterations[i$1].unrender(shouldDestroy); }\n  }\n  this.rendered = false;\n};\n\nRepeatedFragment__proto__.update = function update$3 () {\n    var this$1 = this;\n\n  if (this.pendingNewIndices) {\n    this.bubbled.length = 0;\n    this.updatePostShuffle();\n    return;\n  }\n\n  if (this.updating) { return; }\n  this.updating = true;\n\n  if (this.shuffler) {\n    var values = shuffleValues(this, this.shuffler);\n    var newIndices = buildNewIndices(this.values, values);\n    if (!newIndices.same) {\n      this.shuffle(newIndices, true);\n      this.updatePostShuffle();\n    } else {\n      this.iterations.forEach(update);\n    }\n  } else {\n    var len = this.iterations.length;\n    for (var i = 0; i < len; i++) {\n      var f = this$1.iterations[i];\n      f && f.idxModel && f.idxModel.applyValue(i);\n    }\n\n    var value = this.context.get();\n    var wasArray = this.isArray;\n\n    var toRemove;\n    var oldKeys;\n    var reset = true;\n    var i$1;\n\n    if ((this.isArray = isArray(value))) {\n      // if there's a source to map back to, make sure everything stays bound correctly\n      if (this.source) {\n        this.rebounding = 1;\n        var source = this.source.model.get();\n        this.iterations.forEach(function (f, c) {\n          if (c < value.length && f.lastValue !== value[c] && ~(i$1 = source.indexOf(value[c]))) {\n            swizzleFragment(this$1, f, c, c);\n            f.rebound(true);\n          }\n        });\n        this.rebounding = 0;\n      }\n\n      if (wasArray) {\n        reset = false;\n        if (this.iterations.length > value.length) {\n          toRemove = this.iterations.splice(value.length);\n        }\n      }\n    } else if (isObject(value) && !wasArray) {\n      reset = false;\n      toRemove = [];\n      oldKeys = {};\n      i$1 = this.iterations.length;\n\n      while (i$1--) {\n        var fragment = this$1.iterations[i$1];\n        if (fragment.key in value) {\n          oldKeys[fragment.key] = true;\n        } else {\n          this$1.iterations.splice(i$1, 1);\n          toRemove.push(fragment);\n        }\n      }\n    }\n\n    var newLength = isArray(value) ? value.length : isObject(value) ? keys(value).length : 0;\n    this.length = newLength;\n    this.updateLast();\n\n    if (reset) {\n      toRemove = this.iterations;\n      this.iterations = [];\n    }\n\n    if (toRemove) {\n      len = toRemove.length;\n      for (var i$2 = 0; i$2 < len; i$2++) { toRemove[i$2].unbind().unrender(true); }\n    }\n\n    // update the remaining ones\n    if (!reset && this.isArray && this.bubbled && this.bubbled.length) {\n      var bubbled = this.bubbled;\n      this.bubbled = [];\n      len = bubbled.length;\n      for (var i$3 = 0; i$3 < len; i$3++)\n        { this$1.iterations[bubbled[i$3]] && this$1.iterations[bubbled[i$3]].update(); }\n    } else {\n      len = this.iterations.length;\n      for (var i$4 = 0; i$4 < len; i$4++) { this$1.iterations[i$4].update(); }\n    }\n\n    // add new iterations\n    var docFrag;\n    var fragment$1;\n\n    if (newLength > this.iterations.length) {\n      docFrag = this.rendered ? createDocumentFragment() : null;\n      i$1 = this.iterations.length;\n\n      if (isArray(value)) {\n        while (i$1 < value.length) {\n          fragment$1 = this$1.createIteration(i$1, i$1);\n\n          this$1.iterations.push(fragment$1);\n          if (this$1.rendered) { fragment$1.render(docFrag); }\n\n          i$1 += 1;\n        }\n      } else if (isObject(value)) {\n        // TODO this is a dreadful hack. There must be a neater way\n        if (this.indexRef && !this.keyRef) {\n          var refs = this.indexRef.split(',');\n          this.keyRef = refs[0];\n          this.indexRef = refs[1];\n        }\n\n        keys(value).forEach(function (key) {\n          if (!oldKeys || !(key in oldKeys)) {\n            fragment$1 = this$1.createIteration(key, i$1);\n\n            this$1.iterations.push(fragment$1);\n            if (this$1.rendered) { fragment$1.render(docFrag); }\n\n            i$1 += 1;\n          }\n        });\n      }\n\n      if (this.rendered) {\n        var parentNode = this.parent.findParentNode();\n        var anchor = this.parent.findNextNode(this.owner);\n\n        parentNode.insertBefore(docFrag, anchor);\n      }\n    }\n  }\n\n  this.updating = false;\n};\n\nRepeatedFragment__proto__.updateLast = function updateLast () {\n  if (this.lastModel) { this.lastModel.applyValue(this.length - 1); }\n};\n\nRepeatedFragment__proto__.updatePostShuffle = function updatePostShuffle () {\n    var this$1 = this;\n\n  var newIndices = this.pendingNewIndices[0];\n  var parentNode = this.rendered ? this.parent.findParentNode() : null;\n  var nextNode = parentNode && this.owner.findNextNode();\n  var docFrag = parentNode ? createDocumentFragment() : null;\n\n  // map first shuffle through\n  this.pendingNewIndices.slice(1).forEach(function (indices) {\n    newIndices.forEach(function (newIndex, oldIndex) {\n      newIndices[oldIndex] = indices[newIndex];\n    });\n  });\n\n  var len = (this.length = this.context.get().length);\n  var prev = this.previousIterations;\n  var iters = this.iterations;\n  var value = this.context.get();\n  var stash = {};\n  var idx, dest, pos, next, anchor, rebound;\n\n  var map = new Array(newIndices.length);\n  newIndices.forEach(function (e, i) { return (map[e] = i); });\n\n  this.updateLast();\n\n  idx = pos = 0;\n  while (idx < len) {\n    // if there's not an existing thing to shuffle, handle that\n    if (isUndefined(map[idx])) {\n      next = iters[idx] = this$1.createIteration(idx, idx);\n      if (parentNode) {\n        anchor = prev[pos];\n        anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n        next.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      }\n\n      idx++;\n    } else {\n      dest = newIndices[pos];\n\n      if (dest === -1) {\n        // if it needs to be dropped, drop it\n        prev[pos] && prev[pos].unbind().unrender(true);\n        prev[pos++] = 0;\n      } else if (dest > idx) {\n        // if it needs to move down, stash it\n        stash[dest] = prev[pos];\n        prev[pos++] = null;\n      } else {\n        // get the fragment that goes for this idx\n        iters[idx] = next = iters[idx] || stash[idx] || this$1.createIteration(idx, idx);\n\n        // if it's an existing fragment, swizzle\n        if (stash[idx] || pos !== idx) {\n          rebound = this$1.source && next.lastValue !== value[idx];\n          swizzleFragment(this$1, next, idx, idx);\n        }\n\n        // does next need to be moved?\n        if (parentNode && (stash[idx] || !prev[pos])) {\n          anchor = prev[pos + 1];\n          anchor = (anchor && parentNode && anchor.firstNode()) || nextNode;\n\n          if (stash[idx]) {\n            parentNode.insertBefore(next.detach(), anchor);\n          } else {\n            next.render(docFrag);\n            parentNode.insertBefore(docFrag, anchor);\n          }\n        }\n\n        prev[pos++] = 0;\n        idx++;\n      }\n\n      if (next && isObjectType(next)) {\n        if (next.shouldRebind || rebound) {\n          next.rebound(rebound);\n          next.shouldRebind = 0;\n        }\n        next.update();\n        next.shuffled();\n      }\n    }\n  }\n\n  // clean up any stragglers\n  var plen = prev.length;\n  for (var i = 0; i < plen; i++) { prev[i] && prev[i].unbind().unrender(true); }\n\n  if (this.shuffler) { this.values = shuffleValues(this, this.shuffler); }\n\n  this.pendingNewIndices = null;\n  this.previousIterations = null;\n};\n\nRepeatedFragment.prototype.getContext = getContext;\nRepeatedFragment.prototype.getKeypath = getKeypath;\n\n// find the topmost delegate\nfunction findDelegate(start) {\n  var frag = start;\n  var delegate, el;\n\n  out: while (frag) {\n    // find next element\n    el = 0;\n    while (!el && frag) {\n      if (frag.owner.type === ELEMENT) { el = frag.owner; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n\n    if (el.delegate === false) { break out; }\n    delegate = el.delegate || el;\n\n    // find next repeated fragment\n    while (frag) {\n      if (frag.iterations) { break; }\n      if (frag.owner.ractive && frag.owner.ractive.delegate === false) { break out; }\n      frag = frag.parent || frag.componentParent;\n    }\n  }\n\n  return delegate;\n}\n\nfunction swizzleFragment(section, fragment, key, idx) {\n  var model = section.context ? contextFor(section, fragment, key) : undefined;\n\n  fragment.key = key;\n  fragment.index = idx;\n  fragment.context = model;\n  if (section.source) { fragment.lastValue = model && model.get(); }\n\n  if (fragment.idxModel) { fragment.idxModel.applyValue(idx); }\n  if (fragment.keyModel) { fragment.keyModel.applyValue(key); }\n  if (fragment.pathModel) {\n    fragment.pathModel.context = model;\n    fragment.pathModel.applyValue(model.getKeypath());\n  }\n  if (fragment.rootModel) {\n    fragment.rootModel.context = model;\n    fragment.rootModel.applyValue(model.getKeypath(fragment.ractive.root));\n  }\n\n  // handle any aliases\n  var aliases = fragment.aliases;\n  section.aliases &&\n    section.aliases.forEach(function (a) {\n      if (a.x.r === '.') { aliases[a.n] = model; }\n      else if (a.x.r === '@index') { aliases[a.n] = fragment.getIndex(); }\n      else if (a.x.r === '@key') { aliases[a.n] = fragment.getKey(); }\n      else if (a.x.r === '@keypath') { aliases[a.n] = fragment.getKeypath(); }\n      else if (a.x.r === '@rootpath') { aliases[a.n] = fragment.getKeypath(true); }\n    });\n}\n\nfunction shuffleValues(section, shuffler) {\n  var array = section.context.get() || [];\n  if (shuffler === true) {\n    return array.slice();\n  } else {\n    return array.map(function (v) { return shuffler.reduce(function (a, c) { return a && a[c]; }, v); });\n  }\n}\n\nfunction contextFor(section, fragment, key) {\n  if (section.source) {\n    var idx;\n    var source = section.source.model.get();\n    if (source.indexOf && ~(idx = source.indexOf(section.context.joinKey(key).get())))\n      { return section.source.model.joinKey(idx); }\n  }\n\n  return section.context.joinKey(key);\n}\n\nfunction isEmpty(value) {\n  return (\n    !value ||\n    (isArray(value) && value.length === 0) ||\n    (isObject(value) && keys(value).length === 0)\n  );\n}\n\nfunction getType(value, hasIndexRef) {\n  if (hasIndexRef || isArray(value)) { return SECTION_EACH; }\n  if (isObjectLike(value)) { return SECTION_IF_WITH; }\n  if (isUndefined(value)) { return null; }\n  return SECTION_IF;\n}\n\nvar Section = (function (MustacheContainer) {\n  function Section(options) {\n    MustacheContainer.call(this, options);\n\n    this.isAlias = options.template.t === ALIAS;\n    this.sectionType = options.template.n || (this.isAlias && SECTION_WITH) || null;\n    this.templateSectionType = this.sectionType;\n    this.subordinate = options.template.l === 1;\n    this.fragment = null;\n  }\n\n  if ( MustacheContainer ) Section.__proto__ = MustacheContainer;\n  var Section__proto__ = Section.prototype = Object.create( MustacheContainer && MustacheContainer.prototype );\n  Section__proto__.constructor = Section;\n\n  Section__proto__.bind = function bind () {\n    MustacheContainer.prototype.bind.call(this);\n\n    if (this.subordinate) {\n      this.sibling = this.up.items[this.up.items.indexOf(this) - 1];\n      this.sibling.nextSibling = this;\n    }\n\n    // if we managed to bind, we need to create children\n    if (this.model || this.isAlias) {\n      this.dirty = true;\n      this.update();\n    } else if (\n      this.sectionType &&\n      this.sectionType === SECTION_UNLESS &&\n      (!this.sibling || !this.sibling.isTruthy())\n    ) {\n      this.fragment = new Fragment({\n        owner: this,\n        template: this.template.f\n      }).bind();\n    }\n  };\n\n  Section__proto__.bubble = function bubble () {\n    if (!this.dirty && this.yield) {\n      this.dirty = true;\n      this.containerFragment.bubble();\n    } else { MustacheContainer.prototype.bubble.call(this); }\n  };\n\n  Section__proto__.detach = function detach () {\n    var frag = this.fragment || this.detached;\n    return frag ? frag.detach() : MustacheContainer.prototype.detach.call(this);\n  };\n\n  Section__proto__.isTruthy = function isTruthy () {\n    if (this.subordinate && this.sibling.isTruthy()) { return true; }\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    return !!value && (this.templateSectionType === SECTION_IF_WITH || !isEmpty(value));\n  };\n\n  Section__proto__.rebind = function rebind (next, previous, safe) {\n    if (MustacheContainer.prototype.rebind.call(this, next, previous, safe)) {\n      if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n        this.fragment.rebind(next);\n      }\n    }\n  };\n\n  Section__proto__.rebound = function rebound (update) {\n    if (this.model) {\n      if (this.model.rebound) { this.model.rebound(update); }\n      else {\n        MustacheContainer.prototype.unbind.call(this);\n        MustacheContainer.prototype.bind.call(this);\n        if (\n          this.sectionType === SECTION_WITH ||\n          this.sectionType === SECTION_IF_WITH ||\n          this.sectionType === SECTION_EACH\n        ) {\n          if (this.fragment) { this.fragment.rebind(this.model); }\n        }\n\n        if (update) { this.bubble(); }\n      }\n    }\n    if (this.fragment) { this.fragment.rebound(update); }\n  };\n\n  Section__proto__.render = function render (target, occupants) {\n    this.rendered = true;\n    if (this.fragment) { this.fragment.render(target, occupants); }\n  };\n\n  Section__proto__.shuffle = function shuffle (newIndices) {\n    if (this.fragment && this.sectionType === SECTION_EACH) {\n      this.fragment.shuffle(newIndices);\n    }\n  };\n\n  Section__proto__.unbind = function unbind (view) {\n    MustacheContainer.prototype.unbind.call(this, view);\n    if (this.fragment) { this.fragment.unbind(view); }\n  };\n\n  Section__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && this.fragment) { this.fragment.unrender(shouldDestroy); }\n    this.rendered = false;\n  };\n\n  Section__proto__.update = function update () {\n    var this$1 = this;\n\n    if (!this.dirty) { return; }\n\n    if (this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS) {\n      this.fragment.context = this.model;\n    }\n\n    if (!this.model && this.sectionType !== SECTION_UNLESS && !this.isAlias) { return; }\n\n    this.dirty = false;\n\n    var value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n    var siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n    var lastType = this.sectionType;\n\n    if (this.yield && this.yield !== value) {\n      this.up = this.containerFragment;\n      this.container = null;\n      this.yield = null;\n      if (this.rendered) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    } else if (this.rendered && !this.yield && value instanceof Context) {\n      if (this.rendered && this.fragment) { this.fragment.unbind().unrender(true); }\n      this.fragment = null;\n    }\n\n    // watch for switching section types\n    if (this.sectionType === null || this.templateSectionType === null)\n      { this.sectionType = getType(value, this.template.i); }\n    if (lastType && lastType !== this.sectionType && this.fragment) {\n      if (this.rendered) {\n        this.fragment.unbind().unrender(true);\n      }\n\n      this.fragment = null;\n    }\n\n    var newFragment;\n\n    var fragmentShouldExist =\n      this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n      this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n      (siblingFalsey &&\n        (this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy())) || // if, unless, and if-with depend on siblings and the condition\n      this.isAlias;\n\n    if (fragmentShouldExist) {\n      if (!this.fragment) { this.fragment = this.detached; }\n\n      if (this.fragment) {\n        // check for detached fragment\n        if (this.detached) {\n          attach(this, this.fragment);\n          this.detached = false;\n          this.rendered = true;\n        }\n\n        if (!this.fragment.bound) { this.fragment.bind(this.model); }\n        this.fragment.update();\n      } else {\n        if (this.sectionType === SECTION_EACH) {\n          newFragment = new RepeatedFragment({\n            owner: this,\n            template: this.template.f,\n            indexRef: this.template.i\n          }).bind(this.model);\n        } else {\n          // only with and if-with provide context - if and unless do not\n          var context =\n            this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS\n              ? this.model\n              : null;\n\n          if (value instanceof Context) {\n            this.yield = value;\n            this.containerFragment = this.up;\n            this.up = value.fragment;\n            this.container = value.ractive;\n            context = undefined;\n          }\n\n          newFragment = new Fragment({\n            owner: this,\n            template: this.template.f\n          }).bind(context);\n        }\n      }\n    } else {\n      if (this.fragment && this.rendered) {\n        if (keep !== true) {\n          this.fragment.unbind().unrender(true);\n        } else {\n          this.unrender(false);\n          this.detached = this.fragment;\n          runloop.promise().then(function () {\n            if (this$1.detached) { this$1.detach(); }\n          });\n        }\n      } else if (this.fragment) {\n        this.fragment.unbind();\n      }\n\n      this.fragment = null;\n    }\n\n    if (newFragment) {\n      if (this.rendered) {\n        attach(this, newFragment);\n      }\n\n      this.fragment = newFragment;\n    }\n\n    if (this.nextSibling) {\n      this.nextSibling.dirty = true;\n      this.nextSibling.update();\n    }\n  };\n\n  return Section;\n}(MustacheContainer));\n\nfunction attach(section, fragment) {\n  var anchor = (section.containerFragment || section.up).findNextNode(section);\n\n  if (anchor) {\n    var docFrag = createDocumentFragment();\n    fragment.render(docFrag);\n\n    anchor.parentNode.insertBefore(docFrag, anchor);\n  } else {\n    fragment.render(section.up.findParentNode());\n  }\n}\n\nvar Select = (function (Element) {\n  function Select(options) {\n    Element.call(this, options);\n    this.options = [];\n  }\n\n  if ( Element ) Select.__proto__ = Element;\n  var Select__proto__ = Select.prototype = Object.create( Element && Element.prototype );\n  Select__proto__.constructor = Select;\n\n  Select__proto__.foundNode = function foundNode (node) {\n    if (this.binding) {\n      var selectedOptions = getSelectedOptions(node);\n\n      if (selectedOptions.length > 0) {\n        this.selectedOptions = selectedOptions;\n      }\n    }\n  };\n\n  Select__proto__.render = function render (target, occupants) {\n    Element.prototype.render.call(this, target, occupants);\n    this.sync();\n\n    var node = this.node;\n\n    var i = node.options.length;\n    while (i--) {\n      node.options[i].defaultSelected = node.options[i].selected;\n    }\n\n    this.rendered = true;\n  };\n\n  Select__proto__.sync = function sync () {\n    var this$1 = this;\n\n    var selectNode = this.node;\n\n    if (!selectNode) { return; }\n\n    var options = toArray(selectNode.options);\n\n    if (this.selectedOptions) {\n      options.forEach(function (o) {\n        if (this$1.selectedOptions.indexOf(o) >= 0) { o.selected = true; }\n        else { o.selected = false; }\n      });\n      this.binding.setFromNode(selectNode);\n      delete this.selectedOptions;\n      return;\n    }\n\n    var selectValue = this.getAttribute('value');\n    var isMultiple = this.getAttribute('multiple');\n    var array = isMultiple && isArray(selectValue);\n\n    // If the <select> has a specified value, that should override\n    // these options\n    if (selectValue !== undefined) {\n      var optionWasSelected;\n\n      options.forEach(function (o) {\n        var optionValue = o._ractive ? o._ractive.value : o.value;\n        var shouldSelect = isMultiple\n          ? array && this$1.valueContains(selectValue, optionValue)\n          : this$1.compare(selectValue, optionValue);\n\n        if (shouldSelect) {\n          optionWasSelected = true;\n        }\n\n        o.selected = shouldSelect;\n      });\n\n      if (!optionWasSelected && !isMultiple) {\n        if (this.binding) {\n          this.binding.forceUpdate();\n        }\n      }\n    } else if (this.binding && this.binding.forceUpdate) {\n      // Otherwise the value should be initialised according to which\n      // <option> element is selected, if twoway binding is in effect\n      this.binding.forceUpdate();\n    }\n  };\n  Select__proto__.valueContains = function valueContains (selectValue, optionValue) {\n    var this$1 = this;\n\n    var i = selectValue.length;\n    while (i--) {\n      if (this$1.compare(optionValue, selectValue[i])) { return true; }\n    }\n  };\n  Select__proto__.compare = function compare (optionValue, selectValue) {\n    var comparator = this.getAttribute('value-comparator');\n    if (comparator) {\n      if (isFunction(comparator)) {\n        return comparator(selectValue, optionValue);\n      }\n      if (selectValue && optionValue) {\n        return selectValue[comparator] == optionValue[comparator];\n      }\n    }\n    return selectValue == optionValue;\n  };\n  Select__proto__.update = function update () {\n    var dirty = this.dirty;\n    Element.prototype.update.call(this);\n    if (dirty) {\n      this.sync();\n    }\n  };\n\n  return Select;\n}(Element));\n\nvar Textarea = (function (Input) {\n  function Textarea(options) {\n    var template = options.template;\n\n    options.deferContent = true;\n\n    Input.call(this, options);\n\n    // check for single interpolator binding\n    if (!this.attributeByName.value) {\n      if (template.f && isBindable({ template: template })) {\n        (this.attributes || (this.attributes = [])).push(\n          createItem({\n            owner: this,\n            template: { t: ATTRIBUTE, f: template.f, n: 'value' },\n            up: this.up\n          })\n        );\n      } else {\n        this.fragment = new Fragment({\n          owner: this,\n          cssIds: null,\n          template: template.f\n        });\n      }\n    }\n  }\n\n  if ( Input ) Textarea.__proto__ = Input;\n  var Textarea__proto__ = Textarea.prototype = Object.create( Input && Input.prototype );\n  Textarea__proto__.constructor = Textarea;\n\n  Textarea__proto__.bubble = function bubble () {\n    var this$1 = this;\n\n    if (!this.dirty) {\n      this.dirty = true;\n\n      if (this.rendered && !this.binding && this.fragment) {\n        runloop.scheduleTask(function () {\n          this$1.dirty = false;\n          this$1.node.value = this$1.fragment.toString();\n        });\n      }\n\n      this.up.bubble(); // default behaviour\n    }\n  };\n\n  return Textarea;\n}(Input));\n\nvar Text = (function (Item) {\n  function Text(options) {\n    Item.call(this, options);\n    this.type = TEXT;\n  }\n\n  if ( Item ) Text.__proto__ = Item;\n  var Text__proto__ = Text.prototype = Object.create( Item && Item.prototype );\n  Text__proto__.constructor = Text;\n\n  Text__proto__.detach = function detach () {\n    return detachNode(this.node);\n  };\n\n  Text__proto__.firstNode = function firstNode () {\n    return this.node;\n  };\n\n  Text__proto__.render = function render (target, occupants) {\n    if (inAttributes()) { return; }\n    this.rendered = true;\n\n    progressiveText(this, target, occupants, this.template);\n  };\n\n  Text__proto__.toString = function toString (escape) {\n    return escape ? escapeHtml(this.template) : this.template;\n  };\n\n  Text__proto__.unrender = function unrender (shouldDestroy) {\n    if (this.rendered && shouldDestroy) { this.detach(); }\n    this.rendered = false;\n  };\n\n  Text__proto__.valueOf = function valueOf () {\n    return this.template;\n  };\n\n  return Text;\n}(Item));\n\nvar proto$7 = Text.prototype;\nproto$7.bind = proto$7.unbind = proto$7.update = noop;\n\nvar visible;\nvar hidden = 'hidden';\n\nif (doc) {\n  var prefix$2;\n\n  /* istanbul ignore next */\n  if (hidden in doc) {\n    prefix$2 = '';\n  } else {\n    var i$1 = vendors.length;\n    while (i$1--) {\n      var vendor = vendors[i$1];\n      hidden = vendor + 'Hidden';\n\n      if (hidden in doc) {\n        prefix$2 = vendor;\n        break;\n      }\n    }\n  }\n\n  /* istanbul ignore else */\n  if (prefix$2 !== undefined) {\n    doc.addEventListener(prefix$2 + 'visibilitychange', onChange);\n    onChange();\n  } else {\n    // gah, we're in an old browser\n    if ('onfocusout' in doc) {\n      doc.addEventListener('focusout', onHide);\n      doc.addEventListener('focusin', onShow);\n    } else {\n      win.addEventListener('pagehide', onHide);\n      win.addEventListener('blur', onHide);\n\n      win.addEventListener('pageshow', onShow);\n      win.addEventListener('focus', onShow);\n    }\n\n    visible = true; // until proven otherwise. Not ideal but hey\n  }\n}\n\nfunction onChange() {\n  visible = !doc[hidden];\n}\n\n/* istanbul ignore next */\nfunction onHide() {\n  visible = false;\n}\n\n/* istanbul ignore next */\nfunction onShow() {\n  visible = true;\n}\n\nvar prefix;\n\n/* istanbul ignore next */\nif (!isClient) {\n  prefix = null;\n} else {\n  var prefixCache = {};\n  var testStyle = createElement('div').style;\n\n  // technically this also normalizes on hyphenated styles as well\n  prefix = function(prop) {\n    if (!prefixCache[prop]) {\n      var name = hyphenateCamel(prop);\n\n      if (testStyle[prop] !== undefined) {\n        prefixCache[prop] = name;\n      } else {\n        /* istanbul ignore next */\n        // test vendors...\n        var i = vendors.length;\n        while (i--) {\n          var vendor = \"-\" + (vendors[i]) + \"-\" + name;\n          if (testStyle[vendor] !== undefined) {\n            prefixCache[prop] = vendor;\n            break;\n          }\n        }\n      }\n    }\n\n    return prefixCache[prop];\n  };\n}\n\nvar prefix$1 = prefix;\n\nvar vendorPattern = new RegExp('^(?:' + vendors.join('|') + ')([A-Z])');\n\nfunction hyphenate(str) {\n  /* istanbul ignore next */\n  if (!str) { return ''; } // edge case\n\n  /* istanbul ignore next */\n  if (vendorPattern.test(str)) { str = '-' + str; }\n\n  return str.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });\n}\n\nvar createTransitions;\n\nif (!isClient) {\n  createTransitions = null;\n} else {\n  var testStyle$1 = createElement('div').style;\n  var linear$1 = function (x) { return x; };\n\n  var canUseCssTransitions = {};\n  var cannotUseCssTransitions = {};\n\n  // determine some facts about our environment\n  var TRANSITION$1;\n  var TRANSITIONEND;\n  var CSS_TRANSITIONS_ENABLED;\n  var TRANSITION_DURATION;\n  var TRANSITION_PROPERTY;\n  var TRANSITION_TIMING_FUNCTION;\n\n  if (testStyle$1.transition !== undefined) {\n    TRANSITION$1 = 'transition';\n    TRANSITIONEND = 'transitionend';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else if (testStyle$1.webkitTransition !== undefined) {\n    TRANSITION$1 = 'webkitTransition';\n    TRANSITIONEND = 'webkitTransitionEnd';\n    CSS_TRANSITIONS_ENABLED = true;\n  } else {\n    CSS_TRANSITIONS_ENABLED = false;\n  }\n\n  if (TRANSITION$1) {\n    TRANSITION_DURATION = TRANSITION$1 + 'Duration';\n    TRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n    TRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n  }\n\n  createTransitions = function(t, to, options, changedProperties, resolve) {\n    // Wait a beat (otherwise the target styles will be applied immediately)\n    // TODO use a fastdom-style mechanism?\n    setTimeout(function () {\n      var jsTransitionsComplete;\n      var cssTransitionsComplete;\n      var cssTimeout; // eslint-disable-line prefer-const\n\n      function transitionDone() {\n        clearTimeout(cssTimeout);\n      }\n\n      function checkComplete() {\n        if (jsTransitionsComplete && cssTransitionsComplete) {\n          t.unregisterCompleteHandler(transitionDone);\n          // will changes to events and fire have an unexpected consequence here?\n          t.ractive.fire(t.name + ':end', t.node, t.isIntro);\n          resolve();\n        }\n      }\n\n      // this is used to keep track of which elements can use CSS to animate\n      // which properties\n      var hashPrefix = (t.node.namespaceURI || '') + t.node.tagName;\n\n      // need to reset transition properties\n      var style = t.node.style;\n      var previous = {\n        property: style[TRANSITION_PROPERTY],\n        timing: style[TRANSITION_TIMING_FUNCTION],\n        duration: style[TRANSITION_DURATION]\n      };\n\n      function transitionEndHandler(event) {\n        if (event.target !== t.node) { return; }\n        var index = changedProperties.indexOf(event.propertyName);\n\n        if (index !== -1) {\n          changedProperties.splice(index, 1);\n        }\n\n        if (changedProperties.length) {\n          // still transitioning...\n          return;\n        }\n\n        clearTimeout(cssTimeout);\n        cssTransitionsDone();\n      }\n\n      function cssTransitionsDone() {\n        style[TRANSITION_PROPERTY] = previous.property;\n        style[TRANSITION_TIMING_FUNCTION] = previous.duration;\n        style[TRANSITION_DURATION] = previous.timing;\n\n        t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n        cssTransitionsComplete = true;\n        checkComplete();\n      }\n\n      t.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n      // safety net in case transitionend never fires\n      cssTimeout = setTimeout(function () {\n        changedProperties = [];\n        cssTransitionsDone();\n      }, options.duration + (options.delay || 0) + 50);\n      t.registerCompleteHandler(transitionDone);\n\n      style[TRANSITION_PROPERTY] = changedProperties.join(',');\n      var easingName = hyphenate(options.easing || 'linear');\n      style[TRANSITION_TIMING_FUNCTION] = easingName;\n      var cssTiming = style[TRANSITION_TIMING_FUNCTION] === easingName;\n      style[TRANSITION_DURATION] = options.duration / 1000 + 's';\n\n      setTimeout(function () {\n        var i = changedProperties.length;\n        var hash;\n        var originalValue = null;\n        var index;\n        var propertiesToTransitionInJs = [];\n        var prop;\n        var suffix;\n        var interpolator;\n\n        while (i--) {\n          prop = changedProperties[i];\n          hash = hashPrefix + prop;\n\n          if (cssTiming && CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n            var initial = style[prop];\n            style[prop] = to[prop];\n\n            // If we're not sure if CSS transitions are supported for\n            // this tag/property combo, find out now\n            if (!(hash in canUseCssTransitions)) {\n              originalValue = t.getStyle(prop);\n\n              // if this property is transitionable in this browser,\n              // the current style will be different from the target style\n              canUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n              cannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n              // Reset, if we're going to use timers after all\n              if (cannotUseCssTransitions[hash]) {\n                style[prop] = initial;\n              }\n            }\n          }\n\n          if (!cssTiming || !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n            // we need to fall back to timer-based stuff\n            if (originalValue === null) { originalValue = t.getStyle(prop); }\n\n            // need to remove this from changedProperties, otherwise transitionEndHandler\n            // will get confused\n            index = changedProperties.indexOf(prop);\n            if (index === -1) {\n              warnIfDebug(\n                'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!',\n                { node: t.node }\n              );\n            } else {\n              changedProperties.splice(index, 1);\n            }\n\n            // TODO Determine whether this property is animatable at all\n\n            suffix = /[^\\d]*$/.exec(originalValue)[0];\n            interpolator = interpolate(parseFloat(originalValue), parseFloat(to[prop]));\n\n            // ...then kick off a timer-based transition\n            if (interpolator) {\n              propertiesToTransitionInJs.push({\n                name: prop,\n                interpolator: interpolator,\n                suffix: suffix\n              });\n            } else {\n              style[prop] = to[prop];\n            }\n\n            originalValue = null;\n          }\n        }\n\n        // javascript transitions\n        if (propertiesToTransitionInJs.length) {\n          var easing;\n\n          if (isString(options.easing)) {\n            easing = t.ractive.easing[options.easing];\n\n            if (!easing) {\n              warnOnceIfDebug(missingPlugin(options.easing, 'easing'));\n              easing = linear$1;\n            }\n          } else if (isFunction(options.easing)) {\n            easing = options.easing;\n          } else {\n            easing = linear$1;\n          }\n\n          new Ticker({\n            duration: options.duration,\n            easing: easing,\n            step: function step(pos) {\n              var i = propertiesToTransitionInJs.length;\n              while (i--) {\n                var prop = propertiesToTransitionInJs[i];\n                style[prop.name] = prop.interpolator(pos) + prop.suffix;\n              }\n            },\n            complete: function complete() {\n              jsTransitionsComplete = true;\n              checkComplete();\n            }\n          });\n        } else {\n          jsTransitionsComplete = true;\n        }\n\n        if (changedProperties.length) {\n          style[TRANSITION_PROPERTY] = changedProperties.join(',');\n        } else {\n          style[TRANSITION_PROPERTY] = 'none';\n\n          // We need to cancel the transitionEndHandler, and deal with\n          // the fact that it will never fire\n          t.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n          cssTransitionsComplete = true;\n          checkComplete();\n        }\n      }, 0);\n    }, options.delay || 0);\n  };\n}\n\nvar createTransitions$1 = createTransitions;\n\nvar getComputedStyle = win && win.getComputedStyle;\nvar resolved = Promise.resolve();\n\nvar names = {\n  t0: 'intro-outro',\n  t1: 'intro',\n  t2: 'outro'\n};\n\nvar Transition = function Transition(options) {\n  this.owner = options.owner || options.up.owner || findElement(options.up);\n  this.element = this.owner.attributeByName ? this.owner : findElement(options.up);\n  this.ractive = this.owner.ractive;\n  this.template = options.template;\n  this.up = options.up;\n  this.options = options;\n  this.onComplete = [];\n};\nvar Transition__proto__ = Transition.prototype;\n\nTransition__proto__.animateStyle = function animateStyle (style, value, options) {\n    var this$1 = this;\n\n  if (arguments.length === 4) {\n    throw new Error(\n      't.animateStyle() returns a promise - use .then() instead of passing a callback'\n    );\n  }\n\n  // Special case - page isn't visible. Don't animate anything, because\n  // that way you'll never get CSS transitionend events\n  if (!visible) {\n    this.setStyle(style, value);\n    return resolved;\n  }\n\n  var to;\n\n  if (isString(style)) {\n    to = {};\n    to[style] = value;\n  } else {\n    to = style;\n\n    // shuffle arguments\n    options = value;\n  }\n\n  return new Promise(function (fulfil) {\n    // Edge case - if duration is zero, set style synchronously and complete\n    if (!options.duration) {\n      this$1.setStyle(to);\n      fulfil();\n      return;\n    }\n\n    // Get a list of the properties we're animating\n    var propertyNames = keys(to);\n    var changedProperties = [];\n\n    // Store the current styles\n    var computedStyle = getComputedStyle(this$1.node);\n\n    var i = propertyNames.length;\n    while (i--) {\n      var prop = propertyNames[i];\n      var name = prefix$1(prop);\n\n      var current = computedStyle[prefix$1(prop)];\n\n      // record the starting points\n      var init = this$1.node.style[name];\n      if (!(name in this$1.originals)) { this$1.originals[name] = this$1.node.style[name]; }\n      this$1.node.style[name] = to[prop];\n      this$1.targets[name] = this$1.node.style[name];\n      this$1.node.style[name] = init;\n\n      // we need to know if we're actually changing anything\n      if (current != to[prop]) {\n        // use != instead of !==, so we can compare strings with numbers\n        changedProperties.push(name);\n\n        // if we happened to prefix, make sure there is a properly prefixed value\n        to[name] = to[prop];\n\n        // make the computed style explicit, so we can animate where\n        // e.g. height='auto'\n        this$1.node.style[name] = current;\n      }\n    }\n\n    // If we're not actually changing anything, the transitionend event\n    // will never fire! So we complete early\n    if (!changedProperties.length) {\n      fulfil();\n      return;\n    }\n\n    createTransitions$1(this$1, to, options, changedProperties, fulfil);\n  });\n};\n\nTransition__proto__.bind = function bind () {\n  var options = this.options;\n  var type = options.template && options.template.v;\n  if (type) {\n    if (type === 't0' || type === 't1') { this.element.intro = this; }\n    if (type === 't0' || type === 't2') { this.element.outro = this; }\n    this.eventName = names[type];\n  }\n\n  var ractive = this.owner.ractive;\n\n  this.name = options.name || options.template.n;\n\n  if (options.params) {\n    this.params = options.params;\n  }\n\n  if (isFunction(this.name)) {\n    this._fn = this.name;\n    this.name = this._fn.name;\n  } else {\n    this._fn = findInViewHierarchy('transitions', ractive, this.name);\n  }\n\n  if (!this._fn) {\n    warnOnceIfDebug(missingPlugin(this.name, 'transition'), { ractive: ractive });\n  }\n\n  setupArgsFn(this, options.template);\n};\n\nTransition__proto__.getParams = function getParams () {\n  if (this.params) { return this.params; }\n\n  // get expression args if supplied\n  if (this.fn) {\n    var values = resolveArgs(this, this.template, this.up).map(function (model) {\n      if (!model) { return undefined; }\n\n      return model.get();\n    });\n    return this.fn.apply(this.ractive, values);\n  }\n};\n\nTransition__proto__.getStyle = function getStyle (props) {\n  var computedStyle = getComputedStyle(this.node);\n\n  if (isString(props)) {\n    return computedStyle[prefix$1(props)];\n  }\n\n  if (!isArray(props)) {\n    throw new Error(\n      'Transition$getStyle must be passed a string, or an array of strings representing CSS properties'\n    );\n  }\n\n  var styles = {};\n\n  var i = props.length;\n  while (i--) {\n    var prop = props[i];\n    var value = computedStyle[prefix$1(prop)];\n\n    if (value === '0px') { value = 0; }\n    styles[prop] = value;\n  }\n\n  return styles;\n};\n\nTransition__proto__.processParams = function processParams (params, defaults) {\n  if (isNumber(params)) {\n    params = { duration: params };\n  } else if (isString(params)) {\n    if (params === 'slow') {\n      params = { duration: 600 };\n    } else if (params === 'fast') {\n      params = { duration: 200 };\n    } else {\n      params = { duration: 400 };\n    }\n  } else if (!params) {\n    params = {};\n  }\n\n  return assign({}, defaults, params);\n};\n\nTransition__proto__.registerCompleteHandler = function registerCompleteHandler (fn) {\n  addToArray(this.onComplete, fn);\n};\n\nTransition__proto__.setStyle = function setStyle (style, value) {\n    var this$1 = this;\n\n  if (isString(style)) {\n    var name = prefix$1(style);\n    if (!hasOwn(this.originals, name)) { this.originals[name] = this.node.style[name]; }\n    this.node.style[name] = value;\n    this.targets[name] = this.node.style[name];\n  } else {\n    var prop;\n    for (prop in style) {\n      if (hasOwn(style, prop)) {\n        this$1.setStyle(prop, style[prop]);\n      }\n    }\n  }\n\n  return this;\n};\n\nTransition__proto__.shouldFire = function shouldFire (type) {\n  if (!this.ractive.transitionsEnabled) { return false; }\n\n  // check for noIntro and noOutro cases, which only apply when the owner ractive is rendering and unrendering, respectively\n  if (type === 'intro' && this.ractive.rendering && nearestProp('noIntro', this.ractive, true))\n    { return false; }\n  if (type === 'outro' && this.ractive.unrendering && nearestProp('noOutro', this.ractive, false))\n    { return false; }\n\n  var params = this.getParams(); // this is an array, the params object should be the first member\n  // if there's not a parent element, this can't be nested, so roll on\n  if (!this.element.parent) { return true; }\n\n  // if there is a local param, it takes precedent\n  if (params && params[0] && isObject(params[0]) && 'nested' in params[0]) {\n    if (params[0].nested !== false) { return true; }\n  } else {\n    // use the nearest instance setting\n    // find the nearest instance that actually has a nested setting\n    if (nearestProp('nestedTransitions', this.ractive) !== false) { return true; }\n  }\n\n  // check to see if this is actually a nested transition\n  var el = this.element.parent;\n  while (el) {\n    if (el[type] && el[type].starting) { return false; }\n    el = el.parent;\n  }\n\n  return true;\n};\n\nTransition__proto__.start = function start () {\n    var this$1 = this;\n\n  var node = (this.node = this.element.node);\n  var originals = (this.originals = {}); //= node.getAttribute( 'style' );\n  var targets = (this.targets = {});\n\n  var completed;\n  var args = this.getParams();\n\n  // create t.complete() - we don't want this on the prototype,\n  // because we don't want `this` silliness when passing it as\n  // an argument\n  this.complete = function (noReset) {\n    this$1.starting = false;\n    if (completed) {\n      return;\n    }\n\n    this$1.onComplete.forEach(function (fn) { return fn(); });\n    if (!noReset && this$1.isIntro) {\n      for (var k in targets) {\n        if (node.style[k] === targets[k]) { node.style[k] = originals[k]; }\n      }\n    }\n\n    this$1._manager.remove(this$1);\n\n    completed = true;\n  };\n\n  // If the transition function doesn't exist, abort\n  if (!this._fn) {\n    this.complete();\n    return;\n  }\n\n  var promise = this._fn.apply(this.ractive, [this].concat(args));\n  if (promise) { promise.then(this.complete); }\n};\n\nTransition__proto__.toString = function toString () {\n  return '';\n};\n\nTransition__proto__.unbind = function unbind () {\n  if (!this.element.attributes.unbinding) {\n    var type = this.options && this.options.template && this.options.template.v;\n    if (type === 't0' || type === 't1') { this.element.intro = null; }\n    if (type === 't0' || type === 't2') { this.element.outro = null; }\n  }\n};\n\nTransition__proto__.unregisterCompleteHandler = function unregisterCompleteHandler (fn) {\n  removeFromArray(this.onComplete, fn);\n};\n\nvar proto$8 = Transition.prototype;\nproto$8.destroyed = proto$8.firstNode = proto$8.rebound = proto$8.render = proto$8.unrender = proto$8.update = noop;\n\nfunction nearestProp(prop, ractive, rendering) {\n  var instance = ractive;\n  while (instance) {\n    if (\n      hasOwn(instance, prop) &&\n      (isUndefined(rendering) || rendering ? instance.rendering : instance.unrendering)\n    )\n      { return instance[prop]; }\n    instance = instance.component && instance.component.ractive;\n  }\n\n  return ractive[prop];\n}\n\nvar elementCache = {};\n\nvar ieBug;\nvar ieBlacklist;\n\ntry {\n  createElement('table').innerHTML = 'foo';\n} catch (/* istanbul ignore next */ err) {\n  ieBug = true;\n\n  ieBlacklist = {\n    TABLE: ['<table class=\"x\">', '</table>'],\n    THEAD: ['<table><thead class=\"x\">', '</thead></table>'],\n    TBODY: ['<table><tbody class=\"x\">', '</tbody></table>'],\n    TR: ['<table><tr class=\"x\">', '</tr></table>'],\n    SELECT: ['<select class=\"x\">', '</select>']\n  };\n}\n\nfunction insertHtml(html$$1, node) {\n  var nodes = [];\n\n  // render 0 and false\n  if (html$$1 == null || html$$1 === '') { return nodes; }\n\n  var container;\n  var wrapper;\n  var selectedOption;\n\n  /* istanbul ignore if */\n  if (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n    container = element('DIV');\n    container.innerHTML = wrapper[0] + html$$1 + wrapper[1];\n    container = container.querySelector('.x');\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  } else if (node.namespaceURI === svg$1) {\n    container = element('DIV');\n    container.innerHTML = '<svg class=\"x\">' + html$$1 + '</svg>';\n    container = container.querySelector('.x');\n  } else if (node.tagName === 'TEXTAREA') {\n    container = createElement('div');\n\n    if (typeof container.textContent !== 'undefined') {\n      container.textContent = html$$1;\n    } else {\n      container.innerHTML = html$$1;\n    }\n  } else {\n    container = element(node.tagName);\n    container.innerHTML = html$$1;\n\n    if (container.tagName === 'SELECT') {\n      selectedOption = container.options[container.selectedIndex];\n    }\n  }\n\n  var child;\n  while ((child = container.firstChild)) {\n    nodes.push(child);\n    container.removeChild(child);\n  }\n\n  // This is really annoying. Extracting <option> nodes from the\n  // temporary container <select> causes the remaining ones to\n  // become selected. So now we have to deselect them. IE8, you\n  // amaze me. You really do\n  // ...and now Chrome too\n  var i;\n  if (node.tagName === 'SELECT') {\n    i = nodes.length;\n    while (i--) {\n      if (nodes[i] !== selectedOption) {\n        nodes[i].selected = false;\n      }\n    }\n  }\n\n  return nodes;\n}\n\nfunction element(tagName) {\n  return elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n}\n\nvar Triple = (function (Mustache) {\n  function Triple(options) {\n    Mustache.call(this, options);\n  }\n\n  if ( Mustache ) Triple.__proto__ = Mustache;\n  var Triple__proto__ = Triple.prototype = Object.create( Mustache && Mustache.prototype );\n  Triple__proto__.constructor = Triple;\n\n  Triple__proto__.detach = function detach () {\n    var docFrag = createDocumentFragment();\n    if (this.nodes) { this.nodes.forEach(function (node) { return docFrag.appendChild(node); }); }\n    return docFrag;\n  };\n\n  Triple__proto__.find = function find (selector) {\n    var this$1 = this;\n\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { return node; }\n\n      var queryResult = node.querySelector(selector);\n      if (queryResult) { return queryResult; }\n    }\n\n    return null;\n  };\n\n  Triple__proto__.findAll = function findAll (selector, options) {\n    var this$1 = this;\n\n    var result = options.result;\n    var len = this.nodes.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      var node = this$1.nodes[i];\n\n      if (node.nodeType !== 1) { continue; }\n\n      if (matches(node, selector)) { result.push(node); }\n\n      var queryAllResult = node.querySelectorAll(selector);\n      if (queryAllResult) {\n        result.push.apply(result, queryAllResult);\n      }\n    }\n  };\n\n  Triple__proto__.findComponent = function findComponent () {\n    return null;\n  };\n\n  Triple__proto__.firstNode = function firstNode () {\n    return this.rendered && this.nodes[0];\n  };\n\n  Triple__proto__.render = function render (target, occupants, anchor) {\n    var this$1 = this;\n\n    if (!this.nodes) {\n      var html = this.model ? this.model.get() : '';\n      this.nodes = insertHtml(html, target);\n    }\n\n    var nodes = this.nodes;\n\n    // progressive enhancement\n    if (occupants) {\n      var i = -1;\n      var next;\n\n      // start with the first node that should be rendered\n      while (occupants.length && (next = this.nodes[i + 1])) {\n        var n = (void 0);\n        // look through the occupants until a matching node is found\n        while ((n = occupants.shift())) {\n          var t = n.nodeType;\n\n          if (\n            t === next.nodeType &&\n            ((t === 1 && n.outerHTML === next.outerHTML) ||\n              ((t === 3 || t === 8) && n.nodeValue === next.nodeValue))\n          ) {\n            this$1.nodes.splice(++i, 1, n); // replace the generated node with the existing one\n            break;\n          } else {\n            target.removeChild(n); // remove the non-matching existing node\n          }\n        }\n      }\n\n      if (i >= 0) {\n        // update the list of remaining nodes to attach, excluding any that were replaced by existing nodes\n        nodes = this.nodes.slice(i);\n      }\n\n      // update the anchor to be the next occupant\n      if (occupants.length) { anchor = occupants[0]; }\n    }\n\n    // attach any remainging nodes to the parent\n    if (nodes.length) {\n      var frag = createDocumentFragment();\n      nodes.forEach(function (n) { return frag.appendChild(n); });\n\n      if (anchor) {\n        target.insertBefore(frag, anchor);\n      } else {\n        target.appendChild(frag);\n      }\n    }\n\n    this.rendered = true;\n  };\n\n  Triple__proto__.toString = function toString () {\n    var value = this.model && this.model.get();\n    value = value != null ? '' + value : '';\n\n    return inAttribute() ? decodeCharacterReferences(value) : value;\n  };\n\n  Triple__proto__.unrender = function unrender () {\n    if (this.nodes)\n      { this.nodes.forEach(function (node) {\n        // defer detachment until all relevant outros are done\n        runloop.detachWhenReady({\n          node: node,\n          detach: function detach() {\n            detachNode(node);\n          }\n        });\n      }); }\n    this.rendered = false;\n    this.nodes = null;\n  };\n\n  Triple__proto__.update = function update () {\n    if (this.rendered && this.dirty) {\n      this.dirty = false;\n\n      this.unrender();\n      this.render(this.up.findParentNode(), null, this.up.findNextNode(this));\n    } else {\n      // make sure to reset the dirty flag even if not rendered\n      this.dirty = false;\n    }\n  };\n\n  return Triple;\n}(Mustache));\n\n// finds the component constructor in the registry or view hierarchy registries\nfunction getComponentConstructor(ractive, name) {\n  var instance = findInstance('components', ractive, name);\n  var Component;\n\n  if (instance) {\n    Component = instance.components[name];\n\n    if (Component && !Component.isInstance) {\n      if (Component.default && Component.default.isInstance) { Component = Component.default; }\n      else if (!Component.then && isFunction(Component)) {\n        // function option, execute and store for reset\n        var fn = Component.bind(instance);\n        fn.isOwner = hasOwn(instance.components, name);\n        Component = fn();\n\n        if (!Component) {\n          warnIfDebug(noRegistryFunctionReturn, name, 'component', 'component', {\n            ractive: ractive\n          });\n          return;\n        }\n\n        if (isString(Component)) {\n          // allow string lookup\n          Component = getComponentConstructor(ractive, Component);\n        }\n\n        Component._fn = fn;\n        instance.components[name] = Component;\n      }\n    }\n  }\n\n  return Component;\n}\n\nfunction asyncProxy(promise, options) {\n  var partials = options.template.p || {};\n  var name = options.template.e;\n\n  var opts = assign({}, options, {\n    template: { t: ELEMENT, e: name },\n    macro: function macro(handle) {\n      handle.setTemplate(partials['async-loading'] || []);\n      promise.then(\n        function (cmp) {\n          options.up.ractive.components[name] = cmp;\n          if (partials['async-loaded']) {\n            handle.partials.component = [options.template];\n            handle.setTemplate(partials['async-loaded']);\n          } else {\n            handle.setTemplate([options.template]);\n          }\n        },\n        function (err) {\n          if (partials['async-failed']) {\n            handle.aliasLocal('error', 'error');\n            handle.set('@local.error', err);\n            handle.setTemplate(partials['async-failed']);\n          } else {\n            handle.setTemplate([]);\n          }\n        }\n      );\n    }\n  });\n  return new Partial(opts);\n}\n\nfunction extract(tpl, type, name) {\n  var p = tpl.f.find(function (s) { return s.t === type; });\n  if (p) {\n    if (p.n)\n      { return [\n        {\n          t: 19,\n          n: 54,\n          f: p.f || [],\n          z: [{ n: p.n, x: { r: (\"__await.\" + name) } }]\n        }\n      ]; }\n    else { return p.f || []; }\n  } else { return []; }\n}\n\nfunction Await(options) {\n  var tpl = options.template;\n\n  var success = extract(tpl, THEN, 'value');\n  var error = extract(tpl, CATCH, 'error');\n  var pending = extract(tpl, SECTION);\n  var undef = extract(tpl, ELSE);\n\n  var opts = assign({}, options, {\n    template: {\n      t: ELEMENT,\n      m: [\n        {\n          t: ATTRIBUTE,\n          n: 'for',\n          f: [{ t: INTERPOLATOR, r: tpl.r, rx: tpl.rx, x: tpl.x }]\n        }\n      ]\n    },\n    macro: function macro(handle, attrs) {\n      handle.aliasLocal('__await');\n\n      function update(attrs) {\n        if (attrs.for && isFunction(attrs.for.then)) {\n          handle.setTemplate(pending);\n\n          attrs.for.then(\n            function (v) {\n              handle.set('@local.value', v);\n              handle.setTemplate(success);\n            },\n            function (e) {\n              handle.set('@local.error', e);\n              handle.setTemplate(error);\n            }\n          );\n        } else if (isUndefined(attrs.for)) {\n          handle.setTemplate(undef);\n        } else {\n          handle.set('@local.value', attrs.for);\n          handle.setTemplate(success);\n        }\n      }\n\n      update(attrs);\n\n      return {\n        update: update\n      };\n    }\n  });\n\n  opts.macro.attributes = ['for'];\n\n  return new Partial(opts);\n}\n\nvar constructors = {};\nconstructors[ALIAS] = Section;\nconstructors[ANCHOR] = Component;\nconstructors[AWAIT] = Await;\nconstructors[DOCTYPE] = Doctype;\nconstructors[INTERPOLATOR] = Interpolator;\nconstructors[PARTIAL] = Partial;\nconstructors[SECTION] = Section;\nconstructors[TRIPLE] = Triple;\nconstructors[YIELDER] = Partial;\n\nconstructors[ATTRIBUTE] = Attribute;\nconstructors[BINDING_FLAG] = BindingFlag;\nconstructors[DECORATOR] = Decorator;\nconstructors[EVENT] = EventDirective;\nconstructors[TRANSITION] = Transition;\nconstructors[COMMENT] = Comment;\n\nvar specialElements = {\n  doctype: Doctype,\n  form: Form,\n  input: Input,\n  option: Option,\n  select: Select,\n  textarea: Textarea\n};\n\nfunction createItem(options) {\n  if (isString(options.template)) {\n    return new Text(options);\n  }\n\n  var ctor;\n  var name;\n  var type = options.template.t;\n\n  if (type === ELEMENT) {\n    name = options.template.e;\n\n    // could be a macro partial\n    ctor = findInstance('partials', options.up.ractive, name);\n    if (ctor) {\n      ctor = ctor.partials[name];\n      if (ctor.styleSet) {\n        options.macro = ctor;\n        return new Partial(options);\n      }\n    }\n\n    // could be component or element\n    ctor = getComponentConstructor(options.up.ractive, name);\n    if (ctor) {\n      if (isFunction(ctor.then)) {\n        return asyncProxy(ctor, options);\n      } else if (isFunction(ctor)) {\n        return new Component(options, ctor);\n      }\n    }\n\n    ctor = specialElements[name.toLowerCase()] || Element;\n    return new ctor(options);\n  }\n\n  var Item;\n\n  // component mappings are a special case of attribute\n  if (type === ATTRIBUTE) {\n    var el = options.owner;\n    if (!el || (el.type !== ANCHOR && el.type !== COMPONENT && el.type !== ELEMENT)) {\n      el = findElement(options.up);\n    }\n    options.element = el;\n\n    Item = el.type === COMPONENT || el.type === ANCHOR ? Mapping : Attribute;\n  } else {\n    Item = constructors[type];\n  }\n\n  if (!Item) { throw new Error((\"Unrecognised item type \" + type)); }\n\n  return new Item(options);\n}\n\n// TODO all this code needs to die\nfunction processItems(items, values, guid, counter) {\n  if ( counter === void 0 ) counter = 0;\n\n  return items\n    .map(function (item) {\n      if (item.type === TEXT) {\n        return item.template;\n      }\n\n      if (item.fragment) {\n        if (item.fragment.iterations) {\n          return item.fragment.iterations\n            .map(function (fragment) {\n              return processItems(fragment.items, values, guid, counter);\n            })\n            .join('');\n        } else {\n          return processItems(item.fragment.items, values, guid, counter);\n        }\n      }\n\n      var placeholderId = guid + \"-\" + (counter++);\n      var model = item.model || item.newModel;\n\n      values[placeholderId] = model\n        ? model.wrapper\n          ? model.wrapperValue\n          : model.get()\n        : undefined;\n\n      return '${' + placeholderId + '}';\n    })\n    .join('');\n}\n\nfunction resolveAliases(aliases, fragment, dest) {\n  if ( dest === void 0 ) dest = {};\n\n  for (var i = 0; i < aliases.length; i++) {\n    if (!dest[aliases[i].n]) {\n      var m = resolve(fragment, aliases[i].x);\n      dest[aliases[i].n] = m;\n      m.reference();\n    }\n  }\n\n  return dest;\n}\n\nvar Fragment = function Fragment(options) {\n  this.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n  this.isRoot = !options.owner.up;\n  this.parent = this.isRoot ? null : this.owner.up;\n  this.ractive = options.ractive || (this.isRoot ? options.owner : this.parent.ractive);\n\n  this.componentParent = this.isRoot && this.ractive.component ? this.ractive.component.up : null;\n  if (!this.isRoot || this.ractive.delegate) {\n    this.delegate = this.owner.containerFragment\n      ? this.owner.containerFragment && this.owner.containerFragment.delegate\n      : (this.componentParent && this.componentParent.delegate) ||\n        (this.parent && this.parent.delegate);\n  } else {\n    this.delegate = false;\n  }\n\n  this.context = null;\n  this.rendered = false;\n\n  // encapsulated styles should be inherited until they get applied by an element\n  if ('cssIds' in options) {\n    this.cssIds = options.cssIds && options.cssIds.length && options.cssIds;\n  } else {\n    this.cssIds = this.parent ? this.parent.cssIds : null;\n  }\n\n  this.dirty = false;\n  this.dirtyValue = true; // used for attribute values\n\n  this.template = options.template || [];\n  this.createItems();\n};\nvar Fragment__proto__ = Fragment.prototype;\n\nFragment__proto__.bind = function bind (context) {\n    var this$1 = this;\n\n  this.context = context;\n\n  if (this.owner.template.z) {\n    this.aliases = resolveAliases(\n      this.owner.template.z,\n      this.owner.containerFragment || this.parent\n    );\n  }\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].bind(); }\n  this.bound = true;\n\n  // in rare cases, a forced resolution (or similar) will cause the\n  // fragment to be dirty before it's even finished binding. In those\n  // cases we update immediately\n  if (this.dirty) { this.update(); }\n\n  return this;\n};\n\nFragment__proto__.bubble = function bubble () {\n  this.dirtyValue = true;\n\n  if (!this.dirty) {\n    this.dirty = true;\n\n    if (this.isRoot) {\n      // TODO encapsulate 'is component root, but not overall root' check?\n      if (this.ractive.component) {\n        this.ractive.component.bubble();\n      } else if (this.bound) {\n        runloop.addFragment(this);\n      }\n    } else {\n      this.owner.bubble(this.index);\n    }\n  }\n};\n\nFragment__proto__.createItems = function createItems () {\n    var this$1 = this;\n\n  // this is a hot code path\n  var max = this.template.length;\n  this.items = [];\n  for (var i = 0; i < max; i++) {\n    this$1.items[i] = createItem({\n      up: this$1,\n      template: this$1.template[i],\n      index: i\n    });\n  }\n};\n\nFragment__proto__.destroyed = function destroyed () {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].destroyed(); }\n  if (this.pathModel) { this.pathModel.destroyed(); }\n  if (this.rootModel) { this.rootModel.destroyed(); }\n};\n\nFragment__proto__.detach = function detach () {\n  var docFrag = createDocumentFragment();\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    docFrag.appendChild(xs[i].detach());\n  }\n  return docFrag;\n};\n\nFragment__proto__.find = function find (selector, options) {\n  return findMap(this.items, function (i) { return i.find(selector, options); });\n};\n\nFragment__proto__.findAll = function findAll (selector, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAll && i.findAll(selector, options); });\n  }\n};\n\nFragment__proto__.findComponent = function findComponent (name, options) {\n  return findMap(this.items, function (i) { return i.findComponent(name, options); });\n};\n\nFragment__proto__.findAllComponents = function findAllComponents (name, options) {\n  if (this.items) {\n    this.items.forEach(function (i) { return i.findAllComponents && i.findAllComponents(name, options); });\n  }\n};\n\nFragment__proto__.findContext = function findContext () {\n  var base = findParentWithContext(this);\n  if (!base || !base.context) { return this.ractive.viewmodel; }\n  else { return base.context; }\n};\n\nFragment__proto__.findNextNode = function findNextNode (item) {\n    var this$1 = this;\n\n  // search for the next node going forward\n  if (item) {\n    var it;\n    for (var i = item.index + 1; i < this.items.length; i++) {\n      it = this$1.items[i];\n      if (!it || !it.firstNode) { continue; }\n\n      var node = it.firstNode(true);\n      if (node) { return node; }\n    }\n  }\n\n  // if this is the root fragment, and there are no more items,\n  // it means we're at the end...\n  if (this.isRoot) {\n    if (this.ractive.component) {\n      return this.ractive.component.up.findNextNode(this.ractive.component);\n    }\n\n    // TODO possible edge case with other content\n    // appended to this.ractive.el?\n    return null;\n  }\n\n  if (this.parent) { return this.owner.findNextNode(this); } // the argument is in case the parent is a RepeatedFragment\n};\n\nFragment__proto__.findParentNode = function findParentNode () {\n  var fragment = this;\n\n  do {\n    if (fragment.owner.type === ELEMENT) {\n      return fragment.owner.node;\n    }\n\n    if (fragment.isRoot && !fragment.ractive.component) {\n      // TODO encapsulate check\n      return fragment.ractive.el;\n    }\n\n    if (fragment.owner.type === YIELDER) {\n      fragment = fragment.owner.containerFragment;\n    } else {\n      fragment = fragment.componentParent || fragment.parent; // TODO ugh\n    }\n  } while (fragment);\n\n  throw new Error('Could not find parent node'); // TODO link to issue tracker\n};\n\nFragment__proto__.firstNode = function firstNode (skipParent) {\n  var node = findMap(this.items, function (i) { return i.firstNode(true); });\n  if (node) { return node; }\n  if (skipParent) { return null; }\n\n  return this.parent.findNextNode(this.owner);\n};\n\nFragment__proto__.getKey = function getKey () {\n  return this.keyModel || (this.keyModel = new KeyModel(this.key));\n};\n\nFragment__proto__.getIndex = function getIndex () {\n  return this.idxModel || (this.idxModel = new KeyModel(this.index));\n};\n\nFragment__proto__.rebind = function rebind (next) {\n  this.context = next;\n  if (this.rootModel) { this.rootModel.context = this.context; }\n  if (this.pathModel) { this.pathModel.context = this.context; }\n};\n\nFragment__proto__.rebound = function rebound (update$$1) {\n  if (this.owner.template.z) {\n    var aliases = this.aliases;\n    for (var k in aliases) {\n      if (aliases[k].rebound) { aliases[k].rebound(update$$1); }\n      else {\n        aliases[k].unreference();\n        aliases[k] = 0;\n      }\n    }\n\n    resolveAliases(this.owner.template.z, this.owner.containerFragment || this.parent, aliases);\n  }\n\n  this.items.forEach(function (x) { return x.rebound(update$$1); });\n  if (update$$1) {\n    if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n    if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n  }\n};\n\nFragment__proto__.render = function render (target, occupants) {\n  if (this.rendered) { throw new Error('Fragment is already rendered!'); }\n  this.rendered = true;\n\n  var xs = this.items;\n  var len = xs.length;\n  for (var i = 0; i < len; i++) {\n    xs[i].render(target, occupants);\n  }\n};\n\nFragment__proto__.resetTemplate = function resetTemplate (template) {\n  var wasBound = this.bound;\n  var wasRendered = this.rendered;\n\n  // TODO ensure transitions are disabled globally during reset\n\n  if (wasBound) {\n    if (wasRendered) { this.unrender(true); }\n    this.unbind();\n  }\n\n  this.template = template;\n  this.createItems();\n\n  if (wasBound) {\n    this.bind(this.context);\n\n    if (wasRendered) {\n      var parentNode = this.findParentNode();\n      var anchor = this.findNextNode();\n\n      if (anchor) {\n        var docFrag = createDocumentFragment();\n        this.render(docFrag);\n        parentNode.insertBefore(docFrag, anchor);\n      } else {\n        this.render(parentNode);\n      }\n    }\n  }\n};\n\nFragment__proto__.shuffled = function shuffled$2 () {\n  this.items.forEach(shuffled);\n  if (this.rootModel) { this.rootModel.applyValue(this.context.getKeypath(this.ractive.root)); }\n  if (this.pathModel) { this.pathModel.applyValue(this.context.getKeypath()); }\n};\n\nFragment__proto__.toString = function toString (escape) {\n  return this.items.map(escape ? toEscapedString : toString$1).join('');\n};\n\nFragment__proto__.unbind = function unbind (view) {\n    var this$1 = this;\n\n  if (this.owner.template.z && !this.owner.yielder) {\n    for (var k in this$1.aliases) {\n      this$1.aliases[k].unreference();\n    }\n\n    this.aliases = {};\n  }\n\n  this.context = null;\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unbind(view); }\n  this.bound = false;\n\n  return this;\n};\n\nFragment__proto__.unrender = function unrender (shouldDestroy) {\n    var this$1 = this;\n\n  var len = this.items.length;\n  for (var i = 0; i < len; i++) { this$1.items[i].unrender(shouldDestroy); }\n  this.rendered = false;\n};\n\nFragment__proto__.update = function update () {\n    var this$1 = this;\n\n  if (this.dirty) {\n    if (!this.updating) {\n      this.dirty = false;\n      this.updating = true;\n      var len = this.items.length;\n      for (var i = 0; i < len; i++) { this$1.items[i].update(); }\n      this.updating = false;\n    } else if (this.isRoot) {\n      runloop.addFragmentToRoot(this);\n    }\n  }\n};\n\nFragment__proto__.valueOf = function valueOf () {\n  if (this.items.length === 1) {\n    return this.items[0].valueOf();\n  }\n\n  if (this.dirtyValue) {\n    var values = {};\n    var source = processItems(this.items, values, this.ractive._guid);\n    var parsed = parseJSON(source, values);\n\n    this.value = parsed ? parsed.value : this.toString();\n\n    this.dirtyValue = false;\n  }\n\n  return this.value;\n};\nFragment.prototype.getContext = getContext;\nFragment.prototype.getKeypath = getKeypath;\n\nfunction getKeypath(root) {\n  var base = findParentWithContext(this);\n  var model;\n  if (root) {\n    if (!this.rootModel) {\n      this.rootModel = new KeyModel(\n        this.context.getKeypath(this.ractive.root),\n        this.context,\n        this.ractive.root\n      );\n      model = this.rootModel;\n    } else { return this.rootModel; }\n  } else {\n    if (!this.pathModel) {\n      this.pathModel = new KeyModel(this.context.getKeypath(), this.context);\n      model = this.pathModel;\n    } else { return this.pathModel; }\n  }\n\n  if (base && base.context) { base.getKeypath(root).registerChild(model); }\n\n  return model;\n}\n\nfunction initialise(ractive, userOptions, options) {\n  // initialize settable computeds\n  var computed = ractive.viewmodel.computed;\n  if (computed) {\n    for (var k in computed) {\n      if (k in ractive.viewmodel.value && computed[k] && !computed[k].isReadonly) {\n        computed[k].set(ractive.viewmodel.value[k]);\n      }\n    }\n  }\n\n  // init config from Parent and options\n  config.init(ractive.constructor, ractive, userOptions);\n\n  // call any passed in plugins\n  if (isArray(userOptions.use))\n    { ractive.use.apply(ractive, userOptions.use.filter(function (p) { return !p.construct; })); }\n\n  hooks.config.fire(ractive);\n\n  hooks.init.begin(ractive);\n\n  var fragment = (ractive.fragment = createFragment$1(ractive, options));\n  if (fragment) { fragment.bind(ractive.viewmodel); }\n\n  hooks.init.end(ractive);\n\n  // general config done, set up observers\n  subscribe(ractive, userOptions, 'observe');\n\n  if (fragment) {\n    // render automatically ( if `el` is specified )\n    var el = (ractive.el = ractive.target = getElement(ractive.el || ractive.target));\n    if (el && !ractive.component) {\n      var promise = ractive.render(el, ractive.append);\n\n      if (Ractive.DEBUG_PROMISES) {\n        promise.catch(function (err) {\n          warnOnceIfDebug(\n            'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;'\n          );\n          warnIfDebug('An error happened during rendering', { ractive: ractive });\n          logIfDebug(err);\n\n          throw err;\n        });\n      }\n    }\n  }\n}\n\nfunction createFragment$1(ractive, options) {\n  if ( options === void 0 ) options = {};\n\n  if (ractive.template) {\n    var cssIds = [].concat(ractive.constructor._cssIds || [], options.cssIds || []);\n\n    return new Fragment({\n      owner: ractive,\n      template: ractive.template,\n      cssIds: cssIds\n    });\n  }\n}\n\nfunction render$1(ractive, target, anchor, occupants) {\n  // set a flag to let any transitions know that this instance is currently rendering\n  ractive.rendering = true;\n\n  var promise = runloop.start();\n  runloop.scheduleTask(function () { return hooks.render.fire(ractive); }, true);\n\n  if (ractive.fragment.rendered) {\n    throw new Error(\n      'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first'\n    );\n  }\n\n  if (ractive.destroyed) {\n    ractive.destroyed = false;\n    ractive.fragment = createFragment$1(ractive).bind(ractive.viewmodel);\n  }\n\n  anchor = getElement(anchor) || ractive.anchor;\n\n  ractive.el = ractive.target = target;\n  ractive.anchor = anchor;\n\n  // ensure encapsulated CSS is up-to-date\n  if (ractive.cssId) { applyCSS(); }\n\n  if (target) {\n    (target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(ractive);\n\n    if (anchor) {\n      var docFrag = doc.createDocumentFragment();\n      ractive.fragment.render(docFrag);\n      target.insertBefore(docFrag, anchor);\n    } else {\n      ractive.fragment.render(target, occupants);\n    }\n  }\n\n  runloop.end();\n  ractive.rendering = false;\n\n  return promise.then(function () {\n    if (ractive.torndown) { return; }\n\n    hooks.complete.fire(ractive);\n  });\n}\n\nfunction Ractive$render(target, anchor) {\n  if (this.torndown) {\n    warnIfDebug('ractive.render() was called on a Ractive instance that was already torn down');\n    return Promise.resolve();\n  }\n\n  target = getElement(target) || this.el;\n\n  if (!this.append && target) {\n    // Teardown any existing instances *before* trying to set up the new one -\n    // avoids certain weird bugs\n    var others = target.__ractive_instances__;\n    if (others) { others.forEach(teardown); }\n\n    // make sure we are the only occupants\n    if (!this.enhance) {\n      target.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n    }\n  }\n\n  var occupants = this.enhance ? toArray(target.childNodes) : null;\n  var promise = render$1(this, target, anchor, occupants);\n\n  if (occupants) {\n    while (occupants.length) { target.removeChild(occupants.pop()); }\n  }\n\n  return promise;\n}\n\nvar shouldRerender = ['template', 'partials', 'components', 'decorators', 'events'];\n\nfunction Ractive$reset(data) {\n  data = data || {};\n\n  if (!isObjectType(data)) {\n    throw new Error('The reset method takes either no arguments, or an object containing new data');\n  }\n\n  // TEMP need to tidy this up\n  data = dataConfigurator.init(this.constructor, this, { data: data });\n\n  var promise = runloop.start();\n\n  // If the root object is wrapped, try and use the wrapper's reset value\n  var wrapper = this.viewmodel.wrapper;\n  if (wrapper && wrapper.reset) {\n    if (wrapper.reset(data) === false) {\n      // reset was rejected, we need to replace the object\n      this.viewmodel.set(data);\n    }\n  } else {\n    this.viewmodel.set(data);\n  }\n\n  // reset config items and track if need to rerender\n  var changes = config.reset(this);\n  var rerender;\n\n  var i = changes.length;\n  while (i--) {\n    if (shouldRerender.indexOf(changes[i]) > -1) {\n      rerender = true;\n      break;\n    }\n  }\n\n  if (rerender) {\n    hooks.unrender.fire(this);\n    this.fragment.resetTemplate(this.template);\n    hooks.render.fire(this);\n    hooks.complete.fire(this);\n  }\n\n  runloop.end();\n\n  hooks.reset.fire(this, data);\n\n  return promise;\n}\n\nfunction collect$1(source, name, attr, dest) {\n  source.forEach(function (item) {\n    // queue to rerender if the item is a partial and the current name matches\n    if (item.type === PARTIAL && (item.refName === name || item.name === name)) {\n      item.inAttribute = attr;\n      dest.push(item);\n      return; // go no further\n    }\n\n    // if it has a fragment, process its items\n    if (item.fragment) {\n      collect$1(item.fragment.iterations || item.fragment.items, name, attr, dest);\n    } else if (isArray(item.items)) {\n      // or if it is itself a fragment, process its items\n      collect$1(item.items, name, attr, dest);\n    } else if (item.type === COMPONENT && item.instance) {\n      // or if it is a component, step in and process its items\n      // ...unless the partial is shadowed\n      if (item.instance.partials[name]) { return; }\n      collect$1(item.instance.fragment.items, name, attr, dest);\n    }\n\n    // if the item is an element, process its attributes too\n    if (item.type === ELEMENT) {\n      if (isArray(item.attributes)) {\n        collect$1(item.attributes, name, true, dest);\n      }\n    }\n  });\n}\n\nfunction resetPartial(name, partial) {\n  var collection = [];\n  collect$1(this.fragment.items, name, false, collection);\n\n  var promise = runloop.start();\n\n  this.partials[name] = partial;\n  collection.forEach(handleChange);\n\n  runloop.end();\n\n  return promise;\n}\n\n// TODO should resetTemplate be asynchronous? i.e. should it be a case\n// of outro, update template, intro? I reckon probably not, since that\n// could be achieved with unrender-resetTemplate-render. Also, it should\n// conceptually be similar to resetPartial, which couldn't be async\n\nfunction Ractive$resetTemplate(template) {\n  templateConfigurator.init(null, this, { template: template });\n\n  var transitionsEnabled = this.transitionsEnabled;\n  this.transitionsEnabled = false;\n\n  // Is this is a component, we need to set the `shouldDestroy`\n  // flag, otherwise it will assume by default that a parent node\n  // will be detached, and therefore it doesn't need to bother\n  // detaching its own nodes\n  var component = this.component;\n  if (component) { component.shouldDestroy = true; }\n  this.unrender();\n  if (component) { component.shouldDestroy = false; }\n\n  var promise = runloop.start();\n\n  // remove existing fragment and create new one\n  this.fragment.unbind().unrender(true);\n\n  this.fragment = new Fragment({\n    template: this.template,\n    root: this,\n    owner: this\n  });\n\n  var docFrag = createDocumentFragment();\n  this.fragment.bind(this.viewmodel).render(docFrag);\n\n  // if this is a component, its el may not be valid, so find a\n  // target based on the component container\n  if (component && !component.external) {\n    this.fragment.findParentNode().insertBefore(docFrag, component.findNextNode());\n  } else {\n    this.el.insertBefore(docFrag, this.anchor);\n  }\n\n  runloop.end();\n\n  this.transitionsEnabled = transitionsEnabled;\n\n  return promise;\n}\n\nvar reverse = makeArrayMethod('reverse').path;\n\nfunction Ractive$set(keypath, value, options) {\n  var ractive = this;\n\n  var opts = isObjectType(keypath) ? value : options;\n\n  return set(build(ractive, keypath, value, opts && opts.isolated), opts);\n}\n\nvar shift = makeArrayMethod('shift').path;\n\nvar sort = makeArrayMethod('sort').path;\n\nvar splice = makeArrayMethod('splice').path;\n\nfunction Ractive$subtract(keypath, d, options) {\n  var num = isNumber(d) ? -d : -1;\n  var opts = isObjectType(d) ? d : options;\n  return add(this, keypath, num, opts);\n}\n\nfunction Ractive$toggle(keypath, options) {\n  if (!isString(keypath)) {\n    throw new TypeError(badArguments);\n  }\n\n  return set(\n    gather(this, keypath, null, options && options.isolated).map(function (m) { return [m, !m.get()]; }),\n    options\n  );\n}\n\nfunction Ractive$toCSS() {\n  var cssIds = [this.cssId ].concat( this.findAllComponents().map(function (c) { return c.cssId; }));\n  var uniqueCssIds = keys(cssIds.reduce(function (ids, id) { return (ids[id] = true, ids); }, {}));\n  return getCSS(uniqueCssIds);\n}\n\nfunction Ractive$toHTML() {\n  return this.fragment.toString(true);\n}\n\nfunction toText() {\n  return this.fragment.toString(false);\n}\n\nfunction Ractive$transition(name, node, params) {\n  if (node instanceof HTMLElement) {\n    // good to go\n  } else if (isObject(node)) {\n    // omitted, use event node\n    params = node;\n  }\n\n  // if we allow query selector, then it won't work\n  // simple params like \"fast\"\n\n  // else if ( typeof node === 'string' ) {\n  // \t// query selector\n  // \tnode = this.find( node )\n  // }\n\n  node = node || this.event.node;\n\n  if (!node || !node._ractive) {\n    fatal((\"No node was supplied for transition \" + name));\n  }\n\n  params = params || {};\n  var owner = node._ractive.proxy;\n  var transition = new Transition({ owner: owner, up: owner.up, name: name, params: params });\n  transition.bind();\n\n  var promise = runloop.start();\n  runloop.registerTransition(transition);\n  runloop.end();\n\n  promise.then(function () { return transition.unbind(); });\n  return promise;\n}\n\nfunction unlink(here) {\n  var promise = runloop.start();\n  this.viewmodel.joinAll(splitKeypath(here), { lastLink: false }).unlink();\n  runloop.end();\n  return promise;\n}\n\nfunction Ractive$unrender() {\n  if (!this.fragment.rendered) {\n    warnIfDebug('ractive.unrender() was called on a Ractive instance that was not rendered');\n    return Promise.resolve();\n  }\n\n  this.unrendering = true;\n  var promise = runloop.start();\n\n  hooks.unrendering.fire(this);\n\n  // If this is a component, and the component isn't marked for destruction,\n  // don't detach nodes from the DOM unnecessarily\n  var shouldDestroy =\n    !this.component ||\n    (this.component.anchor || {}).shouldDestroy ||\n    this.component.shouldDestroy ||\n    this.shouldDestroy;\n  this.fragment.unrender(shouldDestroy);\n  if (shouldDestroy) { this.destroyed = true; }\n\n  removeFromArray(this.el.__ractive_instances__, this);\n\n  hooks.unrender.fire(this);\n\n  runloop.end();\n  this.unrendering = false;\n\n  return promise;\n}\n\nvar unshift = makeArrayMethod('unshift').path;\n\nfunction Ractive$updateModel(keypath, cascade) {\n  var promise = runloop.start();\n\n  if (!keypath) {\n    this.viewmodel.updateFromBindings(true);\n  } else {\n    this.viewmodel.joinAll(splitKeypath(keypath)).updateFromBindings(cascade !== false);\n  }\n\n  runloop.end();\n\n  return promise;\n}\n\nfunction use() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    p({\n      proto: this$1,\n      Ractive: this$1.constructor.Ractive,\n      instance: this$1\n    });\n  });\n  return this;\n}\n\nvar proto$9 = {\n  add: Ractive$add,\n  animate: Ractive$animate,\n  attachChild: attachChild,\n  compute: Ractive$compute,\n  detach: Ractive$detach,\n  detachChild: detachChild,\n  find: Ractive$find,\n  findAll: Ractive$findAll,\n  findAllComponents: Ractive$findAllComponents,\n  findComponent: Ractive$findComponent,\n  findContainer: Ractive$findContainer,\n  findParent: Ractive$findParent,\n  fire: Ractive$fire,\n  get: Ractive$get,\n  getContext: getContext$2,\n  insert: Ractive$insert,\n  link: link,\n  observe: observe,\n  observeOnce: observeOnce,\n  off: Ractive$off,\n  on: Ractive$on,\n  once: Ractive$once,\n  pop: pop,\n  push: push,\n  readLink: readLink,\n  render: Ractive$render,\n  reset: Ractive$reset,\n  resetPartial: resetPartial,\n  resetTemplate: Ractive$resetTemplate,\n  reverse: reverse,\n  set: Ractive$set,\n  shift: shift,\n  sort: sort,\n  splice: splice,\n  subtract: Ractive$subtract,\n  teardown: Ractive$teardown,\n  toggle: Ractive$toggle,\n  toCSS: Ractive$toCSS,\n  toCss: Ractive$toCSS,\n  toHTML: Ractive$toHTML,\n  toHtml: Ractive$toHTML,\n  toText: toText,\n  transition: Ractive$transition,\n  unlink: unlink,\n  unrender: Ractive$unrender,\n  unshift: unshift,\n  update: Ractive$update,\n  updateModel: Ractive$updateModel,\n  use: use\n};\n\nfunction isInstance(object) {\n  return object && object instanceof this;\n}\n\nfunction styleGet(keypath, opts) {\n  return this._cssModel.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nvar styles = [];\n\nfunction addStyle(id, css) {\n  if (styles.find(function (s) { return s.id === id; }))\n    { throw new Error((\"Extra styles with the id '\" + id + \"' have already been added.\")); }\n  styles.push({ id: id, css: css });\n\n  if (!this.css) {\n    Object.defineProperty(this, 'css', { configurable: false, writable: false, value: buildCSS });\n  }\n\n  if (!this._cssDef) {\n    Object.defineProperty(this, '_cssDef', {\n      configurable: true,\n      writable: false,\n      value: {\n        transform: false,\n        id: 'Ractive.addStyle'\n      }\n    });\n\n    addCSS(this._cssDef);\n  }\n\n  recomputeCSS(this);\n  applyCSS(true);\n}\n\nfunction buildCSS(data) {\n  return styles\n    .map(function (s) { return \"\\n/* ---- extra style \" + (s.id) + \" */\\n\" + (isFunction(s.css) ? s.css(data) : s.css); })\n    .join('');\n}\n\nfunction hasStyle(id) {\n  return !!styles.find(function (s) { return s.id === id; });\n}\n\nfunction sharedSet(keypath, value, options) {\n  var opts = isObjectType(keypath) ? value : options;\n  var model = SharedModel$1;\n\n  return set(build({ viewmodel: model }, keypath, value, true), opts);\n}\n\nfunction sharedGet(keypath, opts) {\n  return SharedModel$1.joinAll(splitKeypath(keypath)).get(true, opts);\n}\n\nfunction use$1() {\n  var this$1 = this;\n  var plugins = [], len = arguments.length;\n  while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  plugins.forEach(function (p) {\n    isFunction(p) &&\n      p({\n        proto: this$1.prototype,\n        Ractive: this$1.Ractive,\n        instance: this$1\n      });\n  });\n  return this;\n}\n\nvar callsSuper = /super\\s*\\(|\\.call\\s*\\(\\s*this/;\n\nfunction extend() {\n  var options = [], len = arguments.length;\n  while ( len-- ) options[ len ] = arguments[ len ];\n\n  if (!options.length) {\n    return extendOne(this);\n  } else {\n    return options.reduce(extendOne, this);\n  }\n}\n\nfunction extendWith(Class, options) {\n  if ( options === void 0 ) options = {};\n\n  return extendOne(this, options, Class);\n}\n\nfunction extendOne(Parent, options, Target) {\n  if ( options === void 0 ) options = {};\n\n  var proto;\n  var Child = isFunction(Target) && Target;\n\n  if (options.prototype instanceof Ractive) {\n    throw new Error(\"Ractive no longer supports multiple inheritance.\");\n  }\n\n  if (Child) {\n    if (!(Child.prototype instanceof Parent)) {\n      throw new Error(\n        \"Only classes that inherit the appropriate prototype may be used with extend\"\n      );\n    }\n    if (!callsSuper.test(Child.toString())) {\n      throw new Error(\"Only classes that call super in their constructor may be used with extend\");\n    }\n\n    proto = Child.prototype;\n  } else {\n    Child = function(options) {\n      if (!(this instanceof Child)) { return new Child(options); }\n\n      construct(this, options || {});\n      initialise(this, options || {}, {});\n    };\n\n    proto = create(Parent.prototype);\n    proto.constructor = Child;\n\n    Child.prototype = proto;\n  }\n\n  // Static properties\n  defineProperties(Child, {\n    // alias prototype as defaults\n    defaults: { value: proto },\n\n    extend: { value: extend, writable: true, configurable: true },\n    extendWith: { value: extendWith, writable: true, configurable: true },\n    extensions: { value: [] },\n    use: { value: use$1 },\n\n    isInstance: { value: isInstance },\n\n    Parent: { value: Parent },\n    Ractive: { value: Ractive },\n\n    styleGet: { value: styleGet.bind(Child), configurable: true },\n    styleSet: { value: setCSSData.bind(Child), configurable: true }\n  });\n\n  // extend configuration\n  config.extend(Parent, proto, options, Child);\n\n  // store event and observer registries on the constructor when extending\n  Child._on = (Parent._on || []).concat(toPairs(options.on));\n  Child._observe = (Parent._observe || []).concat(toPairs(options.observe));\n\n  Parent.extensions.push(Child);\n\n  // attribute defs are not inherited, but they need to be stored\n  if (options.attributes) {\n    var attrs;\n\n    // allow an array of optional props or an object with arrays for optional and required props\n    if (isArray(options.attributes)) {\n      attrs = { optional: options.attributes, required: [] };\n    } else {\n      attrs = options.attributes;\n    }\n\n    // make sure the requisite keys actually store arrays\n    if (!isArray(attrs.required)) { attrs.required = []; }\n    if (!isArray(attrs.optional)) { attrs.optional = []; }\n\n    Child.attributes = attrs;\n  }\n\n  dataConfigurator.extend(Parent, proto, options, Child);\n\n  defineProperty(Child, 'helpers', { writable: true, value: proto.helpers });\n\n  if (isArray(options.use)) { Child.use.apply(Child, options.use); }\n\n  return Child;\n}\n\ndefineProperties(Ractive, {\n  sharedGet: { value: sharedGet },\n  sharedSet: { value: sharedSet },\n  styleGet: { configurable: true, value: styleGet.bind(Ractive) },\n  styleSet: { configurable: true, value: setCSSData.bind(Ractive) },\n  addCSS: { configurable: false, value: addStyle.bind(Ractive) },\n  hasCSS: { configurable: false, value: hasStyle.bind(Ractive) }\n});\n\nfunction macro(fn, opts) {\n  if (!isFunction(fn)) { throw new Error(\"The macro must be a function\"); }\n\n  assign(fn, opts);\n\n  defineProperties(fn, {\n    extensions: { value: [] },\n    _cssIds: { value: [] },\n    cssData: { value: assign(create(this.cssData), fn.cssData || {}) },\n\n    styleGet: { value: styleGet.bind(fn) },\n    styleSet: { value: setCSSData.bind(fn) }\n  });\n\n  defineProperty(fn, '_cssModel', { value: new CSSModel(fn) });\n\n  if (fn.css) { initCSS(fn, fn, fn); }\n\n  this.extensions.push(fn);\n\n  return fn;\n}\n\nfunction joinKeys() {\n  var keys = [], len = arguments.length;\n  while ( len-- ) keys[ len ] = arguments[ len ];\n\n  return keys.map(escapeKey).join('.');\n}\n\nfunction splitKeypath$1(keypath) {\n  return splitKeypath(keypath).map(unescapeKey);\n}\n\nfunction findPlugin(name, type, instance) {\n  return findInViewHierarchy(type, instance, name);\n}\n\nfunction Ractive(options) {\n  if (!(this instanceof Ractive)) { return new Ractive(options); }\n\n  construct(this, options || {});\n  initialise(this, options || {}, {});\n}\n\n// check to see if we're being asked to force Ractive as a global for some weird environments\nif (win && !win.Ractive) {\n  var opts$1 = '';\n  var script =\n    document.currentScript ||\n    /* istanbul ignore next */ document.querySelector('script[data-ractive-options]');\n\n  if (script) { opts$1 = script.getAttribute('data-ractive-options') || ''; }\n\n  /* istanbul ignore next */\n  if (~opts$1.indexOf('ForceGlobal')) { win.Ractive = Ractive; }\n} else if (win) {\n  warn(\"Ractive already appears to be loaded while loading 1.3.8.\");\n}\n\nassign(Ractive.prototype, proto$9, defaults);\nRactive.prototype.constructor = Ractive;\n\n// alias prototype as `defaults`\nRactive.defaults = Ractive.prototype;\n\n// share defaults with the parser\nshared.defaults = Ractive.defaults;\nshared.Ractive = Ractive;\n\n// static properties\ndefineProperties(Ractive, {\n  // debug flag\n  DEBUG: { writable: true, value: true },\n  DEBUG_PROMISES: { writable: true, value: true },\n\n  // static methods:\n  extend: { value: extend },\n  extendWith: { value: extendWith },\n  escapeKey: { value: escapeKey },\n  evalObjectString: { value: parseJSON },\n  findPlugin: { value: findPlugin },\n  getContext: { value: getContext$1 },\n  getCSS: { value: getCSS },\n  isInstance: { value: isInstance },\n  joinKeys: { value: joinKeys },\n  macro: { value: macro },\n  normaliseKeypath: { value: normalise },\n  parse: { value: parse },\n  splitKeypath: { value: splitKeypath$1 },\n  // sharedSet and styleSet are in _extend because circular refs\n  unescapeKey: { value: unescapeKey },\n  use: { value: use$1 },\n\n  // support\n  enhance: { writable: true, value: false },\n  svg: { value: svg },\n  tick: {\n    get: function get() {\n      return batch && batch.promise;\n    }\n  },\n\n  // version\n  VERSION: { value: '1.3.8' },\n\n  // plugins\n  adaptors: { writable: true, value: {} },\n  components: { writable: true, value: {} },\n  decorators: { writable: true, value: {} },\n  easing: { writable: true, value: easing },\n  events: { writable: true, value: {} },\n  extensions: { value: [] },\n  helpers: { writable: true, value: defaults.helpers },\n  interpolators: { writable: true, value: interpolators },\n  partials: { writable: true, value: {} },\n  transitions: { writable: true, value: {} },\n\n  // CSS variables\n  cssData: { configurable: true, value: {} },\n\n  // access to @shared without an instance\n  sharedData: { value: data },\n\n  // for getting the source Ractive lib from a constructor\n  Ractive: { value: Ractive },\n\n  // to allow extending contexts\n  Context: { value: extern.Context.prototype }\n});\n\n// cssData must already be in place\ndefineProperty(Ractive, '_cssModel', {\n  configurable: true,\n  value: new CSSModel(Ractive)\n});\n\ndefineProperty(Ractive.prototype, 'rendered', {\n  get: function get() {\n    return this.fragment && this.fragment.rendered;\n  }\n});\n\nexport default Ractive;\n//# sourceMappingURL=/home/travis/build/ractivejs/ractive/.gobble-build/10-transpile/.cache/ractive.mjs.map\n"],"sourceRoot":""}